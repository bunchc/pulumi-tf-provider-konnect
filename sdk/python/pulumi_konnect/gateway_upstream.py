# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['GatewayUpstreamArgs', 'GatewayUpstream']

@pulumi.input_type
class GatewayUpstreamArgs:
    def __init__(__self__, *,
                 control_plane_id: pulumi.Input[str],
                 algorithm: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']] = None,
                 hash_fallback: Optional[pulumi.Input[str]] = None,
                 hash_fallback_header: Optional[pulumi.Input[str]] = None,
                 hash_fallback_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_fallback_uri_capture: Optional[pulumi.Input[str]] = None,
                 hash_on: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie_path: Optional[pulumi.Input[str]] = None,
                 hash_on_header: Optional[pulumi.Input[str]] = None,
                 hash_on_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_on_uri_capture: Optional[pulumi.Input[str]] = None,
                 healthchecks: Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slots: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_srv_name: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a GatewayUpstream resource.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[str] algorithm: Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        :param pulumi.Input['GatewayUpstreamClientCertificateArgs'] client_certificate: If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        :param pulumi.Input[str] hash_fallback: What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_fallback_header: The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        :param pulumi.Input[str] hash_fallback_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        :param pulumi.Input[str] hash_fallback_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        :param pulumi.Input[str] hash_on: What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_on_cookie: The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        :param pulumi.Input[str] hash_on_cookie_path: The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        :param pulumi.Input[str] hash_on_header: The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        :param pulumi.Input[str] hash_on_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        :param pulumi.Input[str] hash_on_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        :param pulumi.Input[str] host_header: The hostname to be used as `Host` header when proxying requests through Kong.
        :param pulumi.Input[str] name: This is a hostname, which must be equal to the `host` of a Service.
        :param pulumi.Input[int] slots: The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Upstream for grouping and filtering.
        :param pulumi.Input[bool] use_srv_name: If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        pulumi.set(__self__, "control_plane_id", control_plane_id)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if hash_fallback is not None:
            pulumi.set(__self__, "hash_fallback", hash_fallback)
        if hash_fallback_header is not None:
            pulumi.set(__self__, "hash_fallback_header", hash_fallback_header)
        if hash_fallback_query_arg is not None:
            pulumi.set(__self__, "hash_fallback_query_arg", hash_fallback_query_arg)
        if hash_fallback_uri_capture is not None:
            pulumi.set(__self__, "hash_fallback_uri_capture", hash_fallback_uri_capture)
        if hash_on is not None:
            pulumi.set(__self__, "hash_on", hash_on)
        if hash_on_cookie is not None:
            pulumi.set(__self__, "hash_on_cookie", hash_on_cookie)
        if hash_on_cookie_path is not None:
            pulumi.set(__self__, "hash_on_cookie_path", hash_on_cookie_path)
        if hash_on_header is not None:
            pulumi.set(__self__, "hash_on_header", hash_on_header)
        if hash_on_query_arg is not None:
            pulumi.set(__self__, "hash_on_query_arg", hash_on_query_arg)
        if hash_on_uri_capture is not None:
            pulumi.set(__self__, "hash_on_uri_capture", hash_on_uri_capture)
        if healthchecks is not None:
            pulumi.set(__self__, "healthchecks", healthchecks)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_srv_name is not None:
            pulumi.set(__self__, "use_srv_name", use_srv_name)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> pulumi.Input[str]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @control_plane_id.setter
    def control_plane_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "control_plane_id", value)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']]:
        """
        If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="hashFallback")
    def hash_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_fallback")

    @hash_fallback.setter
    def hash_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback", value)

    @property
    @pulumi.getter(name="hashFallbackHeader")
    def hash_fallback_header(self) -> Optional[pulumi.Input[str]]:
        """
        The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        """
        return pulumi.get(self, "hash_fallback_header")

    @hash_fallback_header.setter
    def hash_fallback_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_header", value)

    @property
    @pulumi.getter(name="hashFallbackQueryArg")
    def hash_fallback_query_arg(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_fallback_query_arg")

    @hash_fallback_query_arg.setter
    def hash_fallback_query_arg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_query_arg", value)

    @property
    @pulumi.getter(name="hashFallbackUriCapture")
    def hash_fallback_uri_capture(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_fallback_uri_capture")

    @hash_fallback_uri_capture.setter
    def hash_fallback_uri_capture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_uri_capture", value)

    @property
    @pulumi.getter(name="hashOn")
    def hash_on(self) -> Optional[pulumi.Input[str]]:
        """
        What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_on")

    @hash_on.setter
    def hash_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on", value)

    @property
    @pulumi.getter(name="hashOnCookie")
    def hash_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        """
        return pulumi.get(self, "hash_on_cookie")

    @hash_on_cookie.setter
    def hash_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_cookie", value)

    @property
    @pulumi.getter(name="hashOnCookiePath")
    def hash_on_cookie_path(self) -> Optional[pulumi.Input[str]]:
        """
        The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        """
        return pulumi.get(self, "hash_on_cookie_path")

    @hash_on_cookie_path.setter
    def hash_on_cookie_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_cookie_path", value)

    @property
    @pulumi.getter(name="hashOnHeader")
    def hash_on_header(self) -> Optional[pulumi.Input[str]]:
        """
        The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        """
        return pulumi.get(self, "hash_on_header")

    @hash_on_header.setter
    def hash_on_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_header", value)

    @property
    @pulumi.getter(name="hashOnQueryArg")
    def hash_on_query_arg(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_on_query_arg")

    @hash_on_query_arg.setter
    def hash_on_query_arg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_query_arg", value)

    @property
    @pulumi.getter(name="hashOnUriCapture")
    def hash_on_uri_capture(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_on_uri_capture")

    @hash_on_uri_capture.setter
    def hash_on_uri_capture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_uri_capture", value)

    @property
    @pulumi.getter
    def healthchecks(self) -> Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']]:
        return pulumi.get(self, "healthchecks")

    @healthchecks.setter
    def healthchecks(self, value: Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']]):
        pulumi.set(self, "healthchecks", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname to be used as `Host` header when proxying requests through Kong.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This is a hostname, which must be equal to the `host` of a Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[int]]:
        """
        The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slots", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of strings associated with the Upstream for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="useSrvName")
    def use_srv_name(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        return pulumi.get(self, "use_srv_name")

    @use_srv_name.setter
    def use_srv_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_srv_name", value)


@pulumi.input_type
class _GatewayUpstreamState:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']] = None,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[int]] = None,
                 hash_fallback: Optional[pulumi.Input[str]] = None,
                 hash_fallback_header: Optional[pulumi.Input[str]] = None,
                 hash_fallback_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_fallback_uri_capture: Optional[pulumi.Input[str]] = None,
                 hash_on: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie_path: Optional[pulumi.Input[str]] = None,
                 hash_on_header: Optional[pulumi.Input[str]] = None,
                 hash_on_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_on_uri_capture: Optional[pulumi.Input[str]] = None,
                 healthchecks: Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slots: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 updated_at: Optional[pulumi.Input[int]] = None,
                 use_srv_name: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering GatewayUpstream resources.
        :param pulumi.Input[str] algorithm: Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        :param pulumi.Input['GatewayUpstreamClientCertificateArgs'] client_certificate: If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[int] created_at: Unix epoch when the resource was created.
        :param pulumi.Input[str] hash_fallback: What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_fallback_header: The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        :param pulumi.Input[str] hash_fallback_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        :param pulumi.Input[str] hash_fallback_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        :param pulumi.Input[str] hash_on: What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_on_cookie: The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        :param pulumi.Input[str] hash_on_cookie_path: The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        :param pulumi.Input[str] hash_on_header: The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        :param pulumi.Input[str] hash_on_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        :param pulumi.Input[str] hash_on_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        :param pulumi.Input[str] host_header: The hostname to be used as `Host` header when proxying requests through Kong.
        :param pulumi.Input[str] name: This is a hostname, which must be equal to the `host` of a Service.
        :param pulumi.Input[int] slots: The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Upstream for grouping and filtering.
        :param pulumi.Input[int] updated_at: Unix epoch when the resource was last updated.
        :param pulumi.Input[bool] use_srv_name: If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if control_plane_id is not None:
            pulumi.set(__self__, "control_plane_id", control_plane_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if hash_fallback is not None:
            pulumi.set(__self__, "hash_fallback", hash_fallback)
        if hash_fallback_header is not None:
            pulumi.set(__self__, "hash_fallback_header", hash_fallback_header)
        if hash_fallback_query_arg is not None:
            pulumi.set(__self__, "hash_fallback_query_arg", hash_fallback_query_arg)
        if hash_fallback_uri_capture is not None:
            pulumi.set(__self__, "hash_fallback_uri_capture", hash_fallback_uri_capture)
        if hash_on is not None:
            pulumi.set(__self__, "hash_on", hash_on)
        if hash_on_cookie is not None:
            pulumi.set(__self__, "hash_on_cookie", hash_on_cookie)
        if hash_on_cookie_path is not None:
            pulumi.set(__self__, "hash_on_cookie_path", hash_on_cookie_path)
        if hash_on_header is not None:
            pulumi.set(__self__, "hash_on_header", hash_on_header)
        if hash_on_query_arg is not None:
            pulumi.set(__self__, "hash_on_query_arg", hash_on_query_arg)
        if hash_on_uri_capture is not None:
            pulumi.set(__self__, "hash_on_uri_capture", hash_on_uri_capture)
        if healthchecks is not None:
            pulumi.set(__self__, "healthchecks", healthchecks)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if use_srv_name is not None:
            pulumi.set(__self__, "use_srv_name", use_srv_name)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']]:
        """
        If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input['GatewayUpstreamClientCertificateArgs']]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @control_plane_id.setter
    def control_plane_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_id", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[int]]:
        """
        Unix epoch when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="hashFallback")
    def hash_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_fallback")

    @hash_fallback.setter
    def hash_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback", value)

    @property
    @pulumi.getter(name="hashFallbackHeader")
    def hash_fallback_header(self) -> Optional[pulumi.Input[str]]:
        """
        The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        """
        return pulumi.get(self, "hash_fallback_header")

    @hash_fallback_header.setter
    def hash_fallback_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_header", value)

    @property
    @pulumi.getter(name="hashFallbackQueryArg")
    def hash_fallback_query_arg(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_fallback_query_arg")

    @hash_fallback_query_arg.setter
    def hash_fallback_query_arg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_query_arg", value)

    @property
    @pulumi.getter(name="hashFallbackUriCapture")
    def hash_fallback_uri_capture(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_fallback_uri_capture")

    @hash_fallback_uri_capture.setter
    def hash_fallback_uri_capture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_fallback_uri_capture", value)

    @property
    @pulumi.getter(name="hashOn")
    def hash_on(self) -> Optional[pulumi.Input[str]]:
        """
        What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_on")

    @hash_on.setter
    def hash_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on", value)

    @property
    @pulumi.getter(name="hashOnCookie")
    def hash_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        """
        return pulumi.get(self, "hash_on_cookie")

    @hash_on_cookie.setter
    def hash_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_cookie", value)

    @property
    @pulumi.getter(name="hashOnCookiePath")
    def hash_on_cookie_path(self) -> Optional[pulumi.Input[str]]:
        """
        The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        """
        return pulumi.get(self, "hash_on_cookie_path")

    @hash_on_cookie_path.setter
    def hash_on_cookie_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_cookie_path", value)

    @property
    @pulumi.getter(name="hashOnHeader")
    def hash_on_header(self) -> Optional[pulumi.Input[str]]:
        """
        The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        """
        return pulumi.get(self, "hash_on_header")

    @hash_on_header.setter
    def hash_on_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_header", value)

    @property
    @pulumi.getter(name="hashOnQueryArg")
    def hash_on_query_arg(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_on_query_arg")

    @hash_on_query_arg.setter
    def hash_on_query_arg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_query_arg", value)

    @property
    @pulumi.getter(name="hashOnUriCapture")
    def hash_on_uri_capture(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_on_uri_capture")

    @hash_on_uri_capture.setter
    def hash_on_uri_capture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_on_uri_capture", value)

    @property
    @pulumi.getter
    def healthchecks(self) -> Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']]:
        return pulumi.get(self, "healthchecks")

    @healthchecks.setter
    def healthchecks(self, value: Optional[pulumi.Input['GatewayUpstreamHealthchecksArgs']]):
        pulumi.set(self, "healthchecks", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname to be used as `Host` header when proxying requests through Kong.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This is a hostname, which must be equal to the `host` of a Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[int]]:
        """
        The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slots", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of strings associated with the Upstream for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[int]]:
        """
        Unix epoch when the resource was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="useSrvName")
    def use_srv_name(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        return pulumi.get(self, "use_srv_name")

    @use_srv_name.setter
    def use_srv_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_srv_name", value)


class GatewayUpstream(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamClientCertificateArgs']]] = None,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 hash_fallback: Optional[pulumi.Input[str]] = None,
                 hash_fallback_header: Optional[pulumi.Input[str]] = None,
                 hash_fallback_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_fallback_uri_capture: Optional[pulumi.Input[str]] = None,
                 hash_on: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie_path: Optional[pulumi.Input[str]] = None,
                 hash_on_header: Optional[pulumi.Input[str]] = None,
                 hash_on_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_on_uri_capture: Optional[pulumi.Input[str]] = None,
                 healthchecks: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamHealthchecksArgs']]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slots: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_srv_name: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        GatewayUpstream Resource

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] algorithm: Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        :param pulumi.Input[pulumi.InputType['GatewayUpstreamClientCertificateArgs']] client_certificate: If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[str] hash_fallback: What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_fallback_header: The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        :param pulumi.Input[str] hash_fallback_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        :param pulumi.Input[str] hash_fallback_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        :param pulumi.Input[str] hash_on: What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_on_cookie: The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        :param pulumi.Input[str] hash_on_cookie_path: The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        :param pulumi.Input[str] hash_on_header: The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        :param pulumi.Input[str] hash_on_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        :param pulumi.Input[str] hash_on_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        :param pulumi.Input[str] host_header: The hostname to be used as `Host` header when proxying requests through Kong.
        :param pulumi.Input[str] name: This is a hostname, which must be equal to the `host` of a Service.
        :param pulumi.Input[int] slots: The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Upstream for grouping and filtering.
        :param pulumi.Input[bool] use_srv_name: If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: GatewayUpstreamArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        GatewayUpstream Resource

        :param str resource_name: The name of the resource.
        :param GatewayUpstreamArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(GatewayUpstreamArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamClientCertificateArgs']]] = None,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 hash_fallback: Optional[pulumi.Input[str]] = None,
                 hash_fallback_header: Optional[pulumi.Input[str]] = None,
                 hash_fallback_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_fallback_uri_capture: Optional[pulumi.Input[str]] = None,
                 hash_on: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie: Optional[pulumi.Input[str]] = None,
                 hash_on_cookie_path: Optional[pulumi.Input[str]] = None,
                 hash_on_header: Optional[pulumi.Input[str]] = None,
                 hash_on_query_arg: Optional[pulumi.Input[str]] = None,
                 hash_on_uri_capture: Optional[pulumi.Input[str]] = None,
                 healthchecks: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamHealthchecksArgs']]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slots: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_srv_name: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = GatewayUpstreamArgs.__new__(GatewayUpstreamArgs)

            __props__.__dict__["algorithm"] = algorithm
            __props__.__dict__["client_certificate"] = client_certificate
            if control_plane_id is None and not opts.urn:
                raise TypeError("Missing required property 'control_plane_id'")
            __props__.__dict__["control_plane_id"] = control_plane_id
            __props__.__dict__["hash_fallback"] = hash_fallback
            __props__.__dict__["hash_fallback_header"] = hash_fallback_header
            __props__.__dict__["hash_fallback_query_arg"] = hash_fallback_query_arg
            __props__.__dict__["hash_fallback_uri_capture"] = hash_fallback_uri_capture
            __props__.__dict__["hash_on"] = hash_on
            __props__.__dict__["hash_on_cookie"] = hash_on_cookie
            __props__.__dict__["hash_on_cookie_path"] = hash_on_cookie_path
            __props__.__dict__["hash_on_header"] = hash_on_header
            __props__.__dict__["hash_on_query_arg"] = hash_on_query_arg
            __props__.__dict__["hash_on_uri_capture"] = hash_on_uri_capture
            __props__.__dict__["healthchecks"] = healthchecks
            __props__.__dict__["host_header"] = host_header
            __props__.__dict__["name"] = name
            __props__.__dict__["slots"] = slots
            __props__.__dict__["tags"] = tags
            __props__.__dict__["use_srv_name"] = use_srv_name
            __props__.__dict__["created_at"] = None
            __props__.__dict__["updated_at"] = None
        super(GatewayUpstream, __self__).__init__(
            'konnect:index/gatewayUpstream:GatewayUpstream',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            algorithm: Optional[pulumi.Input[str]] = None,
            client_certificate: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamClientCertificateArgs']]] = None,
            control_plane_id: Optional[pulumi.Input[str]] = None,
            created_at: Optional[pulumi.Input[int]] = None,
            hash_fallback: Optional[pulumi.Input[str]] = None,
            hash_fallback_header: Optional[pulumi.Input[str]] = None,
            hash_fallback_query_arg: Optional[pulumi.Input[str]] = None,
            hash_fallback_uri_capture: Optional[pulumi.Input[str]] = None,
            hash_on: Optional[pulumi.Input[str]] = None,
            hash_on_cookie: Optional[pulumi.Input[str]] = None,
            hash_on_cookie_path: Optional[pulumi.Input[str]] = None,
            hash_on_header: Optional[pulumi.Input[str]] = None,
            hash_on_query_arg: Optional[pulumi.Input[str]] = None,
            hash_on_uri_capture: Optional[pulumi.Input[str]] = None,
            healthchecks: Optional[pulumi.Input[pulumi.InputType['GatewayUpstreamHealthchecksArgs']]] = None,
            host_header: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            slots: Optional[pulumi.Input[int]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            updated_at: Optional[pulumi.Input[int]] = None,
            use_srv_name: Optional[pulumi.Input[bool]] = None) -> 'GatewayUpstream':
        """
        Get an existing GatewayUpstream resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] algorithm: Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        :param pulumi.Input[pulumi.InputType['GatewayUpstreamClientCertificateArgs']] client_certificate: If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[int] created_at: Unix epoch when the resource was created.
        :param pulumi.Input[str] hash_fallback: What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_fallback_header: The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        :param pulumi.Input[str] hash_fallback_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        :param pulumi.Input[str] hash_fallback_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        :param pulumi.Input[str] hash_on: What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        :param pulumi.Input[str] hash_on_cookie: The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        :param pulumi.Input[str] hash_on_cookie_path: The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        :param pulumi.Input[str] hash_on_header: The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        :param pulumi.Input[str] hash_on_query_arg: The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        :param pulumi.Input[str] hash_on_uri_capture: The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        :param pulumi.Input[str] host_header: The hostname to be used as `Host` header when proxying requests through Kong.
        :param pulumi.Input[str] name: This is a hostname, which must be equal to the `host` of a Service.
        :param pulumi.Input[int] slots: The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Upstream for grouping and filtering.
        :param pulumi.Input[int] updated_at: Unix epoch when the resource was last updated.
        :param pulumi.Input[bool] use_srv_name: If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _GatewayUpstreamState.__new__(_GatewayUpstreamState)

        __props__.__dict__["algorithm"] = algorithm
        __props__.__dict__["client_certificate"] = client_certificate
        __props__.__dict__["control_plane_id"] = control_plane_id
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["hash_fallback"] = hash_fallback
        __props__.__dict__["hash_fallback_header"] = hash_fallback_header
        __props__.__dict__["hash_fallback_query_arg"] = hash_fallback_query_arg
        __props__.__dict__["hash_fallback_uri_capture"] = hash_fallback_uri_capture
        __props__.__dict__["hash_on"] = hash_on
        __props__.__dict__["hash_on_cookie"] = hash_on_cookie
        __props__.__dict__["hash_on_cookie_path"] = hash_on_cookie_path
        __props__.__dict__["hash_on_header"] = hash_on_header
        __props__.__dict__["hash_on_query_arg"] = hash_on_query_arg
        __props__.__dict__["hash_on_uri_capture"] = hash_on_uri_capture
        __props__.__dict__["healthchecks"] = healthchecks
        __props__.__dict__["host_header"] = host_header
        __props__.__dict__["name"] = name
        __props__.__dict__["slots"] = slots
        __props__.__dict__["tags"] = tags
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["use_srv_name"] = use_srv_name
        return GatewayUpstream(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Output[str]:
        """
        Which load balancing algorithm to use. must be one of ["consistent-hashing", "least-connections", "round-robin", "latency"]
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Output['outputs.GatewayUpstreamClientCertificate']:
        """
        If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> pulumi.Output[str]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[int]:
        """
        Unix epoch when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="hashFallback")
    def hash_fallback(self) -> pulumi.Output[str]:
        """
        What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_fallback")

    @property
    @pulumi.getter(name="hashFallbackHeader")
    def hash_fallback_header(self) -> pulumi.Output[str]:
        """
        The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
        """
        return pulumi.get(self, "hash_fallback_header")

    @property
    @pulumi.getter(name="hashFallbackQueryArg")
    def hash_fallback_query_arg(self) -> pulumi.Output[str]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_fallback_query_arg")

    @property
    @pulumi.getter(name="hashFallbackUriCapture")
    def hash_fallback_uri_capture(self) -> pulumi.Output[str]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_fallback_uri_capture")

    @property
    @pulumi.getter(name="hashOn")
    def hash_on(self) -> pulumi.Output[str]:
        """
        What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing. must be one of ["none", "consumer", "ip", "header", "cookie", "path", "query*arg", "uri*capture"]
        """
        return pulumi.get(self, "hash_on")

    @property
    @pulumi.getter(name="hashOnCookie")
    def hash_on_cookie(self) -> pulumi.Output[str]:
        """
        The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
        """
        return pulumi.get(self, "hash_on_cookie")

    @property
    @pulumi.getter(name="hashOnCookiePath")
    def hash_on_cookie_path(self) -> pulumi.Output[str]:
        """
        The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
        """
        return pulumi.get(self, "hash_on_cookie_path")

    @property
    @pulumi.getter(name="hashOnHeader")
    def hash_on_header(self) -> pulumi.Output[str]:
        """
        The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
        """
        return pulumi.get(self, "hash_on_header")

    @property
    @pulumi.getter(name="hashOnQueryArg")
    def hash_on_query_arg(self) -> pulumi.Output[str]:
        """
        The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
        """
        return pulumi.get(self, "hash_on_query_arg")

    @property
    @pulumi.getter(name="hashOnUriCapture")
    def hash_on_uri_capture(self) -> pulumi.Output[str]:
        """
        The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
        """
        return pulumi.get(self, "hash_on_uri_capture")

    @property
    @pulumi.getter
    def healthchecks(self) -> pulumi.Output['outputs.GatewayUpstreamHealthchecks']:
        return pulumi.get(self, "healthchecks")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> pulumi.Output[str]:
        """
        The hostname to be used as `Host` header when proxying requests through Kong.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        This is a hostname, which must be equal to the `host` of a Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def slots(self) -> pulumi.Output[int]:
        """
        The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
        """
        return pulumi.get(self, "slots")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Sequence[str]]:
        """
        An optional set of strings associated with the Upstream for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[int]:
        """
        Unix epoch when the resource was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="useSrvName")
    def use_srv_name(self) -> pulumi.Output[bool]:
        """
        If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
        """
        return pulumi.get(self, "use_srv_name")

