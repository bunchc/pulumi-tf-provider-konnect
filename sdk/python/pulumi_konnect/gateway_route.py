# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['GatewayRouteArgs', 'GatewayRoute']

@pulumi.input_type
class GatewayRouteArgs:
    def __init__(__self__, *,
                 control_plane_id: pulumi.Input[str],
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 https_redirect_status_code: Optional[pulumi.Input[int]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path_handling: Optional[pulumi.Input[str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preserve_host: Optional[pulumi.Input[bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 regex_priority: Optional[pulumi.Input[int]] = None,
                 request_buffering: Optional[pulumi.Input[bool]] = None,
                 response_buffering: Optional[pulumi.Input[bool]] = None,
                 service: Optional[pulumi.Input['GatewayRouteServiceArgs']] = None,
                 snis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]] = None,
                 strip_path: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a GatewayRoute resource.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]] destinations: A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: A list of domain names that match this Route. Note that the hosts value is case sensitive.
        :param pulumi.Input[int] https_redirect_status_code: The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: A list of HTTP methods that match this Route.
        :param pulumi.Input[str] name: The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        :param pulumi.Input[str] path_handling: Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: A list of paths that match this Route.
        :param pulumi.Input[bool] preserve_host: When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        :param pulumi.Input[int] regex_priority: A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        :param pulumi.Input[bool] request_buffering: Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        :param pulumi.Input[bool] response_buffering: Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        :param pulumi.Input['GatewayRouteServiceArgs'] service: The Service this Route is associated to. This is where the Route proxies traffic to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] snis: A list of SNIs that match this Route when using stream routing.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]] sources: A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[bool] strip_path: When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Route for grouping and filtering.
        """
        pulumi.set(__self__, "control_plane_id", control_plane_id)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if https_redirect_status_code is not None:
            pulumi.set(__self__, "https_redirect_status_code", https_redirect_status_code)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_handling is not None:
            pulumi.set(__self__, "path_handling", path_handling)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if preserve_host is not None:
            pulumi.set(__self__, "preserve_host", preserve_host)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if regex_priority is not None:
            pulumi.set(__self__, "regex_priority", regex_priority)
        if request_buffering is not None:
            pulumi.set(__self__, "request_buffering", request_buffering)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if snis is not None:
            pulumi.set(__self__, "snis", snis)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if strip_path is not None:
            pulumi.set(__self__, "strip_path", strip_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> pulumi.Input[str]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @control_plane_id.setter
    def control_plane_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "control_plane_id", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]]:
        """
        A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of domain names that match this Route. Note that the hosts value is case sensitive.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="httpsRedirectStatusCode")
    def https_redirect_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        """
        return pulumi.get(self, "https_redirect_status_code")

    @https_redirect_status_code.setter
    def https_redirect_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_redirect_status_code", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of HTTP methods that match this Route.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathHandling")
    def path_handling(self) -> Optional[pulumi.Input[str]]:
        """
        Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        """
        return pulumi.get(self, "path_handling")

    @path_handling.setter
    def path_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_handling", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of paths that match this Route.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="preserveHost")
    def preserve_host(self) -> Optional[pulumi.Input[bool]]:
        """
        When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        """
        return pulumi.get(self, "preserve_host")

    @preserve_host.setter
    def preserve_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_host", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="regexPriority")
    def regex_priority(self) -> Optional[pulumi.Input[int]]:
        """
        A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        """
        return pulumi.get(self, "regex_priority")

    @regex_priority.setter
    def regex_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "regex_priority", value)

    @property
    @pulumi.getter(name="requestBuffering")
    def request_buffering(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        """
        return pulumi.get(self, "request_buffering")

    @request_buffering.setter
    def request_buffering(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_buffering", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        """
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['GatewayRouteServiceArgs']]:
        """
        The Service this Route is associated to. This is where the Route proxies traffic to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['GatewayRouteServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def snis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of SNIs that match this Route when using stream routing.
        """
        return pulumi.get(self, "snis")

    @snis.setter
    def snis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "snis", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]]:
        """
        A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="stripPath")
    def strip_path(self) -> Optional[pulumi.Input[bool]]:
        """
        When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        """
        return pulumi.get(self, "strip_path")

    @strip_path.setter
    def strip_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strip_path", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of strings associated with the Route for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class _GatewayRouteState:
    def __init__(__self__, *,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[int]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 https_redirect_status_code: Optional[pulumi.Input[int]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path_handling: Optional[pulumi.Input[str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preserve_host: Optional[pulumi.Input[bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 regex_priority: Optional[pulumi.Input[int]] = None,
                 request_buffering: Optional[pulumi.Input[bool]] = None,
                 response_buffering: Optional[pulumi.Input[bool]] = None,
                 service: Optional[pulumi.Input['GatewayRouteServiceArgs']] = None,
                 snis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]] = None,
                 strip_path: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 updated_at: Optional[pulumi.Input[int]] = None):
        """
        Input properties used for looking up and filtering GatewayRoute resources.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[int] created_at: Unix epoch when the resource was created.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]] destinations: A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: A list of domain names that match this Route. Note that the hosts value is case sensitive.
        :param pulumi.Input[int] https_redirect_status_code: The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: A list of HTTP methods that match this Route.
        :param pulumi.Input[str] name: The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        :param pulumi.Input[str] path_handling: Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: A list of paths that match this Route.
        :param pulumi.Input[bool] preserve_host: When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        :param pulumi.Input[int] regex_priority: A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        :param pulumi.Input[bool] request_buffering: Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        :param pulumi.Input[bool] response_buffering: Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        :param pulumi.Input['GatewayRouteServiceArgs'] service: The Service this Route is associated to. This is where the Route proxies traffic to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] snis: A list of SNIs that match this Route when using stream routing.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]] sources: A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[bool] strip_path: When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Route for grouping and filtering.
        :param pulumi.Input[int] updated_at: Unix epoch when the resource was last updated.
        """
        if control_plane_id is not None:
            pulumi.set(__self__, "control_plane_id", control_plane_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if https_redirect_status_code is not None:
            pulumi.set(__self__, "https_redirect_status_code", https_redirect_status_code)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_handling is not None:
            pulumi.set(__self__, "path_handling", path_handling)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if preserve_host is not None:
            pulumi.set(__self__, "preserve_host", preserve_host)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if regex_priority is not None:
            pulumi.set(__self__, "regex_priority", regex_priority)
        if request_buffering is not None:
            pulumi.set(__self__, "request_buffering", request_buffering)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if snis is not None:
            pulumi.set(__self__, "snis", snis)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if strip_path is not None:
            pulumi.set(__self__, "strip_path", strip_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @control_plane_id.setter
    def control_plane_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_id", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[int]]:
        """
        Unix epoch when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]]:
        """
        A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of domain names that match this Route. Note that the hosts value is case sensitive.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="httpsRedirectStatusCode")
    def https_redirect_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        """
        return pulumi.get(self, "https_redirect_status_code")

    @https_redirect_status_code.setter
    def https_redirect_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_redirect_status_code", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of HTTP methods that match this Route.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathHandling")
    def path_handling(self) -> Optional[pulumi.Input[str]]:
        """
        Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        """
        return pulumi.get(self, "path_handling")

    @path_handling.setter
    def path_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_handling", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of paths that match this Route.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="preserveHost")
    def preserve_host(self) -> Optional[pulumi.Input[bool]]:
        """
        When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        """
        return pulumi.get(self, "preserve_host")

    @preserve_host.setter
    def preserve_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_host", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="regexPriority")
    def regex_priority(self) -> Optional[pulumi.Input[int]]:
        """
        A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        """
        return pulumi.get(self, "regex_priority")

    @regex_priority.setter
    def regex_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "regex_priority", value)

    @property
    @pulumi.getter(name="requestBuffering")
    def request_buffering(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        """
        return pulumi.get(self, "request_buffering")

    @request_buffering.setter
    def request_buffering(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_buffering", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        """
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['GatewayRouteServiceArgs']]:
        """
        The Service this Route is associated to. This is where the Route proxies traffic to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['GatewayRouteServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def snis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of SNIs that match this Route when using stream routing.
        """
        return pulumi.get(self, "snis")

    @snis.setter
    def snis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "snis", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]]:
        """
        A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRouteSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="stripPath")
    def strip_path(self) -> Optional[pulumi.Input[bool]]:
        """
        When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        """
        return pulumi.get(self, "strip_path")

    @strip_path.setter
    def strip_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strip_path", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of strings associated with the Route for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[int]]:
        """
        Unix epoch when the resource was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_at", value)


class GatewayRoute(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteDestinationArgs']]]]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 https_redirect_status_code: Optional[pulumi.Input[int]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path_handling: Optional[pulumi.Input[str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preserve_host: Optional[pulumi.Input[bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 regex_priority: Optional[pulumi.Input[int]] = None,
                 request_buffering: Optional[pulumi.Input[bool]] = None,
                 response_buffering: Optional[pulumi.Input[bool]] = None,
                 service: Optional[pulumi.Input[pulumi.InputType['GatewayRouteServiceArgs']]] = None,
                 snis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteSourceArgs']]]]] = None,
                 strip_path: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        GatewayRoute Resource

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteDestinationArgs']]]] destinations: A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: A list of domain names that match this Route. Note that the hosts value is case sensitive.
        :param pulumi.Input[int] https_redirect_status_code: The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: A list of HTTP methods that match this Route.
        :param pulumi.Input[str] name: The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        :param pulumi.Input[str] path_handling: Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: A list of paths that match this Route.
        :param pulumi.Input[bool] preserve_host: When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        :param pulumi.Input[int] regex_priority: A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        :param pulumi.Input[bool] request_buffering: Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        :param pulumi.Input[bool] response_buffering: Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        :param pulumi.Input[pulumi.InputType['GatewayRouteServiceArgs']] service: The Service this Route is associated to. This is where the Route proxies traffic to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] snis: A list of SNIs that match this Route when using stream routing.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteSourceArgs']]]] sources: A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[bool] strip_path: When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Route for grouping and filtering.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: GatewayRouteArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        GatewayRoute Resource

        :param str resource_name: The name of the resource.
        :param GatewayRouteArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(GatewayRouteArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 control_plane_id: Optional[pulumi.Input[str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteDestinationArgs']]]]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 https_redirect_status_code: Optional[pulumi.Input[int]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path_handling: Optional[pulumi.Input[str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preserve_host: Optional[pulumi.Input[bool]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 regex_priority: Optional[pulumi.Input[int]] = None,
                 request_buffering: Optional[pulumi.Input[bool]] = None,
                 response_buffering: Optional[pulumi.Input[bool]] = None,
                 service: Optional[pulumi.Input[pulumi.InputType['GatewayRouteServiceArgs']]] = None,
                 snis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteSourceArgs']]]]] = None,
                 strip_path: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = GatewayRouteArgs.__new__(GatewayRouteArgs)

            if control_plane_id is None and not opts.urn:
                raise TypeError("Missing required property 'control_plane_id'")
            __props__.__dict__["control_plane_id"] = control_plane_id
            __props__.__dict__["destinations"] = destinations
            __props__.__dict__["headers"] = headers
            __props__.__dict__["hosts"] = hosts
            __props__.__dict__["https_redirect_status_code"] = https_redirect_status_code
            __props__.__dict__["methods"] = methods
            __props__.__dict__["name"] = name
            __props__.__dict__["path_handling"] = path_handling
            __props__.__dict__["paths"] = paths
            __props__.__dict__["preserve_host"] = preserve_host
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["regex_priority"] = regex_priority
            __props__.__dict__["request_buffering"] = request_buffering
            __props__.__dict__["response_buffering"] = response_buffering
            __props__.__dict__["service"] = service
            __props__.__dict__["snis"] = snis
            __props__.__dict__["sources"] = sources
            __props__.__dict__["strip_path"] = strip_path
            __props__.__dict__["tags"] = tags
            __props__.__dict__["created_at"] = None
            __props__.__dict__["updated_at"] = None
        super(GatewayRoute, __self__).__init__(
            'konnect:index/gatewayRoute:GatewayRoute',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            control_plane_id: Optional[pulumi.Input[str]] = None,
            created_at: Optional[pulumi.Input[int]] = None,
            destinations: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteDestinationArgs']]]]] = None,
            headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            https_redirect_status_code: Optional[pulumi.Input[int]] = None,
            methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            name: Optional[pulumi.Input[str]] = None,
            path_handling: Optional[pulumi.Input[str]] = None,
            paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            preserve_host: Optional[pulumi.Input[bool]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            regex_priority: Optional[pulumi.Input[int]] = None,
            request_buffering: Optional[pulumi.Input[bool]] = None,
            response_buffering: Optional[pulumi.Input[bool]] = None,
            service: Optional[pulumi.Input[pulumi.InputType['GatewayRouteServiceArgs']]] = None,
            snis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteSourceArgs']]]]] = None,
            strip_path: Optional[pulumi.Input[bool]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            updated_at: Optional[pulumi.Input[int]] = None) -> 'GatewayRoute':
        """
        Get an existing GatewayRoute resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] control_plane_id: The UUID of your control plane. This variable is available in the Konnect manager.
        :param pulumi.Input[int] created_at: Unix epoch when the resource was created.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteDestinationArgs']]]] destinations: A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: A list of domain names that match this Route. Note that the hosts value is case sensitive.
        :param pulumi.Input[int] https_redirect_status_code: The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: A list of HTTP methods that match this Route.
        :param pulumi.Input[str] name: The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        :param pulumi.Input[str] path_handling: Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: A list of paths that match this Route.
        :param pulumi.Input[bool] preserve_host: When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        :param pulumi.Input[int] regex_priority: A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        :param pulumi.Input[bool] request_buffering: Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        :param pulumi.Input[bool] response_buffering: Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        :param pulumi.Input[pulumi.InputType['GatewayRouteServiceArgs']] service: The Service this Route is associated to. This is where the Route proxies traffic to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] snis: A list of SNIs that match this Route when using stream routing.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GatewayRouteSourceArgs']]]] sources: A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        :param pulumi.Input[bool] strip_path: When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: An optional set of strings associated with the Route for grouping and filtering.
        :param pulumi.Input[int] updated_at: Unix epoch when the resource was last updated.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _GatewayRouteState.__new__(_GatewayRouteState)

        __props__.__dict__["control_plane_id"] = control_plane_id
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["destinations"] = destinations
        __props__.__dict__["headers"] = headers
        __props__.__dict__["hosts"] = hosts
        __props__.__dict__["https_redirect_status_code"] = https_redirect_status_code
        __props__.__dict__["methods"] = methods
        __props__.__dict__["name"] = name
        __props__.__dict__["path_handling"] = path_handling
        __props__.__dict__["paths"] = paths
        __props__.__dict__["preserve_host"] = preserve_host
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["regex_priority"] = regex_priority
        __props__.__dict__["request_buffering"] = request_buffering
        __props__.__dict__["response_buffering"] = response_buffering
        __props__.__dict__["service"] = service
        __props__.__dict__["snis"] = snis
        __props__.__dict__["sources"] = sources
        __props__.__dict__["strip_path"] = strip_path
        __props__.__dict__["tags"] = tags
        __props__.__dict__["updated_at"] = updated_at
        return GatewayRoute(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> pulumi.Output[str]:
        """
        The UUID of your control plane. This variable is available in the Konnect manager.
        """
        return pulumi.get(self, "control_plane_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[int]:
        """
        Unix epoch when the resource was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def destinations(self) -> pulumi.Output[Sequence['outputs.GatewayRouteDestination']]:
        """
        A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def headers(self) -> pulumi.Output[Mapping[str, str]]:
        """
        One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of domain names that match this Route. Note that the hosts value is case sensitive.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="httpsRedirectStatusCode")
    def https_redirect_status_code(self) -> pulumi.Output[int]:
        """
        The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
        """
        return pulumi.get(self, "https_redirect_status_code")

    @property
    @pulumi.getter
    def methods(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of HTTP methods that match this Route.
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pathHandling")
    def path_handling(self) -> pulumi.Output[str]:
        """
        Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
        """
        return pulumi.get(self, "path_handling")

    @property
    @pulumi.getter
    def paths(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of paths that match this Route.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="preserveHost")
    def preserve_host(self) -> pulumi.Output[bool]:
        """
        When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
        """
        return pulumi.get(self, "preserve_host")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[str]]:
        """
        An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="regexPriority")
    def regex_priority(self) -> pulumi.Output[int]:
        """
        A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
        """
        return pulumi.get(self, "regex_priority")

    @property
    @pulumi.getter(name="requestBuffering")
    def request_buffering(self) -> pulumi.Output[bool]:
        """
        Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
        """
        return pulumi.get(self, "request_buffering")

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> pulumi.Output[bool]:
        """
        Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
        """
        return pulumi.get(self, "response_buffering")

    @property
    @pulumi.getter
    def service(self) -> pulumi.Output['outputs.GatewayRouteService']:
        """
        The Service this Route is associated to. This is where the Route proxies traffic to.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def snis(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of SNIs that match this Route when using stream routing.
        """
        return pulumi.get(self, "snis")

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Output[Sequence['outputs.GatewayRouteSource']]:
        """
        A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="stripPath")
    def strip_path(self) -> pulumi.Output[bool]:
        """
        When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
        """
        return pulumi.get(self, "strip_path")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Sequence[str]]:
        """
        An optional set of strings associated with the Route for grouping and filtering.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[int]:
        """
        Unix epoch when the resource was last updated.
        """
        return pulumi.get(self, "updated_at")

