# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ApiProductDocumentMetadata',
    'ApiProductPortal',
    'ApiProductVersionGatewayService',
    'ApiProductVersionPortal',
    'ApiProductVersionPortalAuthStrategy',
    'ApplicationAuthStrategyKeyAuth',
    'ApplicationAuthStrategyKeyAuthConfigs',
    'ApplicationAuthStrategyKeyAuthConfigsKeyAuth',
    'ApplicationAuthStrategyKeyAuthDcrProvider',
    'ApplicationAuthStrategyOpenidConnect',
    'ApplicationAuthStrategyOpenidConnectConfigs',
    'ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect',
    'ApplicationAuthStrategyOpenidConnectDcrProvider',
    'CloudGatewayConfigurationDataplaneGroup',
    'CloudGatewayConfigurationDataplaneGroupAutoscale',
    'CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot',
    'CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic',
    'CloudGatewayConfigurationDataplaneGroupConfig',
    'CloudGatewayConfigurationDataplaneGroupConfigAutoscale',
    'CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot',
    'CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic',
    'CloudGatewayCustomDomainStateMetadata',
    'CloudGatewayNetworkFirewall',
    'CloudGatewayNetworkProviderMetadata',
    'CloudGatewayTransitGatewayDnsConfig',
    'CloudGatewayTransitGatewayTransitGatewayAttachmentConfig',
    'CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig',
    'GatewayAclConsumer',
    'GatewayBasicAuthConsumer',
    'GatewayControlPlaneConfig',
    'GatewayControlPlaneMembershipMember',
    'GatewayControlPlaneProxyUrl',
    'GatewayHmacAuthConsumer',
    'GatewayJwtConsumer',
    'GatewayKeyAuthConsumer',
    'GatewayKeyPem',
    'GatewayKeySet',
    'GatewayPluginAclConfig',
    'GatewayPluginAclConsumer',
    'GatewayPluginAclConsumerGroup',
    'GatewayPluginAclRoute',
    'GatewayPluginAclService',
    'GatewayPluginAiPromptDecoratorConfig',
    'GatewayPluginAiPromptDecoratorConfigPrompts',
    'GatewayPluginAiPromptDecoratorConfigPromptsAppend',
    'GatewayPluginAiPromptDecoratorConfigPromptsPrepend',
    'GatewayPluginAiPromptDecoratorConsumer',
    'GatewayPluginAiPromptDecoratorConsumerGroup',
    'GatewayPluginAiPromptDecoratorRoute',
    'GatewayPluginAiPromptDecoratorService',
    'GatewayPluginAiPromptGuardConfig',
    'GatewayPluginAiPromptGuardConsumer',
    'GatewayPluginAiPromptGuardConsumerGroup',
    'GatewayPluginAiPromptGuardRoute',
    'GatewayPluginAiPromptGuardService',
    'GatewayPluginAiPromptTemplateConfig',
    'GatewayPluginAiPromptTemplateConfigTemplate',
    'GatewayPluginAiPromptTemplateConsumer',
    'GatewayPluginAiPromptTemplateConsumerGroup',
    'GatewayPluginAiPromptTemplateRoute',
    'GatewayPluginAiPromptTemplateService',
    'GatewayPluginAiProxyConfig',
    'GatewayPluginAiProxyConfigAuth',
    'GatewayPluginAiProxyConfigLogging',
    'GatewayPluginAiProxyConfigModel',
    'GatewayPluginAiProxyConfigModelOptions',
    'GatewayPluginAiProxyConsumer',
    'GatewayPluginAiProxyConsumerGroup',
    'GatewayPluginAiProxyRoute',
    'GatewayPluginAiProxyService',
    'GatewayPluginAwsLambdaConfig',
    'GatewayPluginAwsLambdaConsumer',
    'GatewayPluginAwsLambdaConsumerGroup',
    'GatewayPluginAwsLambdaRoute',
    'GatewayPluginAwsLambdaService',
    'GatewayPluginBasicAuthConfig',
    'GatewayPluginBasicAuthConsumer',
    'GatewayPluginBasicAuthConsumerGroup',
    'GatewayPluginBasicAuthRoute',
    'GatewayPluginBasicAuthService',
    'GatewayPluginCorrelationIdConfig',
    'GatewayPluginCorrelationIdConsumer',
    'GatewayPluginCorrelationIdConsumerGroup',
    'GatewayPluginCorrelationIdRoute',
    'GatewayPluginCorrelationIdService',
    'GatewayPluginCorsConfig',
    'GatewayPluginCorsConsumer',
    'GatewayPluginCorsConsumerGroup',
    'GatewayPluginCorsRoute',
    'GatewayPluginCorsService',
    'GatewayPluginExitTransformerConfig',
    'GatewayPluginExitTransformerConsumer',
    'GatewayPluginExitTransformerConsumerGroup',
    'GatewayPluginExitTransformerRoute',
    'GatewayPluginExitTransformerService',
    'GatewayPluginFileLogConfig',
    'GatewayPluginFileLogConsumer',
    'GatewayPluginFileLogConsumerGroup',
    'GatewayPluginFileLogRoute',
    'GatewayPluginFileLogService',
    'GatewayPluginIpRestrictionConfig',
    'GatewayPluginIpRestrictionConsumer',
    'GatewayPluginIpRestrictionConsumerGroup',
    'GatewayPluginIpRestrictionRoute',
    'GatewayPluginIpRestrictionService',
    'GatewayPluginJqConfig',
    'GatewayPluginJqConfigRequestJqProgramOptions',
    'GatewayPluginJqConfigResponseJqProgramOptions',
    'GatewayPluginJqConsumer',
    'GatewayPluginJqConsumerGroup',
    'GatewayPluginJqRoute',
    'GatewayPluginJqService',
    'GatewayPluginJwtConfig',
    'GatewayPluginJwtConsumer',
    'GatewayPluginJwtConsumerGroup',
    'GatewayPluginJwtRoute',
    'GatewayPluginJwtService',
    'GatewayPluginJwtSignerConfig',
    'GatewayPluginJwtSignerConsumer',
    'GatewayPluginJwtSignerConsumerGroup',
    'GatewayPluginJwtSignerRoute',
    'GatewayPluginJwtSignerService',
    'GatewayPluginKeyAuthConfig',
    'GatewayPluginKeyAuthConsumer',
    'GatewayPluginKeyAuthConsumerGroup',
    'GatewayPluginKeyAuthRoute',
    'GatewayPluginKeyAuthService',
    'GatewayPluginOauth2Config',
    'GatewayPluginOauth2Consumer',
    'GatewayPluginOauth2ConsumerGroup',
    'GatewayPluginOauth2Route',
    'GatewayPluginOauth2Service',
    'GatewayPluginOpenidConnectConfig',
    'GatewayPluginOpenidConnectConfigClientJwk',
    'GatewayPluginOpenidConnectConfigSessionRedisClusterNode',
    'GatewayPluginOpenidConnectConsumer',
    'GatewayPluginOpenidConnectConsumerGroup',
    'GatewayPluginOpenidConnectRoute',
    'GatewayPluginOpenidConnectService',
    'GatewayPluginOpentelemetryConfig',
    'GatewayPluginOpentelemetryConfigPropagation',
    'GatewayPluginOpentelemetryConfigQueue',
    'GatewayPluginOpentelemetryConsumer',
    'GatewayPluginOpentelemetryConsumerGroup',
    'GatewayPluginOpentelemetryRoute',
    'GatewayPluginOpentelemetryService',
    'GatewayPluginPostFunctionConfig',
    'GatewayPluginPostFunctionConsumer',
    'GatewayPluginPostFunctionConsumerGroup',
    'GatewayPluginPostFunctionRoute',
    'GatewayPluginPostFunctionService',
    'GatewayPluginPreFunctionConfig',
    'GatewayPluginPreFunctionConsumer',
    'GatewayPluginPreFunctionConsumerGroup',
    'GatewayPluginPreFunctionRoute',
    'GatewayPluginPreFunctionService',
    'GatewayPluginPrometheusConfig',
    'GatewayPluginPrometheusConsumer',
    'GatewayPluginPrometheusConsumerGroup',
    'GatewayPluginPrometheusRoute',
    'GatewayPluginPrometheusService',
    'GatewayPluginProxyCacheConfig',
    'GatewayPluginProxyCacheConfigMemory',
    'GatewayPluginProxyCacheConfigResponseHeaders',
    'GatewayPluginProxyCacheConsumer',
    'GatewayPluginProxyCacheConsumerGroup',
    'GatewayPluginProxyCacheRoute',
    'GatewayPluginProxyCacheService',
    'GatewayPluginRateLimitingAdvancedConfig',
    'GatewayPluginRateLimitingAdvancedConfigRedis',
    'GatewayPluginRateLimitingAdvancedConsumer',
    'GatewayPluginRateLimitingAdvancedConsumerGroup',
    'GatewayPluginRateLimitingAdvancedRoute',
    'GatewayPluginRateLimitingAdvancedService',
    'GatewayPluginRateLimitingConfig',
    'GatewayPluginRateLimitingConfigRedis',
    'GatewayPluginRateLimitingConsumer',
    'GatewayPluginRateLimitingConsumerGroup',
    'GatewayPluginRateLimitingRoute',
    'GatewayPluginRateLimitingService',
    'GatewayPluginRequestTerminationConfig',
    'GatewayPluginRequestTerminationConsumer',
    'GatewayPluginRequestTerminationConsumerGroup',
    'GatewayPluginRequestTerminationRoute',
    'GatewayPluginRequestTerminationService',
    'GatewayPluginRequestTransformerAdvancedConfig',
    'GatewayPluginRequestTransformerAdvancedConfigAdd',
    'GatewayPluginRequestTransformerAdvancedConfigAllow',
    'GatewayPluginRequestTransformerAdvancedConfigAppend',
    'GatewayPluginRequestTransformerAdvancedConfigRemove',
    'GatewayPluginRequestTransformerAdvancedConfigRename',
    'GatewayPluginRequestTransformerAdvancedConfigReplace',
    'GatewayPluginRequestTransformerAdvancedConsumer',
    'GatewayPluginRequestTransformerAdvancedConsumerGroup',
    'GatewayPluginRequestTransformerAdvancedRoute',
    'GatewayPluginRequestTransformerAdvancedService',
    'GatewayPluginRequestTransformerConfig',
    'GatewayPluginRequestTransformerConfigAdd',
    'GatewayPluginRequestTransformerConfigAppend',
    'GatewayPluginRequestTransformerConfigRemove',
    'GatewayPluginRequestTransformerConfigRename',
    'GatewayPluginRequestTransformerConfigReplace',
    'GatewayPluginRequestTransformerConsumer',
    'GatewayPluginRequestTransformerConsumerGroup',
    'GatewayPluginRequestTransformerRoute',
    'GatewayPluginRequestTransformerService',
    'GatewayPluginResponseTransformerAdvancedConfig',
    'GatewayPluginResponseTransformerAdvancedConfigAdd',
    'GatewayPluginResponseTransformerAdvancedConfigAllow',
    'GatewayPluginResponseTransformerAdvancedConfigAppend',
    'GatewayPluginResponseTransformerAdvancedConfigRemove',
    'GatewayPluginResponseTransformerAdvancedConfigRename',
    'GatewayPluginResponseTransformerAdvancedConfigReplace',
    'GatewayPluginResponseTransformerAdvancedConfigTransform',
    'GatewayPluginResponseTransformerAdvancedConsumer',
    'GatewayPluginResponseTransformerAdvancedConsumerGroup',
    'GatewayPluginResponseTransformerAdvancedRoute',
    'GatewayPluginResponseTransformerAdvancedService',
    'GatewayPluginResponseTransformerConfig',
    'GatewayPluginResponseTransformerConfigAdd',
    'GatewayPluginResponseTransformerConfigAppend',
    'GatewayPluginResponseTransformerConfigRemove',
    'GatewayPluginResponseTransformerConfigRename',
    'GatewayPluginResponseTransformerConfigReplace',
    'GatewayPluginResponseTransformerConsumer',
    'GatewayPluginResponseTransformerConsumerGroup',
    'GatewayPluginResponseTransformerRoute',
    'GatewayPluginResponseTransformerService',
    'GatewayPluginSamlConfig',
    'GatewayPluginSamlConfigSessionRedisClusterNode',
    'GatewayPluginSamlConsumer',
    'GatewayPluginSamlConsumerGroup',
    'GatewayPluginSamlRoute',
    'GatewayPluginSamlService',
    'GatewayPluginStatsdConfig',
    'GatewayPluginStatsdConfigMetric',
    'GatewayPluginStatsdConfigQueue',
    'GatewayPluginStatsdConsumer',
    'GatewayPluginStatsdConsumerGroup',
    'GatewayPluginStatsdRoute',
    'GatewayPluginStatsdService',
    'GatewayRouteDestination',
    'GatewayRouteService',
    'GatewayRouteSource',
    'GatewayServiceClientCertificate',
    'GatewaySniCertificate',
    'GatewayTargetUpstream',
    'GatewayUpstreamClientCertificate',
    'GatewayUpstreamHealthchecks',
    'GatewayUpstreamHealthchecksActive',
    'GatewayUpstreamHealthchecksActiveHealthy',
    'GatewayUpstreamHealthchecksActiveUnhealthy',
    'GatewayUpstreamHealthchecksPassive',
    'GatewayUpstreamHealthchecksPassiveHealthy',
    'GatewayUpstreamHealthchecksPassiveUnhealthy',
    'PortalAppearanceCustomFonts',
    'PortalAppearanceCustomTheme',
    'PortalAppearanceCustomThemeColors',
    'PortalAppearanceCustomThemeColorsButton',
    'PortalAppearanceCustomThemeColorsButtonPrimaryFill',
    'PortalAppearanceCustomThemeColorsButtonPrimaryText',
    'PortalAppearanceCustomThemeColorsSection',
    'PortalAppearanceCustomThemeColorsSectionAccent',
    'PortalAppearanceCustomThemeColorsSectionBody',
    'PortalAppearanceCustomThemeColorsSectionFooter',
    'PortalAppearanceCustomThemeColorsSectionHeader',
    'PortalAppearanceCustomThemeColorsSectionHero',
    'PortalAppearanceCustomThemeColorsSectionStroke',
    'PortalAppearanceCustomThemeColorsSectionTertiary',
    'PortalAppearanceCustomThemeColorsText',
    'PortalAppearanceCustomThemeColorsTextAccent',
    'PortalAppearanceCustomThemeColorsTextFooter',
    'PortalAppearanceCustomThemeColorsTextHeader',
    'PortalAppearanceCustomThemeColorsTextHeadings',
    'PortalAppearanceCustomThemeColorsTextHero',
    'PortalAppearanceCustomThemeColorsTextLink',
    'PortalAppearanceCustomThemeColorsTextPrimary',
    'PortalAppearanceCustomThemeColorsTextSecondary',
    'PortalAppearanceImages',
    'PortalAppearanceImagesCatalogCover',
    'PortalAppearanceImagesFavicon',
    'PortalAppearanceImagesLogo',
    'PortalAppearanceText',
    'PortalAppearanceTextCatalog',
    'PortalAuthOidcClaimMappings',
    'PortalAuthOidcConfig',
    'PortalAuthOidcConfigClaimMappings',
    'PortalProductVersionAuthStrategy',
    'PortalProductVersionAuthStrategyClientCredentials',
    'PortalProductVersionAuthStrategyKeyAuth',
    'ServerlessCloudGatewayControlPlane',
    'GetApiProductDocumentMetadataResult',
    'GetApiProductPortalResult',
    'GetApiProductVersionGatewayServiceResult',
    'GetApiProductVersionPortalResult',
    'GetApiProductVersionPortalAuthStrategyResult',
    'GetApplicationAuthStrategyKeyAuthResult',
    'GetApplicationAuthStrategyKeyAuthConfigsResult',
    'GetApplicationAuthStrategyKeyAuthConfigsKeyAuthResult',
    'GetApplicationAuthStrategyKeyAuthDcrProviderResult',
    'GetApplicationAuthStrategyOpenidConnectResult',
    'GetApplicationAuthStrategyOpenidConnectConfigsResult',
    'GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnectResult',
    'GetApplicationAuthStrategyOpenidConnectDcrProviderResult',
    'GetCloudGatewayConfigurationDataplaneGroupResult',
    'GetCloudGatewayConfigurationDataplaneGroupAutoscaleResult',
    'GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult',
    'GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult',
    'GetCloudGatewayConfigurationDataplaneGroupConfigResult',
    'GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleResult',
    'GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult',
    'GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult',
    'GetCloudGatewayCustomDomainStateMetadataResult',
    'GetCloudGatewayNetworkFirewallResult',
    'GetCloudGatewayNetworkProviderMetadataResult',
    'GetCloudGatewayProviderAccountListDataResult',
    'GetCloudGatewayProviderAccountListMetaResult',
    'GetCloudGatewayProviderAccountListMetaPageResult',
    'GetCloudGatewayTransitGatewayDnsConfigResult',
    'GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigResult',
    'GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfigResult',
    'GetGatewayAclConsumerResult',
    'GetGatewayBasicAuthConsumerResult',
    'GetGatewayControlPlaneConfigResult',
    'GetGatewayHmacAuthConsumerResult',
    'GetGatewayJwtConsumerResult',
    'GetGatewayKeyAuthConsumerResult',
    'GetGatewayKeyPemResult',
    'GetGatewayKeySetResult',
    'GetGatewayPluginAclConfigResult',
    'GetGatewayPluginAclConsumerResult',
    'GetGatewayPluginAclConsumerGroupResult',
    'GetGatewayPluginAclRouteResult',
    'GetGatewayPluginAclServiceResult',
    'GetGatewayPluginAiPromptDecoratorConfigResult',
    'GetGatewayPluginAiPromptDecoratorConfigPromptsResult',
    'GetGatewayPluginAiPromptDecoratorConfigPromptsAppendResult',
    'GetGatewayPluginAiPromptDecoratorConfigPromptsPrependResult',
    'GetGatewayPluginAiPromptDecoratorConsumerResult',
    'GetGatewayPluginAiPromptDecoratorConsumerGroupResult',
    'GetGatewayPluginAiPromptDecoratorRouteResult',
    'GetGatewayPluginAiPromptDecoratorServiceResult',
    'GetGatewayPluginAiPromptGuardConfigResult',
    'GetGatewayPluginAiPromptGuardConsumerResult',
    'GetGatewayPluginAiPromptGuardConsumerGroupResult',
    'GetGatewayPluginAiPromptGuardRouteResult',
    'GetGatewayPluginAiPromptGuardServiceResult',
    'GetGatewayPluginAiPromptTemplateConfigResult',
    'GetGatewayPluginAiPromptTemplateConfigTemplateResult',
    'GetGatewayPluginAiPromptTemplateConsumerResult',
    'GetGatewayPluginAiPromptTemplateConsumerGroupResult',
    'GetGatewayPluginAiPromptTemplateRouteResult',
    'GetGatewayPluginAiPromptTemplateServiceResult',
    'GetGatewayPluginAiProxyConfigResult',
    'GetGatewayPluginAiProxyConfigAuthResult',
    'GetGatewayPluginAiProxyConfigLoggingResult',
    'GetGatewayPluginAiProxyConfigModelResult',
    'GetGatewayPluginAiProxyConfigModelOptionsResult',
    'GetGatewayPluginAiProxyConsumerResult',
    'GetGatewayPluginAiProxyConsumerGroupResult',
    'GetGatewayPluginAiProxyRouteResult',
    'GetGatewayPluginAiProxyServiceResult',
    'GetGatewayPluginAwsLambdaConfigResult',
    'GetGatewayPluginAwsLambdaConsumerResult',
    'GetGatewayPluginAwsLambdaConsumerGroupResult',
    'GetGatewayPluginAwsLambdaRouteResult',
    'GetGatewayPluginAwsLambdaServiceResult',
    'GetGatewayPluginBasicAuthConfigResult',
    'GetGatewayPluginBasicAuthConsumerResult',
    'GetGatewayPluginBasicAuthConsumerGroupResult',
    'GetGatewayPluginBasicAuthRouteResult',
    'GetGatewayPluginBasicAuthServiceResult',
    'GetGatewayPluginCorrelationIdConfigResult',
    'GetGatewayPluginCorrelationIdConsumerResult',
    'GetGatewayPluginCorrelationIdConsumerGroupResult',
    'GetGatewayPluginCorrelationIdRouteResult',
    'GetGatewayPluginCorrelationIdServiceResult',
    'GetGatewayPluginCorsConfigResult',
    'GetGatewayPluginCorsConsumerResult',
    'GetGatewayPluginCorsConsumerGroupResult',
    'GetGatewayPluginCorsRouteResult',
    'GetGatewayPluginCorsServiceResult',
    'GetGatewayPluginExitTransformerConfigResult',
    'GetGatewayPluginExitTransformerConsumerResult',
    'GetGatewayPluginExitTransformerConsumerGroupResult',
    'GetGatewayPluginExitTransformerRouteResult',
    'GetGatewayPluginExitTransformerServiceResult',
    'GetGatewayPluginFileLogConfigResult',
    'GetGatewayPluginFileLogConsumerResult',
    'GetGatewayPluginFileLogConsumerGroupResult',
    'GetGatewayPluginFileLogRouteResult',
    'GetGatewayPluginFileLogServiceResult',
    'GetGatewayPluginIpRestrictionConfigResult',
    'GetGatewayPluginIpRestrictionConsumerResult',
    'GetGatewayPluginIpRestrictionConsumerGroupResult',
    'GetGatewayPluginIpRestrictionRouteResult',
    'GetGatewayPluginIpRestrictionServiceResult',
    'GetGatewayPluginJqConfigResult',
    'GetGatewayPluginJqConfigRequestJqProgramOptionsResult',
    'GetGatewayPluginJqConfigResponseJqProgramOptionsResult',
    'GetGatewayPluginJqConsumerResult',
    'GetGatewayPluginJqConsumerGroupResult',
    'GetGatewayPluginJqRouteResult',
    'GetGatewayPluginJqServiceResult',
    'GetGatewayPluginJwtConfigResult',
    'GetGatewayPluginJwtConsumerResult',
    'GetGatewayPluginJwtConsumerGroupResult',
    'GetGatewayPluginJwtRouteResult',
    'GetGatewayPluginJwtServiceResult',
    'GetGatewayPluginJwtSignerConfigResult',
    'GetGatewayPluginJwtSignerConsumerResult',
    'GetGatewayPluginJwtSignerConsumerGroupResult',
    'GetGatewayPluginJwtSignerRouteResult',
    'GetGatewayPluginJwtSignerServiceResult',
    'GetGatewayPluginKeyAuthConfigResult',
    'GetGatewayPluginKeyAuthConsumerResult',
    'GetGatewayPluginKeyAuthConsumerGroupResult',
    'GetGatewayPluginKeyAuthRouteResult',
    'GetGatewayPluginKeyAuthServiceResult',
    'GetGatewayPluginOauth2ConfigResult',
    'GetGatewayPluginOauth2ConsumerResult',
    'GetGatewayPluginOauth2ConsumerGroupResult',
    'GetGatewayPluginOauth2RouteResult',
    'GetGatewayPluginOauth2ServiceResult',
    'GetGatewayPluginOpenidConnectConfigResult',
    'GetGatewayPluginOpenidConnectConfigClientJwkResult',
    'GetGatewayPluginOpenidConnectConfigSessionRedisClusterNodeResult',
    'GetGatewayPluginOpenidConnectConsumerResult',
    'GetGatewayPluginOpenidConnectConsumerGroupResult',
    'GetGatewayPluginOpenidConnectRouteResult',
    'GetGatewayPluginOpenidConnectServiceResult',
    'GetGatewayPluginOpentelemetryConfigResult',
    'GetGatewayPluginOpentelemetryConfigPropagationResult',
    'GetGatewayPluginOpentelemetryConfigQueueResult',
    'GetGatewayPluginOpentelemetryConsumerResult',
    'GetGatewayPluginOpentelemetryConsumerGroupResult',
    'GetGatewayPluginOpentelemetryRouteResult',
    'GetGatewayPluginOpentelemetryServiceResult',
    'GetGatewayPluginPostFunctionConfigResult',
    'GetGatewayPluginPostFunctionConsumerResult',
    'GetGatewayPluginPostFunctionConsumerGroupResult',
    'GetGatewayPluginPostFunctionRouteResult',
    'GetGatewayPluginPostFunctionServiceResult',
    'GetGatewayPluginPreFunctionConfigResult',
    'GetGatewayPluginPreFunctionConsumerResult',
    'GetGatewayPluginPreFunctionConsumerGroupResult',
    'GetGatewayPluginPreFunctionRouteResult',
    'GetGatewayPluginPreFunctionServiceResult',
    'GetGatewayPluginPrometheusConfigResult',
    'GetGatewayPluginPrometheusConsumerResult',
    'GetGatewayPluginPrometheusConsumerGroupResult',
    'GetGatewayPluginPrometheusRouteResult',
    'GetGatewayPluginPrometheusServiceResult',
    'GetGatewayPluginProxyCacheConfigResult',
    'GetGatewayPluginProxyCacheConfigMemoryResult',
    'GetGatewayPluginProxyCacheConfigResponseHeadersResult',
    'GetGatewayPluginProxyCacheConsumerResult',
    'GetGatewayPluginProxyCacheConsumerGroupResult',
    'GetGatewayPluginProxyCacheRouteResult',
    'GetGatewayPluginProxyCacheServiceResult',
    'GetGatewayPluginRateLimitingAdvancedConfigResult',
    'GetGatewayPluginRateLimitingAdvancedConfigRedisResult',
    'GetGatewayPluginRateLimitingAdvancedConsumerResult',
    'GetGatewayPluginRateLimitingAdvancedConsumerGroupResult',
    'GetGatewayPluginRateLimitingAdvancedRouteResult',
    'GetGatewayPluginRateLimitingAdvancedServiceResult',
    'GetGatewayPluginRateLimitingConfigResult',
    'GetGatewayPluginRateLimitingConfigRedisResult',
    'GetGatewayPluginRateLimitingConsumerResult',
    'GetGatewayPluginRateLimitingConsumerGroupResult',
    'GetGatewayPluginRateLimitingRouteResult',
    'GetGatewayPluginRateLimitingServiceResult',
    'GetGatewayPluginRequestTerminationConfigResult',
    'GetGatewayPluginRequestTerminationConsumerResult',
    'GetGatewayPluginRequestTerminationConsumerGroupResult',
    'GetGatewayPluginRequestTerminationRouteResult',
    'GetGatewayPluginRequestTerminationServiceResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigAddResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigAllowResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigAppendResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigRemoveResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigRenameResult',
    'GetGatewayPluginRequestTransformerAdvancedConfigReplaceResult',
    'GetGatewayPluginRequestTransformerAdvancedConsumerResult',
    'GetGatewayPluginRequestTransformerAdvancedConsumerGroupResult',
    'GetGatewayPluginRequestTransformerAdvancedRouteResult',
    'GetGatewayPluginRequestTransformerAdvancedServiceResult',
    'GetGatewayPluginRequestTransformerConfigResult',
    'GetGatewayPluginRequestTransformerConfigAddResult',
    'GetGatewayPluginRequestTransformerConfigAppendResult',
    'GetGatewayPluginRequestTransformerConfigRemoveResult',
    'GetGatewayPluginRequestTransformerConfigRenameResult',
    'GetGatewayPluginRequestTransformerConfigReplaceResult',
    'GetGatewayPluginRequestTransformerConsumerResult',
    'GetGatewayPluginRequestTransformerConsumerGroupResult',
    'GetGatewayPluginRequestTransformerRouteResult',
    'GetGatewayPluginRequestTransformerServiceResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigAddResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigAllowResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigAppendResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigRemoveResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigRenameResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigReplaceResult',
    'GetGatewayPluginResponseTransformerAdvancedConfigTransformResult',
    'GetGatewayPluginResponseTransformerAdvancedConsumerResult',
    'GetGatewayPluginResponseTransformerAdvancedConsumerGroupResult',
    'GetGatewayPluginResponseTransformerAdvancedRouteResult',
    'GetGatewayPluginResponseTransformerAdvancedServiceResult',
    'GetGatewayPluginResponseTransformerConfigResult',
    'GetGatewayPluginResponseTransformerConfigAddResult',
    'GetGatewayPluginResponseTransformerConfigAppendResult',
    'GetGatewayPluginResponseTransformerConfigRemoveResult',
    'GetGatewayPluginResponseTransformerConfigRenameResult',
    'GetGatewayPluginResponseTransformerConfigReplaceResult',
    'GetGatewayPluginResponseTransformerConsumerResult',
    'GetGatewayPluginResponseTransformerConsumerGroupResult',
    'GetGatewayPluginResponseTransformerRouteResult',
    'GetGatewayPluginResponseTransformerServiceResult',
    'GetGatewayPluginSamlConfigResult',
    'GetGatewayPluginSamlConfigSessionRedisClusterNodeResult',
    'GetGatewayPluginSamlConsumerResult',
    'GetGatewayPluginSamlConsumerGroupResult',
    'GetGatewayPluginSamlRouteResult',
    'GetGatewayPluginSamlServiceResult',
    'GetGatewayPluginStatsdConfigResult',
    'GetGatewayPluginStatsdConfigMetricResult',
    'GetGatewayPluginStatsdConfigQueueResult',
    'GetGatewayPluginStatsdConsumerResult',
    'GetGatewayPluginStatsdConsumerGroupResult',
    'GetGatewayPluginStatsdRouteResult',
    'GetGatewayPluginStatsdServiceResult',
    'GetGatewayRouteDestinationResult',
    'GetGatewayRouteServiceResult',
    'GetGatewayRouteSourceResult',
    'GetGatewayServiceClientCertificateResult',
    'GetGatewaySniCertificateResult',
    'GetGatewayTargetUpstreamResult',
    'GetGatewayUpstreamClientCertificateResult',
    'GetGatewayUpstreamHealthchecksResult',
    'GetGatewayUpstreamHealthchecksActiveResult',
    'GetGatewayUpstreamHealthchecksActiveHealthyResult',
    'GetGatewayUpstreamHealthchecksActiveUnhealthyResult',
    'GetGatewayUpstreamHealthchecksPassiveResult',
    'GetGatewayUpstreamHealthchecksPassiveHealthyResult',
    'GetGatewayUpstreamHealthchecksPassiveUnhealthyResult',
    'GetPortalAppearanceCustomFontsResult',
    'GetPortalAppearanceCustomThemeResult',
    'GetPortalAppearanceCustomThemeColorsResult',
    'GetPortalAppearanceCustomThemeColorsButtonResult',
    'GetPortalAppearanceCustomThemeColorsButtonPrimaryFillResult',
    'GetPortalAppearanceCustomThemeColorsButtonPrimaryTextResult',
    'GetPortalAppearanceCustomThemeColorsSectionResult',
    'GetPortalAppearanceCustomThemeColorsSectionAccentResult',
    'GetPortalAppearanceCustomThemeColorsSectionBodyResult',
    'GetPortalAppearanceCustomThemeColorsSectionFooterResult',
    'GetPortalAppearanceCustomThemeColorsSectionHeaderResult',
    'GetPortalAppearanceCustomThemeColorsSectionHeroResult',
    'GetPortalAppearanceCustomThemeColorsSectionStrokeResult',
    'GetPortalAppearanceCustomThemeColorsSectionTertiaryResult',
    'GetPortalAppearanceCustomThemeColorsTextResult',
    'GetPortalAppearanceCustomThemeColorsTextAccentResult',
    'GetPortalAppearanceCustomThemeColorsTextFooterResult',
    'GetPortalAppearanceCustomThemeColorsTextHeaderResult',
    'GetPortalAppearanceCustomThemeColorsTextHeadingsResult',
    'GetPortalAppearanceCustomThemeColorsTextHeroResult',
    'GetPortalAppearanceCustomThemeColorsTextLinkResult',
    'GetPortalAppearanceCustomThemeColorsTextPrimaryResult',
    'GetPortalAppearanceCustomThemeColorsTextSecondaryResult',
    'GetPortalAppearanceImagesResult',
    'GetPortalAppearanceImagesCatalogCoverResult',
    'GetPortalAppearanceImagesFaviconResult',
    'GetPortalAppearanceImagesLogoResult',
    'GetPortalAppearanceTextResult',
    'GetPortalAppearanceTextCatalogResult',
    'GetPortalAuthOidcConfigResult',
    'GetPortalAuthOidcConfigClaimMappingsResult',
    'GetPortalListDataResult',
    'GetPortalListMetaResult',
    'GetPortalListMetaPageResult',
    'GetPortalProductVersionAuthStrategyResult',
    'GetPortalProductVersionAuthStrategyClientCredentialsResult',
    'GetPortalProductVersionAuthStrategyKeyAuthResult',
    'GetServerlessCloudGatewayControlPlaneResult',
]

@pulumi.output_type
class ApiProductDocumentMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ApiProductPortal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portalId":
            suggest = "portal_id"
        elif key == "portalName":
            suggest = "portal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiProductPortal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiProductPortal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiProductPortal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 portal_id: Optional[str] = None,
                 portal_name: Optional[str] = None):
        if portal_id is not None:
            pulumi.set(__self__, "portal_id", portal_id)
        if portal_name is not None:
            pulumi.set(__self__, "portal_name", portal_name)

    @property
    @pulumi.getter(name="portalId")
    def portal_id(self) -> Optional[str]:
        return pulumi.get(self, "portal_id")

    @property
    @pulumi.getter(name="portalName")
    def portal_name(self) -> Optional[str]:
        return pulumi.get(self, "portal_name")


@pulumi.output_type
class ApiProductVersionGatewayService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneId":
            suggest = "control_plane_id"
        elif key == "runtimeGroupId":
            suggest = "runtime_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiProductVersionGatewayService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiProductVersionGatewayService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiProductVersionGatewayService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_id: Optional[str] = None,
                 id: Optional[str] = None,
                 runtime_group_id: Optional[str] = None):
        """
        :param str control_plane_id: The identifier of the control plane that the gateway service resides in. Not Null
        :param str id: The identifier of a gateway service associated with the version of the API product. Not Null
        :param str runtime_group_id: This field is deprecated, please use `control_plane_id` instead. The identifier of the control plane that the gateway service resides in
        """
        if control_plane_id is not None:
            pulumi.set(__self__, "control_plane_id", control_plane_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if runtime_group_id is not None:
            pulumi.set(__self__, "runtime_group_id", runtime_group_id)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> Optional[str]:
        """
        The identifier of the control plane that the gateway service resides in. Not Null
        """
        return pulumi.get(self, "control_plane_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The identifier of a gateway service associated with the version of the API product. Not Null
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="runtimeGroupId")
    def runtime_group_id(self) -> Optional[str]:
        """
        This field is deprecated, please use `control_plane_id` instead. The identifier of the control plane that the gateway service resides in
        """
        return pulumi.get(self, "runtime_group_id")


@pulumi.output_type
class ApiProductVersionPortal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationRegistrationEnabled":
            suggest = "application_registration_enabled"
        elif key == "authStrategies":
            suggest = "auth_strategies"
        elif key == "autoApproveRegistration":
            suggest = "auto_approve_registration"
        elif key == "portalId":
            suggest = "portal_id"
        elif key == "portalName":
            suggest = "portal_name"
        elif key == "portalProductVersionId":
            suggest = "portal_product_version_id"
        elif key == "publishStatus":
            suggest = "publish_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiProductVersionPortal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiProductVersionPortal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiProductVersionPortal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_registration_enabled: Optional[bool] = None,
                 auth_strategies: Optional[Sequence['outputs.ApiProductVersionPortalAuthStrategy']] = None,
                 auto_approve_registration: Optional[bool] = None,
                 deprecated: Optional[bool] = None,
                 portal_id: Optional[str] = None,
                 portal_name: Optional[str] = None,
                 portal_product_version_id: Optional[str] = None,
                 publish_status: Optional[str] = None):
        """
        :param str publish_status: must be one of ["published", "unpublished"]
        """
        if application_registration_enabled is not None:
            pulumi.set(__self__, "application_registration_enabled", application_registration_enabled)
        if auth_strategies is not None:
            pulumi.set(__self__, "auth_strategies", auth_strategies)
        if auto_approve_registration is not None:
            pulumi.set(__self__, "auto_approve_registration", auto_approve_registration)
        if deprecated is not None:
            pulumi.set(__self__, "deprecated", deprecated)
        if portal_id is not None:
            pulumi.set(__self__, "portal_id", portal_id)
        if portal_name is not None:
            pulumi.set(__self__, "portal_name", portal_name)
        if portal_product_version_id is not None:
            pulumi.set(__self__, "portal_product_version_id", portal_product_version_id)
        if publish_status is not None:
            pulumi.set(__self__, "publish_status", publish_status)

    @property
    @pulumi.getter(name="applicationRegistrationEnabled")
    def application_registration_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "application_registration_enabled")

    @property
    @pulumi.getter(name="authStrategies")
    def auth_strategies(self) -> Optional[Sequence['outputs.ApiProductVersionPortalAuthStrategy']]:
        return pulumi.get(self, "auth_strategies")

    @property
    @pulumi.getter(name="autoApproveRegistration")
    def auto_approve_registration(self) -> Optional[bool]:
        return pulumi.get(self, "auto_approve_registration")

    @property
    @pulumi.getter
    def deprecated(self) -> Optional[bool]:
        return pulumi.get(self, "deprecated")

    @property
    @pulumi.getter(name="portalId")
    def portal_id(self) -> Optional[str]:
        return pulumi.get(self, "portal_id")

    @property
    @pulumi.getter(name="portalName")
    def portal_name(self) -> Optional[str]:
        return pulumi.get(self, "portal_name")

    @property
    @pulumi.getter(name="portalProductVersionId")
    def portal_product_version_id(self) -> Optional[str]:
        return pulumi.get(self, "portal_product_version_id")

    @property
    @pulumi.getter(name="publishStatus")
    def publish_status(self) -> Optional[str]:
        """
        must be one of ["published", "unpublished"]
        """
        return pulumi.get(self, "publish_status")


@pulumi.output_type
class ApiProductVersionPortalAuthStrategy(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ApplicationAuthStrategyKeyAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "dcrProvider":
            suggest = "dcr_provider"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "strategyType":
            suggest = "strategy_type"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyKeyAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyKeyAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyKeyAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[bool] = None,
                 configs: Optional['outputs.ApplicationAuthStrategyKeyAuthConfigs'] = None,
                 created_at: Optional[str] = None,
                 dcr_provider: Optional['outputs.ApplicationAuthStrategyKeyAuthDcrProvider'] = None,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 strategy_type: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param bool active: At least one published product version is using this auth strategy.
        :param 'ApplicationAuthStrategyKeyAuthConfigsArgs' configs: JSON-B object containing the configuration for the Key Auth strategy. Requires replacement if changed. ; Not Null
        :param str created_at: An ISO-8601 timestamp representation of entity creation date.
        :param str display_name: The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str name: The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        :param str strategy_type: Requires replacement if changed. ; Not Null; must be one of ["key_auth"]
        :param str updated_at: An ISO-8601 timestamp representation of entity update date.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dcr_provider is not None:
            pulumi.set(__self__, "dcr_provider", dcr_provider)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if strategy_type is not None:
            pulumi.set(__self__, "strategy_type", strategy_type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        At least one published product version is using this auth strategy.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def configs(self) -> Optional['outputs.ApplicationAuthStrategyKeyAuthConfigs']:
        """
        JSON-B object containing the configuration for the Key Auth strategy. Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        An ISO-8601 timestamp representation of entity creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dcrProvider")
    def dcr_provider(self) -> Optional['outputs.ApplicationAuthStrategyKeyAuthDcrProvider']:
        return pulumi.get(self, "dcr_provider")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> Optional[str]:
        """
        Requires replacement if changed. ; Not Null; must be one of ["key_auth"]
        """
        return pulumi.get(self, "strategy_type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        An ISO-8601 timestamp representation of entity update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ApplicationAuthStrategyKeyAuthConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyAuth":
            suggest = "key_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyKeyAuthConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyKeyAuthConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyKeyAuthConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_auth: Optional['outputs.ApplicationAuthStrategyKeyAuthConfigsKeyAuth'] = None):
        """
        :param 'ApplicationAuthStrategyKeyAuthConfigsKeyAuthArgs' key_auth: The most basic mode to configure an Application Auth Strategy for an API Product Version.
               Using this mode will allow developers to generate API keys that will authenticate their application requests.
               Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
        """
        if key_auth is not None:
            pulumi.set(__self__, "key_auth", key_auth)

    @property
    @pulumi.getter(name="keyAuth")
    def key_auth(self) -> Optional['outputs.ApplicationAuthStrategyKeyAuthConfigsKeyAuth']:
        """
        The most basic mode to configure an Application Auth Strategy for an API Product Version.
        Using this mode will allow developers to generate API keys that will authenticate their application requests.
        Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
        """
        return pulumi.get(self, "key_auth")


@pulumi.output_type
class ApplicationAuthStrategyKeyAuthConfigsKeyAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyNames":
            suggest = "key_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyKeyAuthConfigsKeyAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyKeyAuthConfigsKeyAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyKeyAuthConfigsKeyAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] key_names: The names of the headers containing the API key. You can specify multiple header names. Requires replacement if changed.
        """
        if key_names is not None:
            pulumi.set(__self__, "key_names", key_names)

    @property
    @pulumi.getter(name="keyNames")
    def key_names(self) -> Optional[Sequence[str]]:
        """
        The names of the headers containing the API key. You can specify multiple header names. Requires replacement if changed.
        """
        return pulumi.get(self, "key_names")


@pulumi.output_type
class ApplicationAuthStrategyKeyAuthDcrProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyKeyAuthDcrProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyKeyAuthDcrProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyKeyAuthDcrProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 provider_type: Optional[str] = None):
        """
        :param str display_name: The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str provider_type: The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[str]:
        """
        The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class ApplicationAuthStrategyOpenidConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "dcrProvider":
            suggest = "dcr_provider"
        elif key == "dcrProviderId":
            suggest = "dcr_provider_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "strategyType":
            suggest = "strategy_type"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyOpenidConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyOpenidConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyOpenidConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: Optional[bool] = None,
                 configs: Optional['outputs.ApplicationAuthStrategyOpenidConnectConfigs'] = None,
                 created_at: Optional[str] = None,
                 dcr_provider: Optional['outputs.ApplicationAuthStrategyOpenidConnectDcrProvider'] = None,
                 dcr_provider_id: Optional[str] = None,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 strategy_type: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param bool active: At least one published product version is using this auth strategy.
        :param 'ApplicationAuthStrategyOpenidConnectConfigsArgs' configs: JSON-B object containing the configuration for the OIDC strategy. Requires replacement if changed. ; Not Null
        :param str created_at: An ISO-8601 timestamp representation of entity creation date.
        :param str dcr_provider_id: Requires replacement if changed.
        :param str display_name: The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str name: The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        :param str strategy_type: Requires replacement if changed. ; Not Null; must be one of ["openid_connect"]
        :param str updated_at: An ISO-8601 timestamp representation of entity update date.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dcr_provider is not None:
            pulumi.set(__self__, "dcr_provider", dcr_provider)
        if dcr_provider_id is not None:
            pulumi.set(__self__, "dcr_provider_id", dcr_provider_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if strategy_type is not None:
            pulumi.set(__self__, "strategy_type", strategy_type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        At least one published product version is using this auth strategy.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def configs(self) -> Optional['outputs.ApplicationAuthStrategyOpenidConnectConfigs']:
        """
        JSON-B object containing the configuration for the OIDC strategy. Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        An ISO-8601 timestamp representation of entity creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dcrProvider")
    def dcr_provider(self) -> Optional['outputs.ApplicationAuthStrategyOpenidConnectDcrProvider']:
        return pulumi.get(self, "dcr_provider")

    @property
    @pulumi.getter(name="dcrProviderId")
    def dcr_provider_id(self) -> Optional[str]:
        """
        Requires replacement if changed.
        """
        return pulumi.get(self, "dcr_provider_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> Optional[str]:
        """
        Requires replacement if changed. ; Not Null; must be one of ["openid_connect"]
        """
        return pulumi.get(self, "strategy_type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        An ISO-8601 timestamp representation of entity update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class ApplicationAuthStrategyOpenidConnectConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openidConnect":
            suggest = "openid_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyOpenidConnectConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyOpenidConnectConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyOpenidConnectConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openid_connect: Optional['outputs.ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect'] = None):
        """
        :param 'ApplicationAuthStrategyOpenidConnectConfigsOpenidConnectArgs' openid_connect: A more advanced mode to configure an API Product Version’s Application Auth Strategy.
               Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests.
               Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy.
               An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
        """
        if openid_connect is not None:
            pulumi.set(__self__, "openid_connect", openid_connect)

    @property
    @pulumi.getter(name="openidConnect")
    def openid_connect(self) -> Optional['outputs.ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect']:
        """
        A more advanced mode to configure an API Product Version’s Application Auth Strategy.
        Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests.
        Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy.
        An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
        """
        return pulumi.get(self, "openid_connect")


@pulumi.output_type
class ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "authMethods":
            suggest = "auth_methods"
        elif key == "credentialClaims":
            suggest = "credential_claims"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None,
                 auth_methods: Optional[Sequence[str]] = None,
                 credential_claims: Optional[Sequence[str]] = None,
                 issuer: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param str additional_properties: Parsed as JSON.
        :param Sequence[str] auth_methods: Requires replacement if changed. ; Not Null
        :param Sequence[str] credential_claims: Requires replacement if changed. ; Not Null
        :param str issuer: Requires replacement if changed. ; Not Null
        :param Sequence[str] scopes: Requires replacement if changed. ; Not Null
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if auth_methods is not None:
            pulumi.set(__self__, "auth_methods", auth_methods)
        if credential_claims is not None:
            pulumi.set(__self__, "credential_claims", credential_claims)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Optional[Sequence[str]]:
        """
        Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="credentialClaims")
    def credential_claims(self) -> Optional[Sequence[str]]:
        """
        Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "credential_claims")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ApplicationAuthStrategyOpenidConnectDcrProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAuthStrategyOpenidConnectDcrProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAuthStrategyOpenidConnectDcrProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAuthStrategyOpenidConnectDcrProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 provider_type: Optional[str] = None):
        """
        :param str display_name: The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str provider_type: The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[str]:
        """
        The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudGatewayNetworkId":
            suggest = "cloud_gateway_network_id"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "egressIpAddresses":
            suggest = "egress_ip_addresses"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscale'] = None,
                 cloud_gateway_network_id: Optional[str] = None,
                 created_at: Optional[str] = None,
                 egress_ip_addresses: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence[str]] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None,
                 state: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param 'CloudGatewayConfigurationDataplaneGroupAutoscaleArgs' autoscale: Not Null
        :param str cloud_gateway_network_id: Not Null
        :param str created_at: An RFC-3339 timestamp representation of data-plane group creation date.
        :param Sequence[str] egress_ip_addresses: List of egress IP addresses for the network that this data-plane group runs on.
        :param str id: ID of the data-plane group that represents a deployment target for a set of data-planes.
        :param Sequence[str] private_ip_addresses: List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
        :param str provider: Name of cloud provider. Not Null; must be one of ["aws"]
        :param str region: Region ID for cloud provider region. Not Null
        :param str state: State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
        :param str updated_at: An RFC-3339 timestamp representation of data-plane group update date.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if cloud_gateway_network_id is not None:
            pulumi.set(__self__, "cloud_gateway_network_id", cloud_gateway_network_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if egress_ip_addresses is not None:
            pulumi.set(__self__, "egress_ip_addresses", egress_ip_addresses)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscale']:
        """
        Not Null
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudGatewayNetworkId")
    def cloud_gateway_network_id(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "cloud_gateway_network_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        An RFC-3339 timestamp representation of data-plane group creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="egressIpAddresses")
    def egress_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        List of egress IP addresses for the network that this data-plane group runs on.
        """
        return pulumi.get(self, "egress_ip_addresses")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the data-plane group that represents a deployment target for a set of data-planes.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Name of cloud provider. Not Null; must be one of ["aws"]
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region ID for cloud provider region. Not Null
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        An RFC-3339 timestamp representation of data-plane group update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationDataPlaneGroupAutoscaleAutopilot":
            suggest = "configuration_data_plane_group_autoscale_autopilot"
        elif key == "configurationDataPlaneGroupAutoscaleStatic":
            suggest = "configuration_data_plane_group_autoscale_static"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_data_plane_group_autoscale_autopilot: Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot'] = None,
                 configuration_data_plane_group_autoscale_static: Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic'] = None):
        """
        :param 'CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotArgs' configuration_data_plane_group_autoscale_autopilot: Object that describes the autopilot autoscaling strategy.
        :param 'CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticArgs' configuration_data_plane_group_autoscale_static: Object that describes the static autoscaling strategy.
        """
        if configuration_data_plane_group_autoscale_autopilot is not None:
            pulumi.set(__self__, "configuration_data_plane_group_autoscale_autopilot", configuration_data_plane_group_autoscale_autopilot)
        if configuration_data_plane_group_autoscale_static is not None:
            pulumi.set(__self__, "configuration_data_plane_group_autoscale_static", configuration_data_plane_group_autoscale_static)

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleAutopilot")
    def configuration_data_plane_group_autoscale_autopilot(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot']:
        """
        Object that describes the autopilot autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_autopilot")

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleStatic")
    def configuration_data_plane_group_autoscale_static(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic']:
        """
        Object that describes the static autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_static")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseRps":
            suggest = "base_rps"
        elif key == "maxRps":
            suggest = "max_rps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_rps: Optional[int] = None,
                 kind: Optional[str] = None,
                 max_rps: Optional[int] = None):
        """
        :param int base_rps: Base number of requests per second that the deployment target should support. Not Null
        :param str kind: Not Null; must be one of ["autopilot"]
        :param int max_rps: Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        if base_rps is not None:
            pulumi.set(__self__, "base_rps", base_rps)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if max_rps is not None:
            pulumi.set(__self__, "max_rps", max_rps)

    @property
    @pulumi.getter(name="baseRps")
    def base_rps(self) -> Optional[int]:
        """
        Base number of requests per second that the deployment target should support. Not Null
        """
        return pulumi.get(self, "base_rps")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Not Null; must be one of ["autopilot"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="maxRps")
    def max_rps(self) -> Optional[int]:
        """
        Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        return pulumi.get(self, "max_rps")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "requestedInstances":
            suggest = "requested_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[str] = None,
                 kind: Optional[str] = None,
                 requested_instances: Optional[int] = None):
        """
        :param str instance_type: Instance type name to indicate capacity. Not Null; must be one of ["small", "medium", "large"]
        :param str kind: Not Null; must be one of ["static"]
        :param int requested_instances: Number of data-planes the deployment target will contain. Not Null
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if requested_instances is not None:
            pulumi.set(__self__, "requested_instances", requested_instances)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Instance type name to indicate capacity. Not Null; must be one of ["small", "medium", "large"]
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Not Null; must be one of ["static"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="requestedInstances")
    def requested_instances(self) -> Optional[int]:
        """
        Number of data-planes the deployment target will contain. Not Null
        """
        return pulumi.get(self, "requested_instances")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudGatewayNetworkId":
            suggest = "cloud_gateway_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscale'] = None,
                 cloud_gateway_network_id: Optional[str] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider: Name of cloud provider. must be one of ["aws"]
        :param str region: Region ID for cloud provider region.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if cloud_gateway_network_id is not None:
            pulumi.set(__self__, "cloud_gateway_network_id", cloud_gateway_network_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudGatewayNetworkId")
    def cloud_gateway_network_id(self) -> Optional[str]:
        return pulumi.get(self, "cloud_gateway_network_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Name of cloud provider. must be one of ["aws"]
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region ID for cloud provider region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupConfigAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationDataPlaneGroupAutoscaleAutopilot":
            suggest = "configuration_data_plane_group_autoscale_autopilot"
        elif key == "configurationDataPlaneGroupAutoscaleStatic":
            suggest = "configuration_data_plane_group_autoscale_static"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupConfigAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_data_plane_group_autoscale_autopilot: Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot'] = None,
                 configuration_data_plane_group_autoscale_static: Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic'] = None):
        """
        :param 'CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotArgs' configuration_data_plane_group_autoscale_autopilot: Object that describes the autopilot autoscaling strategy.
        :param 'CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticArgs' configuration_data_plane_group_autoscale_static: Object that describes the static autoscaling strategy.
        """
        if configuration_data_plane_group_autoscale_autopilot is not None:
            pulumi.set(__self__, "configuration_data_plane_group_autoscale_autopilot", configuration_data_plane_group_autoscale_autopilot)
        if configuration_data_plane_group_autoscale_static is not None:
            pulumi.set(__self__, "configuration_data_plane_group_autoscale_static", configuration_data_plane_group_autoscale_static)

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleAutopilot")
    def configuration_data_plane_group_autoscale_autopilot(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot']:
        """
        Object that describes the autopilot autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_autopilot")

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleStatic")
    def configuration_data_plane_group_autoscale_static(self) -> Optional['outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic']:
        """
        Object that describes the static autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_static")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseRps":
            suggest = "base_rps"
        elif key == "maxRps":
            suggest = "max_rps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_rps: Optional[int] = None,
                 kind: Optional[str] = None,
                 max_rps: Optional[int] = None):
        """
        :param int base_rps: Base number of requests per second that the deployment target should support.
        :param str kind: must be one of ["autopilot"]
        :param int max_rps: Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        if base_rps is not None:
            pulumi.set(__self__, "base_rps", base_rps)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if max_rps is not None:
            pulumi.set(__self__, "max_rps", max_rps)

    @property
    @pulumi.getter(name="baseRps")
    def base_rps(self) -> Optional[int]:
        """
        Base number of requests per second that the deployment target should support.
        """
        return pulumi.get(self, "base_rps")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        must be one of ["autopilot"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="maxRps")
    def max_rps(self) -> Optional[int]:
        """
        Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        return pulumi.get(self, "max_rps")


@pulumi.output_type
class CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "requestedInstances":
            suggest = "requested_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[str] = None,
                 kind: Optional[str] = None,
                 requested_instances: Optional[int] = None):
        """
        :param str instance_type: Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        :param str kind: must be one of ["static"]
        :param int requested_instances: Number of data-planes the deployment target will contain.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if requested_instances is not None:
            pulumi.set(__self__, "requested_instances", requested_instances)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        must be one of ["static"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="requestedInstances")
    def requested_instances(self) -> Optional[int]:
        """
        Number of data-planes the deployment target will contain.
        """
        return pulumi.get(self, "requested_instances")


@pulumi.output_type
class CloudGatewayCustomDomainStateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportedStatus":
            suggest = "reported_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayCustomDomainStateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayCustomDomainStateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayCustomDomainStateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reason: Optional[str] = None,
                 reported_status: Optional[str] = None):
        """
        :param str reason: Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
        :param str reported_status: Reported status of the custom domain from backing infrastructure.
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if reported_status is not None:
            pulumi.set(__self__, "reported_status", reported_status)

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter(name="reportedStatus")
    def reported_status(self) -> Optional[str]:
        """
        Reported status of the custom domain from backing infrastructure.
        """
        return pulumi.get(self, "reported_status")


@pulumi.output_type
class CloudGatewayNetworkFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedCidrBlocks":
            suggest = "allowed_cidr_blocks"
        elif key == "deniedCidrBlocks":
            suggest = "denied_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayNetworkFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayNetworkFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayNetworkFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_cidr_blocks: Optional[Sequence[str]] = None,
                 denied_cidr_blocks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allowed_cidr_blocks: List of allowed CIDR blocks to access a network.
        :param Sequence[str] denied_cidr_blocks: List of denied CIDR blocks to access a network.
        """
        if allowed_cidr_blocks is not None:
            pulumi.set(__self__, "allowed_cidr_blocks", allowed_cidr_blocks)
        if denied_cidr_blocks is not None:
            pulumi.set(__self__, "denied_cidr_blocks", denied_cidr_blocks)

    @property
    @pulumi.getter(name="allowedCidrBlocks")
    def allowed_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of allowed CIDR blocks to access a network.
        """
        return pulumi.get(self, "allowed_cidr_blocks")

    @property
    @pulumi.getter(name="deniedCidrBlocks")
    def denied_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        List of denied CIDR blocks to access a network.
        """
        return pulumi.get(self, "denied_cidr_blocks")


@pulumi.output_type
class CloudGatewayNetworkProviderMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayNetworkProviderMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayNetworkProviderMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayNetworkProviderMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class CloudGatewayTransitGatewayDnsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainProxyLists":
            suggest = "domain_proxy_lists"
        elif key == "remoteDnsServerIpAddresses":
            suggest = "remote_dns_server_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayTransitGatewayDnsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayTransitGatewayDnsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayTransitGatewayDnsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_proxy_lists: Optional[Sequence[str]] = None,
                 remote_dns_server_ip_addresses: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] domain_proxy_lists: Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
               for a transit gateway.
        :param Sequence[str] remote_dns_server_ip_addresses: Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway. Requires replacement if changed. ; Not Null
        """
        if domain_proxy_lists is not None:
            pulumi.set(__self__, "domain_proxy_lists", domain_proxy_lists)
        if remote_dns_server_ip_addresses is not None:
            pulumi.set(__self__, "remote_dns_server_ip_addresses", remote_dns_server_ip_addresses)

    @property
    @pulumi.getter(name="domainProxyLists")
    def domain_proxy_lists(self) -> Optional[Sequence[str]]:
        """
        Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
        for a transit gateway.
        """
        return pulumi.get(self, "domain_proxy_lists")

    @property
    @pulumi.getter(name="remoteDnsServerIpAddresses")
    def remote_dns_server_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway. Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "remote_dns_server_ip_addresses")


@pulumi.output_type
class CloudGatewayTransitGatewayTransitGatewayAttachmentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsTransitGatewayAttachmentConfig":
            suggest = "aws_transit_gateway_attachment_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayTransitGatewayTransitGatewayAttachmentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayTransitGatewayTransitGatewayAttachmentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayTransitGatewayTransitGatewayAttachmentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_transit_gateway_attachment_config: Optional['outputs.CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig'] = None):
        """
        :param 'CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfigArgs' aws_transit_gateway_attachment_config: Requires replacement if changed.
        """
        if aws_transit_gateway_attachment_config is not None:
            pulumi.set(__self__, "aws_transit_gateway_attachment_config", aws_transit_gateway_attachment_config)

    @property
    @pulumi.getter(name="awsTransitGatewayAttachmentConfig")
    def aws_transit_gateway_attachment_config(self) -> Optional['outputs.CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig']:
        """
        Requires replacement if changed.
        """
        return pulumi.get(self, "aws_transit_gateway_attachment_config")


@pulumi.output_type
class CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramShareArn":
            suggest = "ram_share_arn"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: Optional[str] = None,
                 ram_share_arn: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None):
        """
        :param str kind: Requires replacement if changed. ; Not Null; must be one of ["aws-transit-gateway-attachment"]
        :param str ram_share_arn: Resource Share ARN to verify request to create transit gateway attachment. Requires replacement if changed. ; Not Null
        :param str transit_gateway_id: AWS Transit Gateway ID to create attachment to. Requires replacement if changed. ; Not Null
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if ram_share_arn is not None:
            pulumi.set(__self__, "ram_share_arn", ram_share_arn)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Requires replacement if changed. ; Not Null; must be one of ["aws-transit-gateway-attachment"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="ramShareArn")
    def ram_share_arn(self) -> Optional[str]:
        """
        Resource Share ARN to verify request to create transit gateway attachment. Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "ram_share_arn")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        """
        AWS Transit Gateway ID to create attachment to. Requires replacement if changed. ; Not Null
        """
        return pulumi.get(self, "transit_gateway_id")


@pulumi.output_type
class GatewayAclConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayBasicAuthConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayControlPlaneConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneEndpoint":
            suggest = "control_plane_endpoint"
        elif key == "telemetryEndpoint":
            suggest = "telemetry_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayControlPlaneConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayControlPlaneConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayControlPlaneConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_endpoint: Optional[str] = None,
                 telemetry_endpoint: Optional[str] = None):
        """
        :param str control_plane_endpoint: Control Plane Endpoint.
        :param str telemetry_endpoint: Telemetry Endpoint.
        """
        if control_plane_endpoint is not None:
            pulumi.set(__self__, "control_plane_endpoint", control_plane_endpoint)
        if telemetry_endpoint is not None:
            pulumi.set(__self__, "telemetry_endpoint", telemetry_endpoint)

    @property
    @pulumi.getter(name="controlPlaneEndpoint")
    def control_plane_endpoint(self) -> Optional[str]:
        """
        Control Plane Endpoint.
        """
        return pulumi.get(self, "control_plane_endpoint")

    @property
    @pulumi.getter(name="telemetryEndpoint")
    def telemetry_endpoint(self) -> Optional[str]:
        """
        Telemetry Endpoint.
        """
        return pulumi.get(self, "telemetry_endpoint")


@pulumi.output_type
class GatewayControlPlaneMembershipMember(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: Requires replacement if changed.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Requires replacement if changed.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayControlPlaneProxyUrl(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 protocol: str):
        """
        :param str host: Hostname of the proxy URL.
        :param int port: Port of the proxy URL.
        :param str protocol: Protocol of the proxy URL.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the proxy URL.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port of the proxy URL.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the proxy URL.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GatewayHmacAuthConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayJwtConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayKeyAuthConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayKeyPem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayKeyPem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayKeyPem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayKeyPem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: Optional[str] = None,
                 public_key: Optional[str] = None):
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GatewayKeySet(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAclConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hideGroupsHeader":
            suggest = "hide_groups_header"
        elif key == "includeConsumerGroups":
            suggest = "include_consumer_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAclConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAclConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAclConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None,
                 hide_groups_header: Optional[bool] = None,
                 include_consumer_groups: Optional[bool] = None):
        """
        :param Sequence[str] allows: Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        :param Sequence[str] denies: Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        :param bool hide_groups_header: If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)
        if hide_groups_header is not None:
            pulumi.set(__self__, "hide_groups_header", hide_groups_header)
        if include_consumer_groups is not None:
            pulumi.set(__self__, "include_consumer_groups", include_consumer_groups)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        """
        Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        """
        Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "denies")

    @property
    @pulumi.getter(name="hideGroupsHeader")
    def hide_groups_header(self) -> Optional[bool]:
        """
        If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
        """
        return pulumi.get(self, "hide_groups_header")

    @property
    @pulumi.getter(name="includeConsumerGroups")
    def include_consumer_groups(self) -> Optional[bool]:
        return pulumi.get(self, "include_consumer_groups")


@pulumi.output_type
class GatewayPluginAclConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAclConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAclRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAclService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConfig(dict):
    def __init__(__self__, *,
                 prompts: Optional['outputs.GatewayPluginAiPromptDecoratorConfigPrompts'] = None):
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)

    @property
    @pulumi.getter
    def prompts(self) -> Optional['outputs.GatewayPluginAiPromptDecoratorConfigPrompts']:
        return pulumi.get(self, "prompts")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConfigPrompts(dict):
    def __init__(__self__, *,
                 appends: Optional[Sequence['outputs.GatewayPluginAiPromptDecoratorConfigPromptsAppend']] = None,
                 prepends: Optional[Sequence['outputs.GatewayPluginAiPromptDecoratorConfigPromptsPrepend']] = None):
        """
        :param Sequence['GatewayPluginAiPromptDecoratorConfigPromptsAppendArgs'] appends: Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
        :param Sequence['GatewayPluginAiPromptDecoratorConfigPromptsPrependArgs'] prepends: Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if prepends is not None:
            pulumi.set(__self__, "prepends", prepends)

    @property
    @pulumi.getter
    def appends(self) -> Optional[Sequence['outputs.GatewayPluginAiPromptDecoratorConfigPromptsAppend']]:
        """
        Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
        """
        return pulumi.get(self, "appends")

    @property
    @pulumi.getter
    def prepends(self) -> Optional[Sequence['outputs.GatewayPluginAiPromptDecoratorConfigPromptsPrepend']]:
        """
        Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
        """
        return pulumi.get(self, "prepends")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConfigPromptsAppend(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str content: Not Null
        :param str role: must be one of ["system", "assistant", "user"]
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        must be one of ["system", "assistant", "user"]
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConfigPromptsPrepend(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str content: Not Null
        :param str role: must be one of ["system", "assistant", "user"]
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        must be one of ["system", "assistant", "user"]
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptDecoratorService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptGuardConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllConversationHistory":
            suggest = "allow_all_conversation_history"
        elif key == "allowPatterns":
            suggest = "allow_patterns"
        elif key == "denyPatterns":
            suggest = "deny_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiPromptGuardConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiPromptGuardConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiPromptGuardConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_conversation_history: Optional[bool] = None,
                 allow_patterns: Optional[Sequence[str]] = None,
                 deny_patterns: Optional[Sequence[str]] = None):
        """
        :param bool allow_all_conversation_history: If true, will ignore all previous chat prompts from the conversation history.
        :param Sequence[str] allow_patterns: Array of valid regex patterns, or valid questions from the 'user' role in chat.
        :param Sequence[str] deny_patterns: Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
        """
        if allow_all_conversation_history is not None:
            pulumi.set(__self__, "allow_all_conversation_history", allow_all_conversation_history)
        if allow_patterns is not None:
            pulumi.set(__self__, "allow_patterns", allow_patterns)
        if deny_patterns is not None:
            pulumi.set(__self__, "deny_patterns", deny_patterns)

    @property
    @pulumi.getter(name="allowAllConversationHistory")
    def allow_all_conversation_history(self) -> Optional[bool]:
        """
        If true, will ignore all previous chat prompts from the conversation history.
        """
        return pulumi.get(self, "allow_all_conversation_history")

    @property
    @pulumi.getter(name="allowPatterns")
    def allow_patterns(self) -> Optional[Sequence[str]]:
        """
        Array of valid regex patterns, or valid questions from the 'user' role in chat.
        """
        return pulumi.get(self, "allow_patterns")

    @property
    @pulumi.getter(name="denyPatterns")
    def deny_patterns(self) -> Optional[Sequence[str]]:
        """
        Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
        """
        return pulumi.get(self, "deny_patterns")


@pulumi.output_type
class GatewayPluginAiPromptGuardConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptGuardConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptGuardRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptGuardService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUntemplatedRequests":
            suggest = "allow_untemplated_requests"
        elif key == "logOriginalRequest":
            suggest = "log_original_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiPromptTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiPromptTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiPromptTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_untemplated_requests: Optional[bool] = None,
                 log_original_request: Optional[bool] = None,
                 templates: Optional[Sequence['outputs.GatewayPluginAiPromptTemplateConfigTemplate']] = None):
        """
        :param bool allow_untemplated_requests: Set true to allow requests that don't call or match any template.
        :param bool log_original_request: Set true to add the original request to the Kong log plugin(s) output.
        :param Sequence['GatewayPluginAiPromptTemplateConfigTemplateArgs'] templates: Array of templates available to the request context.
        """
        if allow_untemplated_requests is not None:
            pulumi.set(__self__, "allow_untemplated_requests", allow_untemplated_requests)
        if log_original_request is not None:
            pulumi.set(__self__, "log_original_request", log_original_request)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter(name="allowUntemplatedRequests")
    def allow_untemplated_requests(self) -> Optional[bool]:
        """
        Set true to allow requests that don't call or match any template.
        """
        return pulumi.get(self, "allow_untemplated_requests")

    @property
    @pulumi.getter(name="logOriginalRequest")
    def log_original_request(self) -> Optional[bool]:
        """
        Set true to add the original request to the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_original_request")

    @property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.GatewayPluginAiPromptTemplateConfigTemplate']]:
        """
        Array of templates available to the request context.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class GatewayPluginAiPromptTemplateConfigTemplate(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str name: Unique name for the template, can be called with `{template://NAME}`. Not Null
        :param str template: Template string for this request, supports mustache-style `{{placeholders}}`. Not Null
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name for the template, can be called with `{template://NAME}`. Not Null
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        Template string for this request, supports mustache-style `{{placeholders}}`. Not Null
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class GatewayPluginAiPromptTemplateConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptTemplateConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptTemplateRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiPromptTemplateService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiProxyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseStreaming":
            suggest = "response_streaming"
        elif key == "routeType":
            suggest = "route_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiProxyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiProxyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiProxyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.GatewayPluginAiProxyConfigAuth'] = None,
                 logging: Optional['outputs.GatewayPluginAiProxyConfigLogging'] = None,
                 model: Optional['outputs.GatewayPluginAiProxyConfigModel'] = None,
                 response_streaming: Optional[str] = None,
                 route_type: Optional[str] = None):
        """
        :param str response_streaming: Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
        :param str route_type: The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if response_streaming is not None:
            pulumi.set(__self__, "response_streaming", response_streaming)
        if route_type is not None:
            pulumi.set(__self__, "route_type", route_type)

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.GatewayPluginAiProxyConfigAuth']:
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.GatewayPluginAiProxyConfigLogging']:
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def model(self) -> Optional['outputs.GatewayPluginAiProxyConfigModel']:
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="responseStreaming")
    def response_streaming(self) -> Optional[str]:
        """
        Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
        """
        return pulumi.get(self, "response_streaming")

    @property
    @pulumi.getter(name="routeType")
    def route_type(self) -> Optional[str]:
        """
        The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
        """
        return pulumi.get(self, "route_type")


@pulumi.output_type
class GatewayPluginAiProxyConfigAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureClientId":
            suggest = "azure_client_id"
        elif key == "azureClientSecret":
            suggest = "azure_client_secret"
        elif key == "azureTenantId":
            suggest = "azure_tenant_id"
        elif key == "azureUseManagedIdentity":
            suggest = "azure_use_managed_identity"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"
        elif key == "paramLocation":
            suggest = "param_location"
        elif key == "paramName":
            suggest = "param_name"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiProxyConfigAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiProxyConfigAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiProxyConfigAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_client_id: Optional[str] = None,
                 azure_client_secret: Optional[str] = None,
                 azure_tenant_id: Optional[str] = None,
                 azure_use_managed_identity: Optional[bool] = None,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None,
                 param_location: Optional[str] = None,
                 param_name: Optional[str] = None,
                 param_value: Optional[str] = None):
        """
        :param str azure_client_id: If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
        :param str azure_client_secret: If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
        :param str azure_tenant_id: If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
        :param bool azure_use_managed_identity: Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
        :param str header_name: If AI model requires authentication via Authorization or API key header, specify its name here.
        :param str header_value: Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
        :param str param_location: Specify whether the 'param*name' and 'param*value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
        :param str param_name: If AI model requires authentication via query parameter, specify its name here.
        :param str param_value: Specify the full parameter value for 'param_name'.
        """
        if azure_client_id is not None:
            pulumi.set(__self__, "azure_client_id", azure_client_id)
        if azure_client_secret is not None:
            pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        if azure_tenant_id is not None:
            pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        if azure_use_managed_identity is not None:
            pulumi.set(__self__, "azure_use_managed_identity", azure_use_managed_identity)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if param_location is not None:
            pulumi.set(__self__, "param_location", param_location)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if param_value is not None:
            pulumi.set(__self__, "param_value", param_value)

    @property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> Optional[str]:
        """
        If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
        """
        return pulumi.get(self, "azure_client_id")

    @property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> Optional[str]:
        """
        If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
        """
        return pulumi.get(self, "azure_client_secret")

    @property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> Optional[str]:
        """
        If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
        """
        return pulumi.get(self, "azure_tenant_id")

    @property
    @pulumi.getter(name="azureUseManagedIdentity")
    def azure_use_managed_identity(self) -> Optional[bool]:
        """
        Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
        """
        return pulumi.get(self, "azure_use_managed_identity")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        If AI model requires authentication via Authorization or API key header, specify its name here.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter(name="paramLocation")
    def param_location(self) -> Optional[str]:
        """
        Specify whether the 'param*name' and 'param*value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
        """
        return pulumi.get(self, "param_location")

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[str]:
        """
        If AI model requires authentication via query parameter, specify its name here.
        """
        return pulumi.get(self, "param_name")

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> Optional[str]:
        """
        Specify the full parameter value for 'param_name'.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GatewayPluginAiProxyConfigLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logPayloads":
            suggest = "log_payloads"
        elif key == "logStatistics":
            suggest = "log_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiProxyConfigLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiProxyConfigLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiProxyConfigLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_payloads: Optional[bool] = None,
                 log_statistics: Optional[bool] = None):
        """
        :param bool log_payloads: If enabled, will log the request and response body into the Kong log plugin(s) output.
        :param bool log_statistics: If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
        """
        if log_payloads is not None:
            pulumi.set(__self__, "log_payloads", log_payloads)
        if log_statistics is not None:
            pulumi.set(__self__, "log_statistics", log_statistics)

    @property
    @pulumi.getter(name="logPayloads")
    def log_payloads(self) -> Optional[bool]:
        """
        If enabled, will log the request and response body into the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_payloads")

    @property
    @pulumi.getter(name="logStatistics")
    def log_statistics(self) -> Optional[bool]:
        """
        If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_statistics")


@pulumi.output_type
class GatewayPluginAiProxyConfigModel(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 options: Optional['outputs.GatewayPluginAiProxyConfigModelOptions'] = None,
                 provider: Optional[str] = None):
        """
        :param str name: Model name to execute.
        :param 'GatewayPluginAiProxyConfigModelOptionsArgs' options: Key/value settings for the model
        :param str provider: AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Model name to execute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GatewayPluginAiProxyConfigModelOptions']:
        """
        Key/value settings for the model
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class GatewayPluginAiProxyConfigModelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anthropicVersion":
            suggest = "anthropic_version"
        elif key == "azureApiVersion":
            suggest = "azure_api_version"
        elif key == "azureDeploymentId":
            suggest = "azure_deployment_id"
        elif key == "azureInstance":
            suggest = "azure_instance"
        elif key == "llama2Format":
            suggest = "llama2_format"
        elif key == "maxTokens":
            suggest = "max_tokens"
        elif key == "mistralFormat":
            suggest = "mistral_format"
        elif key == "topK":
            suggest = "top_k"
        elif key == "topP":
            suggest = "top_p"
        elif key == "upstreamPath":
            suggest = "upstream_path"
        elif key == "upstreamUrl":
            suggest = "upstream_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAiProxyConfigModelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAiProxyConfigModelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAiProxyConfigModelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anthropic_version: Optional[str] = None,
                 azure_api_version: Optional[str] = None,
                 azure_deployment_id: Optional[str] = None,
                 azure_instance: Optional[str] = None,
                 llama2_format: Optional[str] = None,
                 max_tokens: Optional[int] = None,
                 mistral_format: Optional[str] = None,
                 temperature: Optional[float] = None,
                 top_k: Optional[int] = None,
                 top_p: Optional[float] = None,
                 upstream_path: Optional[str] = None,
                 upstream_url: Optional[str] = None):
        """
        :param str anthropic_version: Defines the schema/API version, if using Anthropic provider.
        :param str azure_api_version: 'api-version' for Azure OpenAI instances.
        :param str azure_deployment_id: Deployment ID for Azure OpenAI instances.
        :param str azure_instance: Instance name for Azure OpenAI hosted models.
        :param str llama2_format: If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
        :param int max_tokens: Defines the max_tokens, if using chat or completion models.
        :param str mistral_format: If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
        :param float temperature: Defines the matching temperature, if using chat or completion models.
        :param int top_k: Defines the top-k most likely tokens, if supported.
        :param float top_p: Defines the top-p probability mass, if supported.
        :param str upstream_path: Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
        :param str upstream_url: Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
        """
        if anthropic_version is not None:
            pulumi.set(__self__, "anthropic_version", anthropic_version)
        if azure_api_version is not None:
            pulumi.set(__self__, "azure_api_version", azure_api_version)
        if azure_deployment_id is not None:
            pulumi.set(__self__, "azure_deployment_id", azure_deployment_id)
        if azure_instance is not None:
            pulumi.set(__self__, "azure_instance", azure_instance)
        if llama2_format is not None:
            pulumi.set(__self__, "llama2_format", llama2_format)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if mistral_format is not None:
            pulumi.set(__self__, "mistral_format", mistral_format)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if upstream_path is not None:
            pulumi.set(__self__, "upstream_path", upstream_path)
        if upstream_url is not None:
            pulumi.set(__self__, "upstream_url", upstream_url)

    @property
    @pulumi.getter(name="anthropicVersion")
    def anthropic_version(self) -> Optional[str]:
        """
        Defines the schema/API version, if using Anthropic provider.
        """
        return pulumi.get(self, "anthropic_version")

    @property
    @pulumi.getter(name="azureApiVersion")
    def azure_api_version(self) -> Optional[str]:
        """
        'api-version' for Azure OpenAI instances.
        """
        return pulumi.get(self, "azure_api_version")

    @property
    @pulumi.getter(name="azureDeploymentId")
    def azure_deployment_id(self) -> Optional[str]:
        """
        Deployment ID for Azure OpenAI instances.
        """
        return pulumi.get(self, "azure_deployment_id")

    @property
    @pulumi.getter(name="azureInstance")
    def azure_instance(self) -> Optional[str]:
        """
        Instance name for Azure OpenAI hosted models.
        """
        return pulumi.get(self, "azure_instance")

    @property
    @pulumi.getter(name="llama2Format")
    def llama2_format(self) -> Optional[str]:
        """
        If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
        """
        return pulumi.get(self, "llama2_format")

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[int]:
        """
        Defines the max_tokens, if using chat or completion models.
        """
        return pulumi.get(self, "max_tokens")

    @property
    @pulumi.getter(name="mistralFormat")
    def mistral_format(self) -> Optional[str]:
        """
        If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
        """
        return pulumi.get(self, "mistral_format")

    @property
    @pulumi.getter
    def temperature(self) -> Optional[float]:
        """
        Defines the matching temperature, if using chat or completion models.
        """
        return pulumi.get(self, "temperature")

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[int]:
        """
        Defines the top-k most likely tokens, if supported.
        """
        return pulumi.get(self, "top_k")

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[float]:
        """
        Defines the top-p probability mass, if supported.
        """
        return pulumi.get(self, "top_p")

    @property
    @pulumi.getter(name="upstreamPath")
    def upstream_path(self) -> Optional[str]:
        """
        Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
        """
        return pulumi.get(self, "upstream_path")

    @property
    @pulumi.getter(name="upstreamUrl")
    def upstream_url(self) -> Optional[str]:
        """
        Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
        """
        return pulumi.get(self, "upstream_url")


@pulumi.output_type
class GatewayPluginAiProxyConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiProxyConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiProxyRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAiProxyService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAwsLambdaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAssumeRoleArn":
            suggest = "aws_assume_role_arn"
        elif key == "awsImdsProtocolVersion":
            suggest = "aws_imds_protocol_version"
        elif key == "awsKey":
            suggest = "aws_key"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsRoleSessionName":
            suggest = "aws_role_session_name"
        elif key == "awsSecret":
            suggest = "aws_secret"
        elif key == "awsgatewayCompatible":
            suggest = "awsgateway_compatible"
        elif key == "base64EncodeBody":
            suggest = "base64_encode_body"
        elif key == "disableHttps":
            suggest = "disable_https"
        elif key == "forwardRequestBody":
            suggest = "forward_request_body"
        elif key == "forwardRequestHeaders":
            suggest = "forward_request_headers"
        elif key == "forwardRequestMethod":
            suggest = "forward_request_method"
        elif key == "forwardRequestUri":
            suggest = "forward_request_uri"
        elif key == "functionName":
            suggest = "function_name"
        elif key == "invocationType":
            suggest = "invocation_type"
        elif key == "isProxyIntegration":
            suggest = "is_proxy_integration"
        elif key == "logType":
            suggest = "log_type"
        elif key == "proxyUrl":
            suggest = "proxy_url"
        elif key == "skipLargeBodies":
            suggest = "skip_large_bodies"
        elif key == "unhandledStatus":
            suggest = "unhandled_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginAwsLambdaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginAwsLambdaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginAwsLambdaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_assume_role_arn: Optional[str] = None,
                 aws_imds_protocol_version: Optional[str] = None,
                 aws_key: Optional[str] = None,
                 aws_region: Optional[str] = None,
                 aws_role_session_name: Optional[str] = None,
                 aws_secret: Optional[str] = None,
                 awsgateway_compatible: Optional[bool] = None,
                 base64_encode_body: Optional[bool] = None,
                 disable_https: Optional[bool] = None,
                 forward_request_body: Optional[bool] = None,
                 forward_request_headers: Optional[bool] = None,
                 forward_request_method: Optional[bool] = None,
                 forward_request_uri: Optional[bool] = None,
                 function_name: Optional[str] = None,
                 host: Optional[str] = None,
                 invocation_type: Optional[str] = None,
                 is_proxy_integration: Optional[bool] = None,
                 keepalive: Optional[float] = None,
                 log_type: Optional[str] = None,
                 port: Optional[int] = None,
                 proxy_url: Optional[str] = None,
                 qualifier: Optional[str] = None,
                 skip_large_bodies: Optional[bool] = None,
                 timeout: Optional[float] = None,
                 unhandled_status: Optional[int] = None):
        """
        :param str aws_assume_role_arn: The target AWS IAM role ARN used to invoke the Lambda function.
        :param str aws_imds_protocol_version: Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
        :param str aws_key: The AWS key credential to be used when invoking the function.
        :param str aws_region: A string representing a host name, such as example.com.
        :param str aws_role_session_name: The identifier of the assumed role session.
        :param str aws_secret: The AWS secret credential to be used when invoking the function.
        :param bool awsgateway_compatible: An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
        :param bool base64_encode_body: An optional value that Base64-encodes the request body.
        :param bool forward_request_body: An optional value that defines whether the request body is sent in the request*body field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate request*body_args field of the request.
        :param bool forward_request_headers: An optional value that defines whether the original HTTP request headers are sent as a map in the request_headers field of the JSON-encoded request.
        :param bool forward_request_method: An optional value that defines whether the original HTTP request method verb is sent in the request_method field of the JSON-encoded request.
        :param bool forward_request_uri: An optional value that defines whether the original HTTP request URI is sent in the request_uri field of the JSON-encoded request.
        :param str function_name: The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
        :param str host: A string representing a host name, such as example.com.
        :param str invocation_type: The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
        :param bool is_proxy_integration: An optional value that defines whether the response format to receive from the Lambda to this format.
        :param float keepalive: An optional value in milliseconds that defines how long an idle connection lives before being closed.
        :param str log_type: The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param str proxy_url: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str qualifier: The qualifier to use when invoking the function.
        :param bool skip_large_bodies: An optional value that defines whether Kong should send large bodies that are buffered to disk
        :param float timeout: An optional timeout in milliseconds when invoking the function.
        :param int unhandled_status: The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
        """
        if aws_assume_role_arn is not None:
            pulumi.set(__self__, "aws_assume_role_arn", aws_assume_role_arn)
        if aws_imds_protocol_version is not None:
            pulumi.set(__self__, "aws_imds_protocol_version", aws_imds_protocol_version)
        if aws_key is not None:
            pulumi.set(__self__, "aws_key", aws_key)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_role_session_name is not None:
            pulumi.set(__self__, "aws_role_session_name", aws_role_session_name)
        if aws_secret is not None:
            pulumi.set(__self__, "aws_secret", aws_secret)
        if awsgateway_compatible is not None:
            pulumi.set(__self__, "awsgateway_compatible", awsgateway_compatible)
        if base64_encode_body is not None:
            pulumi.set(__self__, "base64_encode_body", base64_encode_body)
        if disable_https is not None:
            pulumi.set(__self__, "disable_https", disable_https)
        if forward_request_body is not None:
            pulumi.set(__self__, "forward_request_body", forward_request_body)
        if forward_request_headers is not None:
            pulumi.set(__self__, "forward_request_headers", forward_request_headers)
        if forward_request_method is not None:
            pulumi.set(__self__, "forward_request_method", forward_request_method)
        if forward_request_uri is not None:
            pulumi.set(__self__, "forward_request_uri", forward_request_uri)
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if is_proxy_integration is not None:
            pulumi.set(__self__, "is_proxy_integration", is_proxy_integration)
        if keepalive is not None:
            pulumi.set(__self__, "keepalive", keepalive)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)
        if skip_large_bodies is not None:
            pulumi.set(__self__, "skip_large_bodies", skip_large_bodies)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhandled_status is not None:
            pulumi.set(__self__, "unhandled_status", unhandled_status)

    @property
    @pulumi.getter(name="awsAssumeRoleArn")
    def aws_assume_role_arn(self) -> Optional[str]:
        """
        The target AWS IAM role ARN used to invoke the Lambda function.
        """
        return pulumi.get(self, "aws_assume_role_arn")

    @property
    @pulumi.getter(name="awsImdsProtocolVersion")
    def aws_imds_protocol_version(self) -> Optional[str]:
        """
        Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
        """
        return pulumi.get(self, "aws_imds_protocol_version")

    @property
    @pulumi.getter(name="awsKey")
    def aws_key(self) -> Optional[str]:
        """
        The AWS key credential to be used when invoking the function.
        """
        return pulumi.get(self, "aws_key")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsRoleSessionName")
    def aws_role_session_name(self) -> Optional[str]:
        """
        The identifier of the assumed role session.
        """
        return pulumi.get(self, "aws_role_session_name")

    @property
    @pulumi.getter(name="awsSecret")
    def aws_secret(self) -> Optional[str]:
        """
        The AWS secret credential to be used when invoking the function.
        """
        return pulumi.get(self, "aws_secret")

    @property
    @pulumi.getter(name="awsgatewayCompatible")
    def awsgateway_compatible(self) -> Optional[bool]:
        """
        An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
        """
        return pulumi.get(self, "awsgateway_compatible")

    @property
    @pulumi.getter(name="base64EncodeBody")
    def base64_encode_body(self) -> Optional[bool]:
        """
        An optional value that Base64-encodes the request body.
        """
        return pulumi.get(self, "base64_encode_body")

    @property
    @pulumi.getter(name="disableHttps")
    def disable_https(self) -> Optional[bool]:
        return pulumi.get(self, "disable_https")

    @property
    @pulumi.getter(name="forwardRequestBody")
    def forward_request_body(self) -> Optional[bool]:
        """
        An optional value that defines whether the request body is sent in the request*body field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate request*body_args field of the request.
        """
        return pulumi.get(self, "forward_request_body")

    @property
    @pulumi.getter(name="forwardRequestHeaders")
    def forward_request_headers(self) -> Optional[bool]:
        """
        An optional value that defines whether the original HTTP request headers are sent as a map in the request_headers field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_headers")

    @property
    @pulumi.getter(name="forwardRequestMethod")
    def forward_request_method(self) -> Optional[bool]:
        """
        An optional value that defines whether the original HTTP request method verb is sent in the request_method field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_method")

    @property
    @pulumi.getter(name="forwardRequestUri")
    def forward_request_uri(self) -> Optional[bool]:
        """
        An optional value that defines whether the original HTTP request URI is sent in the request_uri field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_uri")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[str]:
        """
        The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[str]:
        """
        The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
        """
        return pulumi.get(self, "invocation_type")

    @property
    @pulumi.getter(name="isProxyIntegration")
    def is_proxy_integration(self) -> Optional[bool]:
        """
        An optional value that defines whether the response format to receive from the Lambda to this format.
        """
        return pulumi.get(self, "is_proxy_integration")

    @property
    @pulumi.getter
    def keepalive(self) -> Optional[float]:
        """
        An optional value in milliseconds that defines how long an idle connection lives before being closed.
        """
        return pulumi.get(self, "keepalive")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[str]:
        """
        The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter
    def qualifier(self) -> Optional[str]:
        """
        The qualifier to use when invoking the function.
        """
        return pulumi.get(self, "qualifier")

    @property
    @pulumi.getter(name="skipLargeBodies")
    def skip_large_bodies(self) -> Optional[bool]:
        """
        An optional value that defines whether Kong should send large bodies that are buffered to disk
        """
        return pulumi.get(self, "skip_large_bodies")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        """
        An optional timeout in milliseconds when invoking the function.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhandledStatus")
    def unhandled_status(self) -> Optional[int]:
        """
        The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
        """
        return pulumi.get(self, "unhandled_status")


@pulumi.output_type
class GatewayPluginAwsLambdaConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAwsLambdaConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAwsLambdaRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginAwsLambdaService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginBasicAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hideCredentials":
            suggest = "hide_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginBasicAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginBasicAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginBasicAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous: Optional[str] = None,
                 hide_credentials: Optional[bool] = None,
                 realm: Optional[str] = None):
        """
        :param str anonymous: An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `custom_id`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
        :param str realm: When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if hide_credentials is not None:
            pulumi.set(__self__, "hide_credentials", hide_credentials)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `custom_id`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> Optional[bool]:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class GatewayPluginBasicAuthConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginBasicAuthConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginBasicAuthRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginBasicAuthService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorrelationIdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "echoDownstream":
            suggest = "echo_downstream"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginCorrelationIdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginCorrelationIdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginCorrelationIdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 echo_downstream: Optional[bool] = None,
                 generator: Optional[str] = None,
                 header_name: Optional[str] = None):
        """
        :param bool echo_downstream: Whether to echo the header back to downstream (the client).
        :param str generator: The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
        :param str header_name: The HTTP header name to use for the correlation ID.
        """
        if echo_downstream is not None:
            pulumi.set(__self__, "echo_downstream", echo_downstream)
        if generator is not None:
            pulumi.set(__self__, "generator", generator)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="echoDownstream")
    def echo_downstream(self) -> Optional[bool]:
        """
        Whether to echo the header back to downstream (the client).
        """
        return pulumi.get(self, "echo_downstream")

    @property
    @pulumi.getter
    def generator(self) -> Optional[str]:
        """
        The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
        """
        return pulumi.get(self, "generator")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The HTTP header name to use for the correlation ID.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GatewayPluginCorrelationIdConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorrelationIdConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorrelationIdRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorrelationIdService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exposedHeaders":
            suggest = "exposed_headers"
        elif key == "maxAge":
            suggest = "max_age"
        elif key == "preflightContinue":
            suggest = "preflight_continue"
        elif key == "privateNetwork":
            suggest = "private_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginCorsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginCorsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginCorsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional[bool] = None,
                 exposed_headers: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 max_age: Optional[float] = None,
                 methods: Optional[Sequence[str]] = None,
                 origins: Optional[Sequence[str]] = None,
                 preflight_continue: Optional[bool] = None,
                 private_network: Optional[bool] = None):
        """
        :param bool credentials: Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
        :param Sequence[str] exposed_headers: Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
        :param Sequence[str] headers: Value for the `Access-Control-Allow-Headers` header.
        :param float max_age: Indicates how long the results of the preflight request can be cached, in `seconds`.
        :param Sequence[str] methods: 'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
        :param Sequence[str] origins: List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
        :param bool preflight_continue: A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
        :param bool private_network: Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)
        if preflight_continue is not None:
            pulumi.set(__self__, "preflight_continue", preflight_continue)
        if private_network is not None:
            pulumi.set(__self__, "private_network", private_network)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[bool]:
        """
        Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[Sequence[str]]:
        """
        Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
        """
        return pulumi.get(self, "exposed_headers")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        Value for the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        Indicates how long the results of the preflight request can be cached, in `seconds`.
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        """
        'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def origins(self) -> Optional[Sequence[str]]:
        """
        List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter(name="preflightContinue")
    def preflight_continue(self) -> Optional[bool]:
        """
        A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
        """
        return pulumi.get(self, "preflight_continue")

    @property
    @pulumi.getter(name="privateNetwork")
    def private_network(self) -> Optional[bool]:
        """
        Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
        """
        return pulumi.get(self, "private_network")


@pulumi.output_type
class GatewayPluginCorsConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorsConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorsRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginCorsService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginExitTransformerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "handleUnexpected":
            suggest = "handle_unexpected"
        elif key == "handleUnknown":
            suggest = "handle_unknown"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginExitTransformerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginExitTransformerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginExitTransformerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 functions: Optional[Sequence[str]] = None,
                 handle_unexpected: Optional[bool] = None,
                 handle_unknown: Optional[bool] = None):
        """
        :param bool handle_unexpected: Determines whether to handle unexpected errors by transforming their responses.
        :param bool handle_unknown: Determines whether to handle unknown status codes by transforming their responses.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if handle_unexpected is not None:
            pulumi.set(__self__, "handle_unexpected", handle_unexpected)
        if handle_unknown is not None:
            pulumi.set(__self__, "handle_unknown", handle_unknown)

    @property
    @pulumi.getter
    def functions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "functions")

    @property
    @pulumi.getter(name="handleUnexpected")
    def handle_unexpected(self) -> Optional[bool]:
        """
        Determines whether to handle unexpected errors by transforming their responses.
        """
        return pulumi.get(self, "handle_unexpected")

    @property
    @pulumi.getter(name="handleUnknown")
    def handle_unknown(self) -> Optional[bool]:
        """
        Determines whether to handle unknown status codes by transforming their responses.
        """
        return pulumi.get(self, "handle_unknown")


@pulumi.output_type
class GatewayPluginExitTransformerConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginExitTransformerConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginExitTransformerRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginExitTransformerService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginFileLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFieldsByLua":
            suggest = "custom_fields_by_lua"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginFileLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginFileLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginFileLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_fields_by_lua: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 reopen: Optional[bool] = None):
        """
        :param Mapping[str, str] custom_fields_by_lua: Lua code as a key-value map
        :param str path: The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
        :param bool reopen: Determines whether the log file is closed and reopened on every request.
        """
        if custom_fields_by_lua is not None:
            pulumi.set(__self__, "custom_fields_by_lua", custom_fields_by_lua)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if reopen is not None:
            pulumi.set(__self__, "reopen", reopen)

    @property
    @pulumi.getter(name="customFieldsByLua")
    def custom_fields_by_lua(self) -> Optional[Mapping[str, str]]:
        """
        Lua code as a key-value map
        """
        return pulumi.get(self, "custom_fields_by_lua")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def reopen(self) -> Optional[bool]:
        """
        Determines whether the log file is closed and reopened on every request.
        """
        return pulumi.get(self, "reopen")


@pulumi.output_type
class GatewayPluginFileLogConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginFileLogConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginFileLogRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginFileLogService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginIpRestrictionConfig(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None,
                 message: Optional[str] = None,
                 status: Optional[float] = None):
        """
        :param Sequence[str] allows: List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
        :param Sequence[str] denies: List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
        :param str message: The message to send as a response body to rejected requests.
        :param float status: The HTTP status of the requests that will be rejected by the plugin.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        """
        List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        """
        List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "denies")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The message to send as a response body to rejected requests.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def status(self) -> Optional[float]:
        """
        The HTTP status of the requests that will be rejected by the plugin.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GatewayPluginIpRestrictionConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginIpRestrictionConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginIpRestrictionRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginIpRestrictionService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJqConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestIfMediaTypes":
            suggest = "request_if_media_types"
        elif key == "requestJqProgram":
            suggest = "request_jq_program"
        elif key == "requestJqProgramOptions":
            suggest = "request_jq_program_options"
        elif key == "responseIfMediaTypes":
            suggest = "response_if_media_types"
        elif key == "responseIfStatusCodes":
            suggest = "response_if_status_codes"
        elif key == "responseJqProgram":
            suggest = "response_jq_program"
        elif key == "responseJqProgramOptions":
            suggest = "response_jq_program_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginJqConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginJqConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginJqConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_if_media_types: Optional[Sequence[str]] = None,
                 request_jq_program: Optional[str] = None,
                 request_jq_program_options: Optional['outputs.GatewayPluginJqConfigRequestJqProgramOptions'] = None,
                 response_if_media_types: Optional[Sequence[str]] = None,
                 response_if_status_codes: Optional[Sequence[int]] = None,
                 response_jq_program: Optional[str] = None,
                 response_jq_program_options: Optional['outputs.GatewayPluginJqConfigResponseJqProgramOptions'] = None):
        if request_if_media_types is not None:
            pulumi.set(__self__, "request_if_media_types", request_if_media_types)
        if request_jq_program is not None:
            pulumi.set(__self__, "request_jq_program", request_jq_program)
        if request_jq_program_options is not None:
            pulumi.set(__self__, "request_jq_program_options", request_jq_program_options)
        if response_if_media_types is not None:
            pulumi.set(__self__, "response_if_media_types", response_if_media_types)
        if response_if_status_codes is not None:
            pulumi.set(__self__, "response_if_status_codes", response_if_status_codes)
        if response_jq_program is not None:
            pulumi.set(__self__, "response_jq_program", response_jq_program)
        if response_jq_program_options is not None:
            pulumi.set(__self__, "response_jq_program_options", response_jq_program_options)

    @property
    @pulumi.getter(name="requestIfMediaTypes")
    def request_if_media_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "request_if_media_types")

    @property
    @pulumi.getter(name="requestJqProgram")
    def request_jq_program(self) -> Optional[str]:
        return pulumi.get(self, "request_jq_program")

    @property
    @pulumi.getter(name="requestJqProgramOptions")
    def request_jq_program_options(self) -> Optional['outputs.GatewayPluginJqConfigRequestJqProgramOptions']:
        return pulumi.get(self, "request_jq_program_options")

    @property
    @pulumi.getter(name="responseIfMediaTypes")
    def response_if_media_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "response_if_media_types")

    @property
    @pulumi.getter(name="responseIfStatusCodes")
    def response_if_status_codes(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "response_if_status_codes")

    @property
    @pulumi.getter(name="responseJqProgram")
    def response_jq_program(self) -> Optional[str]:
        return pulumi.get(self, "response_jq_program")

    @property
    @pulumi.getter(name="responseJqProgramOptions")
    def response_jq_program_options(self) -> Optional['outputs.GatewayPluginJqConfigResponseJqProgramOptions']:
        return pulumi.get(self, "response_jq_program_options")


@pulumi.output_type
class GatewayPluginJqConfigRequestJqProgramOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asciiOutput":
            suggest = "ascii_output"
        elif key == "compactOutput":
            suggest = "compact_output"
        elif key == "joinOutput":
            suggest = "join_output"
        elif key == "rawOutput":
            suggest = "raw_output"
        elif key == "sortKeys":
            suggest = "sort_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginJqConfigRequestJqProgramOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginJqConfigRequestJqProgramOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginJqConfigRequestJqProgramOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ascii_output: Optional[bool] = None,
                 compact_output: Optional[bool] = None,
                 join_output: Optional[bool] = None,
                 raw_output: Optional[bool] = None,
                 sort_keys: Optional[bool] = None):
        if ascii_output is not None:
            pulumi.set(__self__, "ascii_output", ascii_output)
        if compact_output is not None:
            pulumi.set(__self__, "compact_output", compact_output)
        if join_output is not None:
            pulumi.set(__self__, "join_output", join_output)
        if raw_output is not None:
            pulumi.set(__self__, "raw_output", raw_output)
        if sort_keys is not None:
            pulumi.set(__self__, "sort_keys", sort_keys)

    @property
    @pulumi.getter(name="asciiOutput")
    def ascii_output(self) -> Optional[bool]:
        return pulumi.get(self, "ascii_output")

    @property
    @pulumi.getter(name="compactOutput")
    def compact_output(self) -> Optional[bool]:
        return pulumi.get(self, "compact_output")

    @property
    @pulumi.getter(name="joinOutput")
    def join_output(self) -> Optional[bool]:
        return pulumi.get(self, "join_output")

    @property
    @pulumi.getter(name="rawOutput")
    def raw_output(self) -> Optional[bool]:
        return pulumi.get(self, "raw_output")

    @property
    @pulumi.getter(name="sortKeys")
    def sort_keys(self) -> Optional[bool]:
        return pulumi.get(self, "sort_keys")


@pulumi.output_type
class GatewayPluginJqConfigResponseJqProgramOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asciiOutput":
            suggest = "ascii_output"
        elif key == "compactOutput":
            suggest = "compact_output"
        elif key == "joinOutput":
            suggest = "join_output"
        elif key == "rawOutput":
            suggest = "raw_output"
        elif key == "sortKeys":
            suggest = "sort_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginJqConfigResponseJqProgramOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginJqConfigResponseJqProgramOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginJqConfigResponseJqProgramOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ascii_output: Optional[bool] = None,
                 compact_output: Optional[bool] = None,
                 join_output: Optional[bool] = None,
                 raw_output: Optional[bool] = None,
                 sort_keys: Optional[bool] = None):
        if ascii_output is not None:
            pulumi.set(__self__, "ascii_output", ascii_output)
        if compact_output is not None:
            pulumi.set(__self__, "compact_output", compact_output)
        if join_output is not None:
            pulumi.set(__self__, "join_output", join_output)
        if raw_output is not None:
            pulumi.set(__self__, "raw_output", raw_output)
        if sort_keys is not None:
            pulumi.set(__self__, "sort_keys", sort_keys)

    @property
    @pulumi.getter(name="asciiOutput")
    def ascii_output(self) -> Optional[bool]:
        return pulumi.get(self, "ascii_output")

    @property
    @pulumi.getter(name="compactOutput")
    def compact_output(self) -> Optional[bool]:
        return pulumi.get(self, "compact_output")

    @property
    @pulumi.getter(name="joinOutput")
    def join_output(self) -> Optional[bool]:
        return pulumi.get(self, "join_output")

    @property
    @pulumi.getter(name="rawOutput")
    def raw_output(self) -> Optional[bool]:
        return pulumi.get(self, "raw_output")

    @property
    @pulumi.getter(name="sortKeys")
    def sort_keys(self) -> Optional[bool]:
        return pulumi.get(self, "sort_keys")


@pulumi.output_type
class GatewayPluginJqConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJqConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJqRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJqService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimsToVerifies":
            suggest = "claims_to_verifies"
        elif key == "cookieNames":
            suggest = "cookie_names"
        elif key == "headerNames":
            suggest = "header_names"
        elif key == "keyClaimName":
            suggest = "key_claim_name"
        elif key == "maximumExpiration":
            suggest = "maximum_expiration"
        elif key == "runOnPreflight":
            suggest = "run_on_preflight"
        elif key == "secretIsBase64":
            suggest = "secret_is_base64"
        elif key == "uriParamNames":
            suggest = "uri_param_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginJwtConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginJwtConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginJwtConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous: Optional[str] = None,
                 claims_to_verifies: Optional[Sequence[str]] = None,
                 cookie_names: Optional[Sequence[str]] = None,
                 header_names: Optional[Sequence[str]] = None,
                 key_claim_name: Optional[str] = None,
                 maximum_expiration: Optional[float] = None,
                 run_on_preflight: Optional[bool] = None,
                 secret_is_base64: Optional[bool] = None,
                 uri_param_names: Optional[Sequence[str]] = None):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        :param Sequence[str] claims_to_verifies: A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
        :param Sequence[str] cookie_names: A list of cookie names that Kong will inspect to retrieve JWTs.
        :param Sequence[str] header_names: A list of HTTP header names that Kong will inspect to retrieve JWTs.
        :param str key_claim_name: The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
        :param float maximum_expiration: A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximum_expiration seconds in the future.
        :param bool run_on_preflight: A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
        :param bool secret_is_base64: If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
        :param Sequence[str] uri_param_names: A list of querystring parameters that Kong will inspect to retrieve JWTs.
        """
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if claims_to_verifies is not None:
            pulumi.set(__self__, "claims_to_verifies", claims_to_verifies)
        if cookie_names is not None:
            pulumi.set(__self__, "cookie_names", cookie_names)
        if header_names is not None:
            pulumi.set(__self__, "header_names", header_names)
        if key_claim_name is not None:
            pulumi.set(__self__, "key_claim_name", key_claim_name)
        if maximum_expiration is not None:
            pulumi.set(__self__, "maximum_expiration", maximum_expiration)
        if run_on_preflight is not None:
            pulumi.set(__self__, "run_on_preflight", run_on_preflight)
        if secret_is_base64 is not None:
            pulumi.set(__self__, "secret_is_base64", secret_is_base64)
        if uri_param_names is not None:
            pulumi.set(__self__, "uri_param_names", uri_param_names)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="claimsToVerifies")
    def claims_to_verifies(self) -> Optional[Sequence[str]]:
        """
        A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
        """
        return pulumi.get(self, "claims_to_verifies")

    @property
    @pulumi.getter(name="cookieNames")
    def cookie_names(self) -> Optional[Sequence[str]]:
        """
        A list of cookie names that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "cookie_names")

    @property
    @pulumi.getter(name="headerNames")
    def header_names(self) -> Optional[Sequence[str]]:
        """
        A list of HTTP header names that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "header_names")

    @property
    @pulumi.getter(name="keyClaimName")
    def key_claim_name(self) -> Optional[str]:
        """
        The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
        """
        return pulumi.get(self, "key_claim_name")

    @property
    @pulumi.getter(name="maximumExpiration")
    def maximum_expiration(self) -> Optional[float]:
        """
        A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximum_expiration seconds in the future.
        """
        return pulumi.get(self, "maximum_expiration")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> Optional[bool]:
        """
        A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
        """
        return pulumi.get(self, "run_on_preflight")

    @property
    @pulumi.getter(name="secretIsBase64")
    def secret_is_base64(self) -> Optional[bool]:
        """
        If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
        """
        return pulumi.get(self, "secret_is_base64")

    @property
    @pulumi.getter(name="uriParamNames")
    def uri_param_names(self) -> Optional[Sequence[str]]:
        """
        A list of querystring parameters that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "uri_param_names")


@pulumi.output_type
class GatewayPluginJwtConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtSignerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenConsumerBies":
            suggest = "access_token_consumer_bies"
        elif key == "accessTokenConsumerClaims":
            suggest = "access_token_consumer_claims"
        elif key == "accessTokenIntrospectionAuthorization":
            suggest = "access_token_introspection_authorization"
        elif key == "accessTokenIntrospectionBodyArgs":
            suggest = "access_token_introspection_body_args"
        elif key == "accessTokenIntrospectionConsumerBies":
            suggest = "access_token_introspection_consumer_bies"
        elif key == "accessTokenIntrospectionConsumerClaims":
            suggest = "access_token_introspection_consumer_claims"
        elif key == "accessTokenIntrospectionEndpoint":
            suggest = "access_token_introspection_endpoint"
        elif key == "accessTokenIntrospectionHint":
            suggest = "access_token_introspection_hint"
        elif key == "accessTokenIntrospectionJwtClaims":
            suggest = "access_token_introspection_jwt_claims"
        elif key == "accessTokenIntrospectionLeeway":
            suggest = "access_token_introspection_leeway"
        elif key == "accessTokenIntrospectionScopesClaims":
            suggest = "access_token_introspection_scopes_claims"
        elif key == "accessTokenIntrospectionScopesRequireds":
            suggest = "access_token_introspection_scopes_requireds"
        elif key == "accessTokenIntrospectionTimeout":
            suggest = "access_token_introspection_timeout"
        elif key == "accessTokenIssuer":
            suggest = "access_token_issuer"
        elif key == "accessTokenJwksUri":
            suggest = "access_token_jwks_uri"
        elif key == "accessTokenJwksUriClientCertificate":
            suggest = "access_token_jwks_uri_client_certificate"
        elif key == "accessTokenJwksUriClientPassword":
            suggest = "access_token_jwks_uri_client_password"
        elif key == "accessTokenJwksUriClientUsername":
            suggest = "access_token_jwks_uri_client_username"
        elif key == "accessTokenJwksUriRotatePeriod":
            suggest = "access_token_jwks_uri_rotate_period"
        elif key == "accessTokenKeyset":
            suggest = "access_token_keyset"
        elif key == "accessTokenKeysetClientCertificate":
            suggest = "access_token_keyset_client_certificate"
        elif key == "accessTokenKeysetClientPassword":
            suggest = "access_token_keyset_client_password"
        elif key == "accessTokenKeysetClientUsername":
            suggest = "access_token_keyset_client_username"
        elif key == "accessTokenKeysetRotatePeriod":
            suggest = "access_token_keyset_rotate_period"
        elif key == "accessTokenLeeway":
            suggest = "access_token_leeway"
        elif key == "accessTokenOptional":
            suggest = "access_token_optional"
        elif key == "accessTokenRequestHeader":
            suggest = "access_token_request_header"
        elif key == "accessTokenScopesClaims":
            suggest = "access_token_scopes_claims"
        elif key == "accessTokenScopesRequireds":
            suggest = "access_token_scopes_requireds"
        elif key == "accessTokenSigningAlgorithm":
            suggest = "access_token_signing_algorithm"
        elif key == "accessTokenUpstreamHeader":
            suggest = "access_token_upstream_header"
        elif key == "accessTokenUpstreamLeeway":
            suggest = "access_token_upstream_leeway"
        elif key == "addAccessTokenClaims":
            suggest = "add_access_token_claims"
        elif key == "addChannelTokenClaims":
            suggest = "add_channel_token_claims"
        elif key == "addClaims":
            suggest = "add_claims"
        elif key == "cacheAccessTokenIntrospection":
            suggest = "cache_access_token_introspection"
        elif key == "cacheChannelTokenIntrospection":
            suggest = "cache_channel_token_introspection"
        elif key == "channelTokenConsumerBies":
            suggest = "channel_token_consumer_bies"
        elif key == "channelTokenConsumerClaims":
            suggest = "channel_token_consumer_claims"
        elif key == "channelTokenIntrospectionAuthorization":
            suggest = "channel_token_introspection_authorization"
        elif key == "channelTokenIntrospectionBodyArgs":
            suggest = "channel_token_introspection_body_args"
        elif key == "channelTokenIntrospectionConsumerBies":
            suggest = "channel_token_introspection_consumer_bies"
        elif key == "channelTokenIntrospectionConsumerClaims":
            suggest = "channel_token_introspection_consumer_claims"
        elif key == "channelTokenIntrospectionEndpoint":
            suggest = "channel_token_introspection_endpoint"
        elif key == "channelTokenIntrospectionHint":
            suggest = "channel_token_introspection_hint"
        elif key == "channelTokenIntrospectionJwtClaims":
            suggest = "channel_token_introspection_jwt_claims"
        elif key == "channelTokenIntrospectionLeeway":
            suggest = "channel_token_introspection_leeway"
        elif key == "channelTokenIntrospectionScopesClaims":
            suggest = "channel_token_introspection_scopes_claims"
        elif key == "channelTokenIntrospectionScopesRequireds":
            suggest = "channel_token_introspection_scopes_requireds"
        elif key == "channelTokenIntrospectionTimeout":
            suggest = "channel_token_introspection_timeout"
        elif key == "channelTokenIssuer":
            suggest = "channel_token_issuer"
        elif key == "channelTokenJwksUri":
            suggest = "channel_token_jwks_uri"
        elif key == "channelTokenJwksUriClientCertificate":
            suggest = "channel_token_jwks_uri_client_certificate"
        elif key == "channelTokenJwksUriClientPassword":
            suggest = "channel_token_jwks_uri_client_password"
        elif key == "channelTokenJwksUriClientUsername":
            suggest = "channel_token_jwks_uri_client_username"
        elif key == "channelTokenJwksUriRotatePeriod":
            suggest = "channel_token_jwks_uri_rotate_period"
        elif key == "channelTokenKeyset":
            suggest = "channel_token_keyset"
        elif key == "channelTokenKeysetClientCertificate":
            suggest = "channel_token_keyset_client_certificate"
        elif key == "channelTokenKeysetClientPassword":
            suggest = "channel_token_keyset_client_password"
        elif key == "channelTokenKeysetClientUsername":
            suggest = "channel_token_keyset_client_username"
        elif key == "channelTokenKeysetRotatePeriod":
            suggest = "channel_token_keyset_rotate_period"
        elif key == "channelTokenLeeway":
            suggest = "channel_token_leeway"
        elif key == "channelTokenOptional":
            suggest = "channel_token_optional"
        elif key == "channelTokenRequestHeader":
            suggest = "channel_token_request_header"
        elif key == "channelTokenScopesClaims":
            suggest = "channel_token_scopes_claims"
        elif key == "channelTokenScopesRequireds":
            suggest = "channel_token_scopes_requireds"
        elif key == "channelTokenSigningAlgorithm":
            suggest = "channel_token_signing_algorithm"
        elif key == "channelTokenUpstreamHeader":
            suggest = "channel_token_upstream_header"
        elif key == "channelTokenUpstreamLeeway":
            suggest = "channel_token_upstream_leeway"
        elif key == "enableAccessTokenIntrospection":
            suggest = "enable_access_token_introspection"
        elif key == "enableChannelTokenIntrospection":
            suggest = "enable_channel_token_introspection"
        elif key == "enableHsSignatures":
            suggest = "enable_hs_signatures"
        elif key == "enableInstrumentation":
            suggest = "enable_instrumentation"
        elif key == "originalAccessTokenUpstreamHeader":
            suggest = "original_access_token_upstream_header"
        elif key == "originalChannelTokenUpstreamHeader":
            suggest = "original_channel_token_upstream_header"
        elif key == "removeAccessTokenClaims":
            suggest = "remove_access_token_claims"
        elif key == "removeChannelTokenClaims":
            suggest = "remove_channel_token_claims"
        elif key == "setAccessTokenClaims":
            suggest = "set_access_token_claims"
        elif key == "setChannelTokenClaims":
            suggest = "set_channel_token_claims"
        elif key == "setClaims":
            suggest = "set_claims"
        elif key == "trustAccessTokenIntrospection":
            suggest = "trust_access_token_introspection"
        elif key == "trustChannelTokenIntrospection":
            suggest = "trust_channel_token_introspection"
        elif key == "verifyAccessTokenExpiry":
            suggest = "verify_access_token_expiry"
        elif key == "verifyAccessTokenIntrospectionExpiry":
            suggest = "verify_access_token_introspection_expiry"
        elif key == "verifyAccessTokenIntrospectionScopes":
            suggest = "verify_access_token_introspection_scopes"
        elif key == "verifyAccessTokenScopes":
            suggest = "verify_access_token_scopes"
        elif key == "verifyAccessTokenSignature":
            suggest = "verify_access_token_signature"
        elif key == "verifyChannelTokenExpiry":
            suggest = "verify_channel_token_expiry"
        elif key == "verifyChannelTokenIntrospectionExpiry":
            suggest = "verify_channel_token_introspection_expiry"
        elif key == "verifyChannelTokenIntrospectionScopes":
            suggest = "verify_channel_token_introspection_scopes"
        elif key == "verifyChannelTokenScopes":
            suggest = "verify_channel_token_scopes"
        elif key == "verifyChannelTokenSignature":
            suggest = "verify_channel_token_signature"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginJwtSignerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginJwtSignerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginJwtSignerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_consumer_bies: Optional[Sequence[str]] = None,
                 access_token_consumer_claims: Optional[Sequence[str]] = None,
                 access_token_introspection_authorization: Optional[str] = None,
                 access_token_introspection_body_args: Optional[str] = None,
                 access_token_introspection_consumer_bies: Optional[Sequence[str]] = None,
                 access_token_introspection_consumer_claims: Optional[Sequence[str]] = None,
                 access_token_introspection_endpoint: Optional[str] = None,
                 access_token_introspection_hint: Optional[str] = None,
                 access_token_introspection_jwt_claims: Optional[Sequence[str]] = None,
                 access_token_introspection_leeway: Optional[float] = None,
                 access_token_introspection_scopes_claims: Optional[Sequence[str]] = None,
                 access_token_introspection_scopes_requireds: Optional[Sequence[str]] = None,
                 access_token_introspection_timeout: Optional[float] = None,
                 access_token_issuer: Optional[str] = None,
                 access_token_jwks_uri: Optional[str] = None,
                 access_token_jwks_uri_client_certificate: Optional[str] = None,
                 access_token_jwks_uri_client_password: Optional[str] = None,
                 access_token_jwks_uri_client_username: Optional[str] = None,
                 access_token_jwks_uri_rotate_period: Optional[float] = None,
                 access_token_keyset: Optional[str] = None,
                 access_token_keyset_client_certificate: Optional[str] = None,
                 access_token_keyset_client_password: Optional[str] = None,
                 access_token_keyset_client_username: Optional[str] = None,
                 access_token_keyset_rotate_period: Optional[float] = None,
                 access_token_leeway: Optional[float] = None,
                 access_token_optional: Optional[bool] = None,
                 access_token_request_header: Optional[str] = None,
                 access_token_scopes_claims: Optional[Sequence[str]] = None,
                 access_token_scopes_requireds: Optional[Sequence[str]] = None,
                 access_token_signing_algorithm: Optional[str] = None,
                 access_token_upstream_header: Optional[str] = None,
                 access_token_upstream_leeway: Optional[float] = None,
                 add_access_token_claims: Optional[Mapping[str, str]] = None,
                 add_channel_token_claims: Optional[Mapping[str, str]] = None,
                 add_claims: Optional[Mapping[str, str]] = None,
                 cache_access_token_introspection: Optional[bool] = None,
                 cache_channel_token_introspection: Optional[bool] = None,
                 channel_token_consumer_bies: Optional[Sequence[str]] = None,
                 channel_token_consumer_claims: Optional[Sequence[str]] = None,
                 channel_token_introspection_authorization: Optional[str] = None,
                 channel_token_introspection_body_args: Optional[str] = None,
                 channel_token_introspection_consumer_bies: Optional[Sequence[str]] = None,
                 channel_token_introspection_consumer_claims: Optional[Sequence[str]] = None,
                 channel_token_introspection_endpoint: Optional[str] = None,
                 channel_token_introspection_hint: Optional[str] = None,
                 channel_token_introspection_jwt_claims: Optional[Sequence[str]] = None,
                 channel_token_introspection_leeway: Optional[float] = None,
                 channel_token_introspection_scopes_claims: Optional[Sequence[str]] = None,
                 channel_token_introspection_scopes_requireds: Optional[Sequence[str]] = None,
                 channel_token_introspection_timeout: Optional[float] = None,
                 channel_token_issuer: Optional[str] = None,
                 channel_token_jwks_uri: Optional[str] = None,
                 channel_token_jwks_uri_client_certificate: Optional[str] = None,
                 channel_token_jwks_uri_client_password: Optional[str] = None,
                 channel_token_jwks_uri_client_username: Optional[str] = None,
                 channel_token_jwks_uri_rotate_period: Optional[float] = None,
                 channel_token_keyset: Optional[str] = None,
                 channel_token_keyset_client_certificate: Optional[str] = None,
                 channel_token_keyset_client_password: Optional[str] = None,
                 channel_token_keyset_client_username: Optional[str] = None,
                 channel_token_keyset_rotate_period: Optional[float] = None,
                 channel_token_leeway: Optional[float] = None,
                 channel_token_optional: Optional[bool] = None,
                 channel_token_request_header: Optional[str] = None,
                 channel_token_scopes_claims: Optional[Sequence[str]] = None,
                 channel_token_scopes_requireds: Optional[Sequence[str]] = None,
                 channel_token_signing_algorithm: Optional[str] = None,
                 channel_token_upstream_header: Optional[str] = None,
                 channel_token_upstream_leeway: Optional[float] = None,
                 enable_access_token_introspection: Optional[bool] = None,
                 enable_channel_token_introspection: Optional[bool] = None,
                 enable_hs_signatures: Optional[bool] = None,
                 enable_instrumentation: Optional[bool] = None,
                 original_access_token_upstream_header: Optional[str] = None,
                 original_channel_token_upstream_header: Optional[str] = None,
                 realm: Optional[str] = None,
                 remove_access_token_claims: Optional[Sequence[str]] = None,
                 remove_channel_token_claims: Optional[Sequence[str]] = None,
                 set_access_token_claims: Optional[Mapping[str, str]] = None,
                 set_channel_token_claims: Optional[Mapping[str, str]] = None,
                 set_claims: Optional[Mapping[str, str]] = None,
                 trust_access_token_introspection: Optional[bool] = None,
                 trust_channel_token_introspection: Optional[bool] = None,
                 verify_access_token_expiry: Optional[bool] = None,
                 verify_access_token_introspection_expiry: Optional[bool] = None,
                 verify_access_token_introspection_scopes: Optional[bool] = None,
                 verify_access_token_scopes: Optional[bool] = None,
                 verify_access_token_signature: Optional[bool] = None,
                 verify_channel_token_expiry: Optional[bool] = None,
                 verify_channel_token_introspection_expiry: Optional[bool] = None,
                 verify_channel_token_introspection_scopes: Optional[bool] = None,
                 verify_channel_token_scopes: Optional[bool] = None,
                 verify_channel_token_signature: Optional[bool] = None):
        """
        :param Sequence[str] access_token_consumer_bies: When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `custom_id`.
        :param Sequence[str] access_token_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
        :param str access_token_introspection_authorization: If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
        :param str access_token_introspection_body_args: This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
        :param Sequence[str] access_token_introspection_consumer_bies: When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
        :param Sequence[str] access_token_introspection_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
        :param str access_token_introspection_endpoint: When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
        :param str access_token_introspection_hint: If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
        :param Sequence[str] access_token_introspection_jwt_claims: If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
        :param float access_token_introspection_leeway: Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
        :param Sequence[str] access_token_introspection_scopes_claims: Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realm_access", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
        :param Sequence[str] access_token_introspection_scopes_requireds: Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
        :param float access_token_introspection_timeout: Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
        :param str access_token_issuer: The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `original_iss` claim of the newly signed access token.
        :param str access_token_jwks_uri: Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
        :param str access_token_jwks_uri_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        :param str access_token_jwks_uri_client_password: The client password that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_username`
        :param str access_token_jwks_uri_client_username: The client username that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_password`
        :param float access_token_jwks_uri_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `access_token_jwks_uri`. The default value 0 means no auto-rotation.
        :param str access_token_keyset: The name of the keyset containing signing keys.
        :param str access_token_keyset_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_keyset` is an https uri that requires mTLS Auth.
        :param str access_token_keyset_client_password: The client password that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_username`
        :param str access_token_keyset_client_username: The client username that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_password`
        :param float access_token_keyset_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `access_token_keyset`. The default value 0 means no auto-rotation.
        :param float access_token_leeway: Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
        :param bool access_token_optional: If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
        :param str access_token_request_header: This parameter tells the name of the header where to look for the access token.
        :param Sequence[str] access_token_scopes_claims: Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
        :param Sequence[str] access_token_scopes_requireds: Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
        :param str access_token_signing_algorithm: When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        :param str access_token_upstream_header: Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
        :param float access_token_upstream_leeway: If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
        :param Mapping[str, str] add_access_token_claims: Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] add_channel_token_claims: Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] add_claims: Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param bool cache_access_token_introspection: Whether to cache access token introspection results.
        :param bool cache_channel_token_introspection: Whether to cache channel token introspection results.
        :param Sequence[str] channel_token_consumer_bies: When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `custom_id`.
        :param Sequence[str] channel_token_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `custom_id`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
        :param str channel_token_introspection_authorization: When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
        :param str channel_token_introspection_body_args: If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
        :param Sequence[str] channel_token_introspection_consumer_bies: When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `custom_id`.
        :param Sequence[str] channel_token_introspection_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
        :param str channel_token_introspection_endpoint: When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
        :param str channel_token_introspection_hint: If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
        :param Sequence[str] channel_token_introspection_jwt_claims: If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
        :param float channel_token_introspection_leeway: You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
        :param Sequence[str] channel_token_introspection_scopes_claims: Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
        :param Sequence[str] channel_token_introspection_scopes_requireds: Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
        :param float channel_token_introspection_timeout: Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
        :param str channel_token_issuer: The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `original_iss` claim of the newly signed channel token.
        :param str channel_token_jwks_uri: If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
        :param str channel_token_jwks_uri_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        :param str channel_token_jwks_uri_client_password: The client password that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_username`
        :param str channel_token_jwks_uri_client_username: The client username that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_password`
        :param float channel_token_jwks_uri_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `channel_token_jwks_uri`. The default value 0 means no auto-rotation.
        :param str channel_token_keyset: The name of the keyset containing signing keys.
        :param str channel_token_keyset_client_certificate: The client certificate that will be used to authenticate Kong if `channel_token_keyset` is an https uri that requires mTLS Auth.
        :param str channel_token_keyset_client_password: The client password that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_username`
        :param str channel_token_keyset_client_username: The client username that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_password`
        :param float channel_token_keyset_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `channel_token_keyset`. The default value 0 means no auto-rotation.
        :param float channel_token_leeway: Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
        :param bool channel_token_optional: If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
        :param str channel_token_request_header: This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
        :param Sequence[str] channel_token_scopes_claims: Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
        :param Sequence[str] channel_token_scopes_requireds: Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
        :param str channel_token_signing_algorithm: When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        :param str channel_token_upstream_header: This plugin removes the `config.channel_token_request_header` from the request after reading its value.
        :param float channel_token_upstream_leeway: If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
        :param bool enable_access_token_introspection: If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
        :param bool enable_channel_token_introspection: If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
        :param bool enable_hs_signatures: Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
        :param bool enable_instrumentation: Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
        :param str original_access_token_upstream_header: The HTTP header name used to store the original access token.
        :param str original_channel_token_upstream_header: The HTTP header name used to store the original channel token.
        :param str realm: When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
        :param Sequence[str] remove_access_token_claims: remove claims. It should be an array, and each element is a claim key string.
        :param Sequence[str] remove_channel_token_claims: remove claims. It should be an array, and each element is a claim key string.
        :param Mapping[str, str] set_access_token_claims: Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] set_channel_token_claims: Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] set_claims: Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param bool trust_access_token_introspection: Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
        :param bool trust_channel_token_introspection: Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel*token*introspection*jwt*claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
        :param bool verify_access_token_expiry: Quickly turn access token expiry verification off and on as needed.
        :param bool verify_access_token_introspection_expiry: Quickly turn access token introspection expiry verification off and on as needed.
        :param bool verify_access_token_introspection_scopes: Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
        :param bool verify_access_token_scopes: Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
        :param bool verify_access_token_signature: Quickly turn access token signature verification off and on as needed.
        :param bool verify_channel_token_introspection_expiry: Quickly turn on/off the channel token introspection expiry verification.
        :param bool verify_channel_token_introspection_scopes: Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
        :param bool verify_channel_token_scopes: Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
        :param bool verify_channel_token_signature: Quickly turn on/off the channel token signature verification.
        """
        if access_token_consumer_bies is not None:
            pulumi.set(__self__, "access_token_consumer_bies", access_token_consumer_bies)
        if access_token_consumer_claims is not None:
            pulumi.set(__self__, "access_token_consumer_claims", access_token_consumer_claims)
        if access_token_introspection_authorization is not None:
            pulumi.set(__self__, "access_token_introspection_authorization", access_token_introspection_authorization)
        if access_token_introspection_body_args is not None:
            pulumi.set(__self__, "access_token_introspection_body_args", access_token_introspection_body_args)
        if access_token_introspection_consumer_bies is not None:
            pulumi.set(__self__, "access_token_introspection_consumer_bies", access_token_introspection_consumer_bies)
        if access_token_introspection_consumer_claims is not None:
            pulumi.set(__self__, "access_token_introspection_consumer_claims", access_token_introspection_consumer_claims)
        if access_token_introspection_endpoint is not None:
            pulumi.set(__self__, "access_token_introspection_endpoint", access_token_introspection_endpoint)
        if access_token_introspection_hint is not None:
            pulumi.set(__self__, "access_token_introspection_hint", access_token_introspection_hint)
        if access_token_introspection_jwt_claims is not None:
            pulumi.set(__self__, "access_token_introspection_jwt_claims", access_token_introspection_jwt_claims)
        if access_token_introspection_leeway is not None:
            pulumi.set(__self__, "access_token_introspection_leeway", access_token_introspection_leeway)
        if access_token_introspection_scopes_claims is not None:
            pulumi.set(__self__, "access_token_introspection_scopes_claims", access_token_introspection_scopes_claims)
        if access_token_introspection_scopes_requireds is not None:
            pulumi.set(__self__, "access_token_introspection_scopes_requireds", access_token_introspection_scopes_requireds)
        if access_token_introspection_timeout is not None:
            pulumi.set(__self__, "access_token_introspection_timeout", access_token_introspection_timeout)
        if access_token_issuer is not None:
            pulumi.set(__self__, "access_token_issuer", access_token_issuer)
        if access_token_jwks_uri is not None:
            pulumi.set(__self__, "access_token_jwks_uri", access_token_jwks_uri)
        if access_token_jwks_uri_client_certificate is not None:
            pulumi.set(__self__, "access_token_jwks_uri_client_certificate", access_token_jwks_uri_client_certificate)
        if access_token_jwks_uri_client_password is not None:
            pulumi.set(__self__, "access_token_jwks_uri_client_password", access_token_jwks_uri_client_password)
        if access_token_jwks_uri_client_username is not None:
            pulumi.set(__self__, "access_token_jwks_uri_client_username", access_token_jwks_uri_client_username)
        if access_token_jwks_uri_rotate_period is not None:
            pulumi.set(__self__, "access_token_jwks_uri_rotate_period", access_token_jwks_uri_rotate_period)
        if access_token_keyset is not None:
            pulumi.set(__self__, "access_token_keyset", access_token_keyset)
        if access_token_keyset_client_certificate is not None:
            pulumi.set(__self__, "access_token_keyset_client_certificate", access_token_keyset_client_certificate)
        if access_token_keyset_client_password is not None:
            pulumi.set(__self__, "access_token_keyset_client_password", access_token_keyset_client_password)
        if access_token_keyset_client_username is not None:
            pulumi.set(__self__, "access_token_keyset_client_username", access_token_keyset_client_username)
        if access_token_keyset_rotate_period is not None:
            pulumi.set(__self__, "access_token_keyset_rotate_period", access_token_keyset_rotate_period)
        if access_token_leeway is not None:
            pulumi.set(__self__, "access_token_leeway", access_token_leeway)
        if access_token_optional is not None:
            pulumi.set(__self__, "access_token_optional", access_token_optional)
        if access_token_request_header is not None:
            pulumi.set(__self__, "access_token_request_header", access_token_request_header)
        if access_token_scopes_claims is not None:
            pulumi.set(__self__, "access_token_scopes_claims", access_token_scopes_claims)
        if access_token_scopes_requireds is not None:
            pulumi.set(__self__, "access_token_scopes_requireds", access_token_scopes_requireds)
        if access_token_signing_algorithm is not None:
            pulumi.set(__self__, "access_token_signing_algorithm", access_token_signing_algorithm)
        if access_token_upstream_header is not None:
            pulumi.set(__self__, "access_token_upstream_header", access_token_upstream_header)
        if access_token_upstream_leeway is not None:
            pulumi.set(__self__, "access_token_upstream_leeway", access_token_upstream_leeway)
        if add_access_token_claims is not None:
            pulumi.set(__self__, "add_access_token_claims", add_access_token_claims)
        if add_channel_token_claims is not None:
            pulumi.set(__self__, "add_channel_token_claims", add_channel_token_claims)
        if add_claims is not None:
            pulumi.set(__self__, "add_claims", add_claims)
        if cache_access_token_introspection is not None:
            pulumi.set(__self__, "cache_access_token_introspection", cache_access_token_introspection)
        if cache_channel_token_introspection is not None:
            pulumi.set(__self__, "cache_channel_token_introspection", cache_channel_token_introspection)
        if channel_token_consumer_bies is not None:
            pulumi.set(__self__, "channel_token_consumer_bies", channel_token_consumer_bies)
        if channel_token_consumer_claims is not None:
            pulumi.set(__self__, "channel_token_consumer_claims", channel_token_consumer_claims)
        if channel_token_introspection_authorization is not None:
            pulumi.set(__self__, "channel_token_introspection_authorization", channel_token_introspection_authorization)
        if channel_token_introspection_body_args is not None:
            pulumi.set(__self__, "channel_token_introspection_body_args", channel_token_introspection_body_args)
        if channel_token_introspection_consumer_bies is not None:
            pulumi.set(__self__, "channel_token_introspection_consumer_bies", channel_token_introspection_consumer_bies)
        if channel_token_introspection_consumer_claims is not None:
            pulumi.set(__self__, "channel_token_introspection_consumer_claims", channel_token_introspection_consumer_claims)
        if channel_token_introspection_endpoint is not None:
            pulumi.set(__self__, "channel_token_introspection_endpoint", channel_token_introspection_endpoint)
        if channel_token_introspection_hint is not None:
            pulumi.set(__self__, "channel_token_introspection_hint", channel_token_introspection_hint)
        if channel_token_introspection_jwt_claims is not None:
            pulumi.set(__self__, "channel_token_introspection_jwt_claims", channel_token_introspection_jwt_claims)
        if channel_token_introspection_leeway is not None:
            pulumi.set(__self__, "channel_token_introspection_leeway", channel_token_introspection_leeway)
        if channel_token_introspection_scopes_claims is not None:
            pulumi.set(__self__, "channel_token_introspection_scopes_claims", channel_token_introspection_scopes_claims)
        if channel_token_introspection_scopes_requireds is not None:
            pulumi.set(__self__, "channel_token_introspection_scopes_requireds", channel_token_introspection_scopes_requireds)
        if channel_token_introspection_timeout is not None:
            pulumi.set(__self__, "channel_token_introspection_timeout", channel_token_introspection_timeout)
        if channel_token_issuer is not None:
            pulumi.set(__self__, "channel_token_issuer", channel_token_issuer)
        if channel_token_jwks_uri is not None:
            pulumi.set(__self__, "channel_token_jwks_uri", channel_token_jwks_uri)
        if channel_token_jwks_uri_client_certificate is not None:
            pulumi.set(__self__, "channel_token_jwks_uri_client_certificate", channel_token_jwks_uri_client_certificate)
        if channel_token_jwks_uri_client_password is not None:
            pulumi.set(__self__, "channel_token_jwks_uri_client_password", channel_token_jwks_uri_client_password)
        if channel_token_jwks_uri_client_username is not None:
            pulumi.set(__self__, "channel_token_jwks_uri_client_username", channel_token_jwks_uri_client_username)
        if channel_token_jwks_uri_rotate_period is not None:
            pulumi.set(__self__, "channel_token_jwks_uri_rotate_period", channel_token_jwks_uri_rotate_period)
        if channel_token_keyset is not None:
            pulumi.set(__self__, "channel_token_keyset", channel_token_keyset)
        if channel_token_keyset_client_certificate is not None:
            pulumi.set(__self__, "channel_token_keyset_client_certificate", channel_token_keyset_client_certificate)
        if channel_token_keyset_client_password is not None:
            pulumi.set(__self__, "channel_token_keyset_client_password", channel_token_keyset_client_password)
        if channel_token_keyset_client_username is not None:
            pulumi.set(__self__, "channel_token_keyset_client_username", channel_token_keyset_client_username)
        if channel_token_keyset_rotate_period is not None:
            pulumi.set(__self__, "channel_token_keyset_rotate_period", channel_token_keyset_rotate_period)
        if channel_token_leeway is not None:
            pulumi.set(__self__, "channel_token_leeway", channel_token_leeway)
        if channel_token_optional is not None:
            pulumi.set(__self__, "channel_token_optional", channel_token_optional)
        if channel_token_request_header is not None:
            pulumi.set(__self__, "channel_token_request_header", channel_token_request_header)
        if channel_token_scopes_claims is not None:
            pulumi.set(__self__, "channel_token_scopes_claims", channel_token_scopes_claims)
        if channel_token_scopes_requireds is not None:
            pulumi.set(__self__, "channel_token_scopes_requireds", channel_token_scopes_requireds)
        if channel_token_signing_algorithm is not None:
            pulumi.set(__self__, "channel_token_signing_algorithm", channel_token_signing_algorithm)
        if channel_token_upstream_header is not None:
            pulumi.set(__self__, "channel_token_upstream_header", channel_token_upstream_header)
        if channel_token_upstream_leeway is not None:
            pulumi.set(__self__, "channel_token_upstream_leeway", channel_token_upstream_leeway)
        if enable_access_token_introspection is not None:
            pulumi.set(__self__, "enable_access_token_introspection", enable_access_token_introspection)
        if enable_channel_token_introspection is not None:
            pulumi.set(__self__, "enable_channel_token_introspection", enable_channel_token_introspection)
        if enable_hs_signatures is not None:
            pulumi.set(__self__, "enable_hs_signatures", enable_hs_signatures)
        if enable_instrumentation is not None:
            pulumi.set(__self__, "enable_instrumentation", enable_instrumentation)
        if original_access_token_upstream_header is not None:
            pulumi.set(__self__, "original_access_token_upstream_header", original_access_token_upstream_header)
        if original_channel_token_upstream_header is not None:
            pulumi.set(__self__, "original_channel_token_upstream_header", original_channel_token_upstream_header)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if remove_access_token_claims is not None:
            pulumi.set(__self__, "remove_access_token_claims", remove_access_token_claims)
        if remove_channel_token_claims is not None:
            pulumi.set(__self__, "remove_channel_token_claims", remove_channel_token_claims)
        if set_access_token_claims is not None:
            pulumi.set(__self__, "set_access_token_claims", set_access_token_claims)
        if set_channel_token_claims is not None:
            pulumi.set(__self__, "set_channel_token_claims", set_channel_token_claims)
        if set_claims is not None:
            pulumi.set(__self__, "set_claims", set_claims)
        if trust_access_token_introspection is not None:
            pulumi.set(__self__, "trust_access_token_introspection", trust_access_token_introspection)
        if trust_channel_token_introspection is not None:
            pulumi.set(__self__, "trust_channel_token_introspection", trust_channel_token_introspection)
        if verify_access_token_expiry is not None:
            pulumi.set(__self__, "verify_access_token_expiry", verify_access_token_expiry)
        if verify_access_token_introspection_expiry is not None:
            pulumi.set(__self__, "verify_access_token_introspection_expiry", verify_access_token_introspection_expiry)
        if verify_access_token_introspection_scopes is not None:
            pulumi.set(__self__, "verify_access_token_introspection_scopes", verify_access_token_introspection_scopes)
        if verify_access_token_scopes is not None:
            pulumi.set(__self__, "verify_access_token_scopes", verify_access_token_scopes)
        if verify_access_token_signature is not None:
            pulumi.set(__self__, "verify_access_token_signature", verify_access_token_signature)
        if verify_channel_token_expiry is not None:
            pulumi.set(__self__, "verify_channel_token_expiry", verify_channel_token_expiry)
        if verify_channel_token_introspection_expiry is not None:
            pulumi.set(__self__, "verify_channel_token_introspection_expiry", verify_channel_token_introspection_expiry)
        if verify_channel_token_introspection_scopes is not None:
            pulumi.set(__self__, "verify_channel_token_introspection_scopes", verify_channel_token_introspection_scopes)
        if verify_channel_token_scopes is not None:
            pulumi.set(__self__, "verify_channel_token_scopes", verify_channel_token_scopes)
        if verify_channel_token_signature is not None:
            pulumi.set(__self__, "verify_channel_token_signature", verify_channel_token_signature)

    @property
    @pulumi.getter(name="accessTokenConsumerBies")
    def access_token_consumer_bies(self) -> Optional[Sequence[str]]:
        """
        When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `custom_id`.
        """
        return pulumi.get(self, "access_token_consumer_bies")

    @property
    @pulumi.getter(name="accessTokenConsumerClaims")
    def access_token_consumer_claims(self) -> Optional[Sequence[str]]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
        """
        return pulumi.get(self, "access_token_consumer_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionAuthorization")
    def access_token_introspection_authorization(self) -> Optional[str]:
        """
        If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
        """
        return pulumi.get(self, "access_token_introspection_authorization")

    @property
    @pulumi.getter(name="accessTokenIntrospectionBodyArgs")
    def access_token_introspection_body_args(self) -> Optional[str]:
        """
        This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
        """
        return pulumi.get(self, "access_token_introspection_body_args")

    @property
    @pulumi.getter(name="accessTokenIntrospectionConsumerBies")
    def access_token_introspection_consumer_bies(self) -> Optional[Sequence[str]]:
        """
        When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
        """
        return pulumi.get(self, "access_token_introspection_consumer_bies")

    @property
    @pulumi.getter(name="accessTokenIntrospectionConsumerClaims")
    def access_token_introspection_consumer_claims(self) -> Optional[Sequence[str]]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
        """
        return pulumi.get(self, "access_token_introspection_consumer_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionEndpoint")
    def access_token_introspection_endpoint(self) -> Optional[str]:
        """
        When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
        """
        return pulumi.get(self, "access_token_introspection_endpoint")

    @property
    @pulumi.getter(name="accessTokenIntrospectionHint")
    def access_token_introspection_hint(self) -> Optional[str]:
        """
        If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
        """
        return pulumi.get(self, "access_token_introspection_hint")

    @property
    @pulumi.getter(name="accessTokenIntrospectionJwtClaims")
    def access_token_introspection_jwt_claims(self) -> Optional[Sequence[str]]:
        """
        If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
        """
        return pulumi.get(self, "access_token_introspection_jwt_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionLeeway")
    def access_token_introspection_leeway(self) -> Optional[float]:
        """
        Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
        """
        return pulumi.get(self, "access_token_introspection_leeway")

    @property
    @pulumi.getter(name="accessTokenIntrospectionScopesClaims")
    def access_token_introspection_scopes_claims(self) -> Optional[Sequence[str]]:
        """
        Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realm_access", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
        """
        return pulumi.get(self, "access_token_introspection_scopes_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionScopesRequireds")
    def access_token_introspection_scopes_requireds(self) -> Optional[Sequence[str]]:
        """
        Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
        """
        return pulumi.get(self, "access_token_introspection_scopes_requireds")

    @property
    @pulumi.getter(name="accessTokenIntrospectionTimeout")
    def access_token_introspection_timeout(self) -> Optional[float]:
        """
        Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
        """
        return pulumi.get(self, "access_token_introspection_timeout")

    @property
    @pulumi.getter(name="accessTokenIssuer")
    def access_token_issuer(self) -> Optional[str]:
        """
        The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `original_iss` claim of the newly signed access token.
        """
        return pulumi.get(self, "access_token_issuer")

    @property
    @pulumi.getter(name="accessTokenJwksUri")
    def access_token_jwks_uri(self) -> Optional[str]:
        """
        Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
        """
        return pulumi.get(self, "access_token_jwks_uri")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientCertificate")
    def access_token_jwks_uri_client_certificate(self) -> Optional[str]:
        """
        The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "access_token_jwks_uri_client_certificate")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientPassword")
    def access_token_jwks_uri_client_password(self) -> Optional[str]:
        """
        The client password that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_username`
        """
        return pulumi.get(self, "access_token_jwks_uri_client_password")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientUsername")
    def access_token_jwks_uri_client_username(self) -> Optional[str]:
        """
        The client username that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_password`
        """
        return pulumi.get(self, "access_token_jwks_uri_client_username")

    @property
    @pulumi.getter(name="accessTokenJwksUriRotatePeriod")
    def access_token_jwks_uri_rotate_period(self) -> Optional[float]:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `access_token_jwks_uri`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "access_token_jwks_uri_rotate_period")

    @property
    @pulumi.getter(name="accessTokenKeyset")
    def access_token_keyset(self) -> Optional[str]:
        """
        The name of the keyset containing signing keys.
        """
        return pulumi.get(self, "access_token_keyset")

    @property
    @pulumi.getter(name="accessTokenKeysetClientCertificate")
    def access_token_keyset_client_certificate(self) -> Optional[str]:
        """
        The client certificate that will be used to authenticate Kong if `access_token_keyset` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "access_token_keyset_client_certificate")

    @property
    @pulumi.getter(name="accessTokenKeysetClientPassword")
    def access_token_keyset_client_password(self) -> Optional[str]:
        """
        The client password that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_username`
        """
        return pulumi.get(self, "access_token_keyset_client_password")

    @property
    @pulumi.getter(name="accessTokenKeysetClientUsername")
    def access_token_keyset_client_username(self) -> Optional[str]:
        """
        The client username that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_password`
        """
        return pulumi.get(self, "access_token_keyset_client_username")

    @property
    @pulumi.getter(name="accessTokenKeysetRotatePeriod")
    def access_token_keyset_rotate_period(self) -> Optional[float]:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `access_token_keyset`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "access_token_keyset_rotate_period")

    @property
    @pulumi.getter(name="accessTokenLeeway")
    def access_token_leeway(self) -> Optional[float]:
        """
        Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
        """
        return pulumi.get(self, "access_token_leeway")

    @property
    @pulumi.getter(name="accessTokenOptional")
    def access_token_optional(self) -> Optional[bool]:
        """
        If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
        """
        return pulumi.get(self, "access_token_optional")

    @property
    @pulumi.getter(name="accessTokenRequestHeader")
    def access_token_request_header(self) -> Optional[str]:
        """
        This parameter tells the name of the header where to look for the access token.
        """
        return pulumi.get(self, "access_token_request_header")

    @property
    @pulumi.getter(name="accessTokenScopesClaims")
    def access_token_scopes_claims(self) -> Optional[Sequence[str]]:
        """
        Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
        """
        return pulumi.get(self, "access_token_scopes_claims")

    @property
    @pulumi.getter(name="accessTokenScopesRequireds")
    def access_token_scopes_requireds(self) -> Optional[Sequence[str]]:
        """
        Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
        """
        return pulumi.get(self, "access_token_scopes_requireds")

    @property
    @pulumi.getter(name="accessTokenSigningAlgorithm")
    def access_token_signing_algorithm(self) -> Optional[str]:
        """
        When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        """
        return pulumi.get(self, "access_token_signing_algorithm")

    @property
    @pulumi.getter(name="accessTokenUpstreamHeader")
    def access_token_upstream_header(self) -> Optional[str]:
        """
        Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
        """
        return pulumi.get(self, "access_token_upstream_header")

    @property
    @pulumi.getter(name="accessTokenUpstreamLeeway")
    def access_token_upstream_leeway(self) -> Optional[float]:
        """
        If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
        """
        return pulumi.get(self, "access_token_upstream_leeway")

    @property
    @pulumi.getter(name="addAccessTokenClaims")
    def add_access_token_claims(self) -> Optional[Mapping[str, str]]:
        """
        Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_access_token_claims")

    @property
    @pulumi.getter(name="addChannelTokenClaims")
    def add_channel_token_claims(self) -> Optional[Mapping[str, str]]:
        """
        Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_channel_token_claims")

    @property
    @pulumi.getter(name="addClaims")
    def add_claims(self) -> Optional[Mapping[str, str]]:
        """
        Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_claims")

    @property
    @pulumi.getter(name="cacheAccessTokenIntrospection")
    def cache_access_token_introspection(self) -> Optional[bool]:
        """
        Whether to cache access token introspection results.
        """
        return pulumi.get(self, "cache_access_token_introspection")

    @property
    @pulumi.getter(name="cacheChannelTokenIntrospection")
    def cache_channel_token_introspection(self) -> Optional[bool]:
        """
        Whether to cache channel token introspection results.
        """
        return pulumi.get(self, "cache_channel_token_introspection")

    @property
    @pulumi.getter(name="channelTokenConsumerBies")
    def channel_token_consumer_bies(self) -> Optional[Sequence[str]]:
        """
        When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `custom_id`.
        """
        return pulumi.get(self, "channel_token_consumer_bies")

    @property
    @pulumi.getter(name="channelTokenConsumerClaims")
    def channel_token_consumer_claims(self) -> Optional[Sequence[str]]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `custom_id`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
        """
        return pulumi.get(self, "channel_token_consumer_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionAuthorization")
    def channel_token_introspection_authorization(self) -> Optional[str]:
        """
        When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
        """
        return pulumi.get(self, "channel_token_introspection_authorization")

    @property
    @pulumi.getter(name="channelTokenIntrospectionBodyArgs")
    def channel_token_introspection_body_args(self) -> Optional[str]:
        """
        If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
        """
        return pulumi.get(self, "channel_token_introspection_body_args")

    @property
    @pulumi.getter(name="channelTokenIntrospectionConsumerBies")
    def channel_token_introspection_consumer_bies(self) -> Optional[Sequence[str]]:
        """
        When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `custom_id`.
        """
        return pulumi.get(self, "channel_token_introspection_consumer_bies")

    @property
    @pulumi.getter(name="channelTokenIntrospectionConsumerClaims")
    def channel_token_introspection_consumer_claims(self) -> Optional[Sequence[str]]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
        """
        return pulumi.get(self, "channel_token_introspection_consumer_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionEndpoint")
    def channel_token_introspection_endpoint(self) -> Optional[str]:
        """
        When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
        """
        return pulumi.get(self, "channel_token_introspection_endpoint")

    @property
    @pulumi.getter(name="channelTokenIntrospectionHint")
    def channel_token_introspection_hint(self) -> Optional[str]:
        """
        If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
        """
        return pulumi.get(self, "channel_token_introspection_hint")

    @property
    @pulumi.getter(name="channelTokenIntrospectionJwtClaims")
    def channel_token_introspection_jwt_claims(self) -> Optional[Sequence[str]]:
        """
        If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
        """
        return pulumi.get(self, "channel_token_introspection_jwt_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionLeeway")
    def channel_token_introspection_leeway(self) -> Optional[float]:
        """
        You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
        """
        return pulumi.get(self, "channel_token_introspection_leeway")

    @property
    @pulumi.getter(name="channelTokenIntrospectionScopesClaims")
    def channel_token_introspection_scopes_claims(self) -> Optional[Sequence[str]]:
        """
        Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
        """
        return pulumi.get(self, "channel_token_introspection_scopes_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionScopesRequireds")
    def channel_token_introspection_scopes_requireds(self) -> Optional[Sequence[str]]:
        """
        Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
        """
        return pulumi.get(self, "channel_token_introspection_scopes_requireds")

    @property
    @pulumi.getter(name="channelTokenIntrospectionTimeout")
    def channel_token_introspection_timeout(self) -> Optional[float]:
        """
        Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
        """
        return pulumi.get(self, "channel_token_introspection_timeout")

    @property
    @pulumi.getter(name="channelTokenIssuer")
    def channel_token_issuer(self) -> Optional[str]:
        """
        The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `original_iss` claim of the newly signed channel token.
        """
        return pulumi.get(self, "channel_token_issuer")

    @property
    @pulumi.getter(name="channelTokenJwksUri")
    def channel_token_jwks_uri(self) -> Optional[str]:
        """
        If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
        """
        return pulumi.get(self, "channel_token_jwks_uri")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientCertificate")
    def channel_token_jwks_uri_client_certificate(self) -> Optional[str]:
        """
        The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_certificate")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientPassword")
    def channel_token_jwks_uri_client_password(self) -> Optional[str]:
        """
        The client password that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_username`
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_password")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientUsername")
    def channel_token_jwks_uri_client_username(self) -> Optional[str]:
        """
        The client username that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_password`
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_username")

    @property
    @pulumi.getter(name="channelTokenJwksUriRotatePeriod")
    def channel_token_jwks_uri_rotate_period(self) -> Optional[float]:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `channel_token_jwks_uri`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "channel_token_jwks_uri_rotate_period")

    @property
    @pulumi.getter(name="channelTokenKeyset")
    def channel_token_keyset(self) -> Optional[str]:
        """
        The name of the keyset containing signing keys.
        """
        return pulumi.get(self, "channel_token_keyset")

    @property
    @pulumi.getter(name="channelTokenKeysetClientCertificate")
    def channel_token_keyset_client_certificate(self) -> Optional[str]:
        """
        The client certificate that will be used to authenticate Kong if `channel_token_keyset` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "channel_token_keyset_client_certificate")

    @property
    @pulumi.getter(name="channelTokenKeysetClientPassword")
    def channel_token_keyset_client_password(self) -> Optional[str]:
        """
        The client password that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_username`
        """
        return pulumi.get(self, "channel_token_keyset_client_password")

    @property
    @pulumi.getter(name="channelTokenKeysetClientUsername")
    def channel_token_keyset_client_username(self) -> Optional[str]:
        """
        The client username that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_password`
        """
        return pulumi.get(self, "channel_token_keyset_client_username")

    @property
    @pulumi.getter(name="channelTokenKeysetRotatePeriod")
    def channel_token_keyset_rotate_period(self) -> Optional[float]:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `channel_token_keyset`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "channel_token_keyset_rotate_period")

    @property
    @pulumi.getter(name="channelTokenLeeway")
    def channel_token_leeway(self) -> Optional[float]:
        """
        Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
        """
        return pulumi.get(self, "channel_token_leeway")

    @property
    @pulumi.getter(name="channelTokenOptional")
    def channel_token_optional(self) -> Optional[bool]:
        """
        If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
        """
        return pulumi.get(self, "channel_token_optional")

    @property
    @pulumi.getter(name="channelTokenRequestHeader")
    def channel_token_request_header(self) -> Optional[str]:
        """
        This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
        """
        return pulumi.get(self, "channel_token_request_header")

    @property
    @pulumi.getter(name="channelTokenScopesClaims")
    def channel_token_scopes_claims(self) -> Optional[Sequence[str]]:
        """
        Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
        """
        return pulumi.get(self, "channel_token_scopes_claims")

    @property
    @pulumi.getter(name="channelTokenScopesRequireds")
    def channel_token_scopes_requireds(self) -> Optional[Sequence[str]]:
        """
        Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
        """
        return pulumi.get(self, "channel_token_scopes_requireds")

    @property
    @pulumi.getter(name="channelTokenSigningAlgorithm")
    def channel_token_signing_algorithm(self) -> Optional[str]:
        """
        When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        """
        return pulumi.get(self, "channel_token_signing_algorithm")

    @property
    @pulumi.getter(name="channelTokenUpstreamHeader")
    def channel_token_upstream_header(self) -> Optional[str]:
        """
        This plugin removes the `config.channel_token_request_header` from the request after reading its value.
        """
        return pulumi.get(self, "channel_token_upstream_header")

    @property
    @pulumi.getter(name="channelTokenUpstreamLeeway")
    def channel_token_upstream_leeway(self) -> Optional[float]:
        """
        If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
        """
        return pulumi.get(self, "channel_token_upstream_leeway")

    @property
    @pulumi.getter(name="enableAccessTokenIntrospection")
    def enable_access_token_introspection(self) -> Optional[bool]:
        """
        If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
        """
        return pulumi.get(self, "enable_access_token_introspection")

    @property
    @pulumi.getter(name="enableChannelTokenIntrospection")
    def enable_channel_token_introspection(self) -> Optional[bool]:
        """
        If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
        """
        return pulumi.get(self, "enable_channel_token_introspection")

    @property
    @pulumi.getter(name="enableHsSignatures")
    def enable_hs_signatures(self) -> Optional[bool]:
        """
        Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
        """
        return pulumi.get(self, "enable_hs_signatures")

    @property
    @pulumi.getter(name="enableInstrumentation")
    def enable_instrumentation(self) -> Optional[bool]:
        """
        Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
        """
        return pulumi.get(self, "enable_instrumentation")

    @property
    @pulumi.getter(name="originalAccessTokenUpstreamHeader")
    def original_access_token_upstream_header(self) -> Optional[str]:
        """
        The HTTP header name used to store the original access token.
        """
        return pulumi.get(self, "original_access_token_upstream_header")

    @property
    @pulumi.getter(name="originalChannelTokenUpstreamHeader")
    def original_channel_token_upstream_header(self) -> Optional[str]:
        """
        The HTTP header name used to store the original channel token.
        """
        return pulumi.get(self, "original_channel_token_upstream_header")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="removeAccessTokenClaims")
    def remove_access_token_claims(self) -> Optional[Sequence[str]]:
        """
        remove claims. It should be an array, and each element is a claim key string.
        """
        return pulumi.get(self, "remove_access_token_claims")

    @property
    @pulumi.getter(name="removeChannelTokenClaims")
    def remove_channel_token_claims(self) -> Optional[Sequence[str]]:
        """
        remove claims. It should be an array, and each element is a claim key string.
        """
        return pulumi.get(self, "remove_channel_token_claims")

    @property
    @pulumi.getter(name="setAccessTokenClaims")
    def set_access_token_claims(self) -> Optional[Mapping[str, str]]:
        """
        Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_access_token_claims")

    @property
    @pulumi.getter(name="setChannelTokenClaims")
    def set_channel_token_claims(self) -> Optional[Mapping[str, str]]:
        """
        Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_channel_token_claims")

    @property
    @pulumi.getter(name="setClaims")
    def set_claims(self) -> Optional[Mapping[str, str]]:
        """
        Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_claims")

    @property
    @pulumi.getter(name="trustAccessTokenIntrospection")
    def trust_access_token_introspection(self) -> Optional[bool]:
        """
        Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
        """
        return pulumi.get(self, "trust_access_token_introspection")

    @property
    @pulumi.getter(name="trustChannelTokenIntrospection")
    def trust_channel_token_introspection(self) -> Optional[bool]:
        """
        Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel*token*introspection*jwt*claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
        """
        return pulumi.get(self, "trust_channel_token_introspection")

    @property
    @pulumi.getter(name="verifyAccessTokenExpiry")
    def verify_access_token_expiry(self) -> Optional[bool]:
        """
        Quickly turn access token expiry verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_expiry")

    @property
    @pulumi.getter(name="verifyAccessTokenIntrospectionExpiry")
    def verify_access_token_introspection_expiry(self) -> Optional[bool]:
        """
        Quickly turn access token introspection expiry verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_introspection_expiry")

    @property
    @pulumi.getter(name="verifyAccessTokenIntrospectionScopes")
    def verify_access_token_introspection_scopes(self) -> Optional[bool]:
        """
        Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
        """
        return pulumi.get(self, "verify_access_token_introspection_scopes")

    @property
    @pulumi.getter(name="verifyAccessTokenScopes")
    def verify_access_token_scopes(self) -> Optional[bool]:
        """
        Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
        """
        return pulumi.get(self, "verify_access_token_scopes")

    @property
    @pulumi.getter(name="verifyAccessTokenSignature")
    def verify_access_token_signature(self) -> Optional[bool]:
        """
        Quickly turn access token signature verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_signature")

    @property
    @pulumi.getter(name="verifyChannelTokenExpiry")
    def verify_channel_token_expiry(self) -> Optional[bool]:
        return pulumi.get(self, "verify_channel_token_expiry")

    @property
    @pulumi.getter(name="verifyChannelTokenIntrospectionExpiry")
    def verify_channel_token_introspection_expiry(self) -> Optional[bool]:
        """
        Quickly turn on/off the channel token introspection expiry verification.
        """
        return pulumi.get(self, "verify_channel_token_introspection_expiry")

    @property
    @pulumi.getter(name="verifyChannelTokenIntrospectionScopes")
    def verify_channel_token_introspection_scopes(self) -> Optional[bool]:
        """
        Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
        """
        return pulumi.get(self, "verify_channel_token_introspection_scopes")

    @property
    @pulumi.getter(name="verifyChannelTokenScopes")
    def verify_channel_token_scopes(self) -> Optional[bool]:
        """
        Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
        """
        return pulumi.get(self, "verify_channel_token_scopes")

    @property
    @pulumi.getter(name="verifyChannelTokenSignature")
    def verify_channel_token_signature(self) -> Optional[bool]:
        """
        Quickly turn on/off the channel token signature verification.
        """
        return pulumi.get(self, "verify_channel_token_signature")


@pulumi.output_type
class GatewayPluginJwtSignerConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtSignerConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtSignerRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginJwtSignerService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginKeyAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hideCredentials":
            suggest = "hide_credentials"
        elif key == "keyInBody":
            suggest = "key_in_body"
        elif key == "keyInHeader":
            suggest = "key_in_header"
        elif key == "keyInQuery":
            suggest = "key_in_query"
        elif key == "keyNames":
            suggest = "key_names"
        elif key == "runOnPreflight":
            suggest = "run_on_preflight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginKeyAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginKeyAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginKeyAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous: Optional[str] = None,
                 hide_credentials: Optional[bool] = None,
                 key_in_body: Optional[bool] = None,
                 key_in_header: Optional[bool] = None,
                 key_in_query: Optional[bool] = None,
                 key_names: Optional[Sequence[str]] = None,
                 realm: Optional[str] = None,
                 run_on_preflight: Optional[bool] = None):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
        :param bool key_in_body: If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
        :param bool key_in_header: If enabled (default), the plugin reads the request header and tries to find the key in it.
        :param bool key_in_query: If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
        :param Sequence[str] key_names: Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
        :param str realm: When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        :param bool run_on_preflight: A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
        """
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if hide_credentials is not None:
            pulumi.set(__self__, "hide_credentials", hide_credentials)
        if key_in_body is not None:
            pulumi.set(__self__, "key_in_body", key_in_body)
        if key_in_header is not None:
            pulumi.set(__self__, "key_in_header", key_in_header)
        if key_in_query is not None:
            pulumi.set(__self__, "key_in_query", key_in_query)
        if key_names is not None:
            pulumi.set(__self__, "key_names", key_names)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if run_on_preflight is not None:
            pulumi.set(__self__, "run_on_preflight", run_on_preflight)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> Optional[bool]:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="keyInBody")
    def key_in_body(self) -> Optional[bool]:
        """
        If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
        """
        return pulumi.get(self, "key_in_body")

    @property
    @pulumi.getter(name="keyInHeader")
    def key_in_header(self) -> Optional[bool]:
        """
        If enabled (default), the plugin reads the request header and tries to find the key in it.
        """
        return pulumi.get(self, "key_in_header")

    @property
    @pulumi.getter(name="keyInQuery")
    def key_in_query(self) -> Optional[bool]:
        """
        If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
        """
        return pulumi.get(self, "key_in_query")

    @property
    @pulumi.getter(name="keyNames")
    def key_names(self) -> Optional[Sequence[str]]:
        """
        Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
        """
        return pulumi.get(self, "key_names")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> Optional[bool]:
        """
        A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
        """
        return pulumi.get(self, "run_on_preflight")


@pulumi.output_type
class GatewayPluginKeyAuthConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginKeyAuthConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginKeyAuthRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginKeyAuthService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOauth2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptHttpIfAlreadyTerminated":
            suggest = "accept_http_if_already_terminated"
        elif key == "authHeaderName":
            suggest = "auth_header_name"
        elif key == "enableAuthorizationCode":
            suggest = "enable_authorization_code"
        elif key == "enableClientCredentials":
            suggest = "enable_client_credentials"
        elif key == "enableImplicitGrant":
            suggest = "enable_implicit_grant"
        elif key == "enablePasswordGrant":
            suggest = "enable_password_grant"
        elif key == "globalCredentials":
            suggest = "global_credentials"
        elif key == "hideCredentials":
            suggest = "hide_credentials"
        elif key == "mandatoryScope":
            suggest = "mandatory_scope"
        elif key == "persistentRefreshToken":
            suggest = "persistent_refresh_token"
        elif key == "provisionKey":
            suggest = "provision_key"
        elif key == "refreshTokenTtl":
            suggest = "refresh_token_ttl"
        elif key == "reuseRefreshToken":
            suggest = "reuse_refresh_token"
        elif key == "tokenExpiration":
            suggest = "token_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOauth2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOauth2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOauth2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_http_if_already_terminated: Optional[bool] = None,
                 anonymous: Optional[str] = None,
                 auth_header_name: Optional[str] = None,
                 enable_authorization_code: Optional[bool] = None,
                 enable_client_credentials: Optional[bool] = None,
                 enable_implicit_grant: Optional[bool] = None,
                 enable_password_grant: Optional[bool] = None,
                 global_credentials: Optional[bool] = None,
                 hide_credentials: Optional[bool] = None,
                 mandatory_scope: Optional[bool] = None,
                 persistent_refresh_token: Optional[bool] = None,
                 pkce: Optional[str] = None,
                 provision_key: Optional[str] = None,
                 refresh_token_ttl: Optional[float] = None,
                 reuse_refresh_token: Optional[bool] = None,
                 scopes: Optional[Sequence[str]] = None,
                 token_expiration: Optional[float] = None):
        """
        :param bool accept_http_if_already_terminated: Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        :param str auth_header_name: The name of the header that is supposed to carry the access token.
        :param bool enable_authorization_code: An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
        :param bool enable_client_credentials: An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
        :param bool enable_implicit_grant: An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
        :param bool enable_password_grant: An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
        :param bool global_credentials: An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service.
        :param bool mandatory_scope: An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
        :param str pkce: Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
        :param str provision_key: The unique key the plugin has generated when it has been added to the Service.
        :param float refresh_token_ttl: Time-to-live value for data
        :param bool reuse_refresh_token: An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
        :param Sequence[str] scopes: Describes an array of scope names that will be available to the end user. If `mandatory_scope` is set to `true`, then `scopes` are required.
        :param float token_expiration: An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
        """
        if accept_http_if_already_terminated is not None:
            pulumi.set(__self__, "accept_http_if_already_terminated", accept_http_if_already_terminated)
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if auth_header_name is not None:
            pulumi.set(__self__, "auth_header_name", auth_header_name)
        if enable_authorization_code is not None:
            pulumi.set(__self__, "enable_authorization_code", enable_authorization_code)
        if enable_client_credentials is not None:
            pulumi.set(__self__, "enable_client_credentials", enable_client_credentials)
        if enable_implicit_grant is not None:
            pulumi.set(__self__, "enable_implicit_grant", enable_implicit_grant)
        if enable_password_grant is not None:
            pulumi.set(__self__, "enable_password_grant", enable_password_grant)
        if global_credentials is not None:
            pulumi.set(__self__, "global_credentials", global_credentials)
        if hide_credentials is not None:
            pulumi.set(__self__, "hide_credentials", hide_credentials)
        if mandatory_scope is not None:
            pulumi.set(__self__, "mandatory_scope", mandatory_scope)
        if persistent_refresh_token is not None:
            pulumi.set(__self__, "persistent_refresh_token", persistent_refresh_token)
        if pkce is not None:
            pulumi.set(__self__, "pkce", pkce)
        if provision_key is not None:
            pulumi.set(__self__, "provision_key", provision_key)
        if refresh_token_ttl is not None:
            pulumi.set(__self__, "refresh_token_ttl", refresh_token_ttl)
        if reuse_refresh_token is not None:
            pulumi.set(__self__, "reuse_refresh_token", reuse_refresh_token)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_expiration is not None:
            pulumi.set(__self__, "token_expiration", token_expiration)

    @property
    @pulumi.getter(name="acceptHttpIfAlreadyTerminated")
    def accept_http_if_already_terminated(self) -> Optional[bool]:
        """
        Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
        """
        return pulumi.get(self, "accept_http_if_already_terminated")

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="authHeaderName")
    def auth_header_name(self) -> Optional[str]:
        """
        The name of the header that is supposed to carry the access token.
        """
        return pulumi.get(self, "auth_header_name")

    @property
    @pulumi.getter(name="enableAuthorizationCode")
    def enable_authorization_code(self) -> Optional[bool]:
        """
        An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
        """
        return pulumi.get(self, "enable_authorization_code")

    @property
    @pulumi.getter(name="enableClientCredentials")
    def enable_client_credentials(self) -> Optional[bool]:
        """
        An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
        """
        return pulumi.get(self, "enable_client_credentials")

    @property
    @pulumi.getter(name="enableImplicitGrant")
    def enable_implicit_grant(self) -> Optional[bool]:
        """
        An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
        """
        return pulumi.get(self, "enable_implicit_grant")

    @property
    @pulumi.getter(name="enablePasswordGrant")
    def enable_password_grant(self) -> Optional[bool]:
        """
        An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
        """
        return pulumi.get(self, "enable_password_grant")

    @property
    @pulumi.getter(name="globalCredentials")
    def global_credentials(self) -> Optional[bool]:
        """
        An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
        """
        return pulumi.get(self, "global_credentials")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> Optional[bool]:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="mandatoryScope")
    def mandatory_scope(self) -> Optional[bool]:
        """
        An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
        """
        return pulumi.get(self, "mandatory_scope")

    @property
    @pulumi.getter(name="persistentRefreshToken")
    def persistent_refresh_token(self) -> Optional[bool]:
        return pulumi.get(self, "persistent_refresh_token")

    @property
    @pulumi.getter
    def pkce(self) -> Optional[str]:
        """
        Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
        """
        return pulumi.get(self, "pkce")

    @property
    @pulumi.getter(name="provisionKey")
    def provision_key(self) -> Optional[str]:
        """
        The unique key the plugin has generated when it has been added to the Service.
        """
        return pulumi.get(self, "provision_key")

    @property
    @pulumi.getter(name="refreshTokenTtl")
    def refresh_token_ttl(self) -> Optional[float]:
        """
        Time-to-live value for data
        """
        return pulumi.get(self, "refresh_token_ttl")

    @property
    @pulumi.getter(name="reuseRefreshToken")
    def reuse_refresh_token(self) -> Optional[bool]:
        """
        An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
        """
        return pulumi.get(self, "reuse_refresh_token")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        Describes an array of scope names that will be available to the end user. If `mandatory_scope` is set to `true`, then `scopes` are required.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenExpiration")
    def token_expiration(self) -> Optional[float]:
        """
        An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
        """
        return pulumi.get(self, "token_expiration")


@pulumi.output_type
class GatewayPluginOauth2Consumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOauth2ConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOauth2Route(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOauth2Service(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpenidConnectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audienceClaims":
            suggest = "audience_claims"
        elif key == "audienceRequireds":
            suggest = "audience_requireds"
        elif key == "authMethods":
            suggest = "auth_methods"
        elif key == "authenticatedGroupsClaims":
            suggest = "authenticated_groups_claims"
        elif key == "authorizationCookieDomain":
            suggest = "authorization_cookie_domain"
        elif key == "authorizationCookieHttpOnly":
            suggest = "authorization_cookie_http_only"
        elif key == "authorizationCookieName":
            suggest = "authorization_cookie_name"
        elif key == "authorizationCookiePath":
            suggest = "authorization_cookie_path"
        elif key == "authorizationCookieSameSite":
            suggest = "authorization_cookie_same_site"
        elif key == "authorizationCookieSecure":
            suggest = "authorization_cookie_secure"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "authorizationQueryArgsClients":
            suggest = "authorization_query_args_clients"
        elif key == "authorizationQueryArgsNames":
            suggest = "authorization_query_args_names"
        elif key == "authorizationQueryArgsValues":
            suggest = "authorization_query_args_values"
        elif key == "authorizationRollingTimeout":
            suggest = "authorization_rolling_timeout"
        elif key == "bearerTokenCookieName":
            suggest = "bearer_token_cookie_name"
        elif key == "bearerTokenParamTypes":
            suggest = "bearer_token_param_types"
        elif key == "byUsernameIgnoreCase":
            suggest = "by_username_ignore_case"
        elif key == "cacheIntrospection":
            suggest = "cache_introspection"
        elif key == "cacheTokenExchange":
            suggest = "cache_token_exchange"
        elif key == "cacheTokens":
            suggest = "cache_tokens"
        elif key == "cacheTokensSalt":
            suggest = "cache_tokens_salt"
        elif key == "cacheTtl":
            suggest = "cache_ttl"
        elif key == "cacheTtlMax":
            suggest = "cache_ttl_max"
        elif key == "cacheTtlMin":
            suggest = "cache_ttl_min"
        elif key == "cacheTtlNeg":
            suggest = "cache_ttl_neg"
        elif key == "cacheTtlResurrect":
            suggest = "cache_ttl_resurrect"
        elif key == "cacheUserInfo":
            suggest = "cache_user_info"
        elif key == "clientAlgs":
            suggest = "client_algs"
        elif key == "clientArg":
            suggest = "client_arg"
        elif key == "clientAuths":
            suggest = "client_auths"
        elif key == "clientCredentialsParamTypes":
            suggest = "client_credentials_param_types"
        elif key == "clientIds":
            suggest = "client_ids"
        elif key == "clientJwks":
            suggest = "client_jwks"
        elif key == "clientSecrets":
            suggest = "client_secrets"
        elif key == "consumerBies":
            suggest = "consumer_bies"
        elif key == "consumerClaims":
            suggest = "consumer_claims"
        elif key == "consumerOptional":
            suggest = "consumer_optional"
        elif key == "credentialClaims":
            suggest = "credential_claims"
        elif key == "disableSessions":
            suggest = "disable_sessions"
        elif key == "discoveryHeadersNames":
            suggest = "discovery_headers_names"
        elif key == "discoveryHeadersValues":
            suggest = "discovery_headers_values"
        elif key == "displayErrors":
            suggest = "display_errors"
        elif key == "downstreamAccessTokenHeader":
            suggest = "downstream_access_token_header"
        elif key == "downstreamAccessTokenJwkHeader":
            suggest = "downstream_access_token_jwk_header"
        elif key == "downstreamHeadersClaims":
            suggest = "downstream_headers_claims"
        elif key == "downstreamHeadersNames":
            suggest = "downstream_headers_names"
        elif key == "downstreamIdTokenHeader":
            suggest = "downstream_id_token_header"
        elif key == "downstreamIdTokenJwkHeader":
            suggest = "downstream_id_token_jwk_header"
        elif key == "downstreamIntrospectionHeader":
            suggest = "downstream_introspection_header"
        elif key == "downstreamIntrospectionJwtHeader":
            suggest = "downstream_introspection_jwt_header"
        elif key == "downstreamRefreshTokenHeader":
            suggest = "downstream_refresh_token_header"
        elif key == "downstreamSessionIdHeader":
            suggest = "downstream_session_id_header"
        elif key == "downstreamUserInfoHeader":
            suggest = "downstream_user_info_header"
        elif key == "downstreamUserInfoJwtHeader":
            suggest = "downstream_user_info_jwt_header"
        elif key == "dpopProofLifetime":
            suggest = "dpop_proof_lifetime"
        elif key == "dpopUseNonce":
            suggest = "dpop_use_nonce"
        elif key == "enableHsSignatures":
            suggest = "enable_hs_signatures"
        elif key == "endSessionEndpoint":
            suggest = "end_session_endpoint"
        elif key == "exposeErrorCode":
            suggest = "expose_error_code"
        elif key == "extraJwksUris":
            suggest = "extra_jwks_uris"
        elif key == "forbiddenDestroySession":
            suggest = "forbidden_destroy_session"
        elif key == "forbiddenErrorMessage":
            suggest = "forbidden_error_message"
        elif key == "forbiddenRedirectUris":
            suggest = "forbidden_redirect_uris"
        elif key == "groupsClaims":
            suggest = "groups_claims"
        elif key == "groupsRequireds":
            suggest = "groups_requireds"
        elif key == "hideCredentials":
            suggest = "hide_credentials"
        elif key == "httpProxy":
            suggest = "http_proxy"
        elif key == "httpProxyAuthorization":
            suggest = "http_proxy_authorization"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "httpsProxy":
            suggest = "https_proxy"
        elif key == "httpsProxyAuthorization":
            suggest = "https_proxy_authorization"
        elif key == "idTokenParamName":
            suggest = "id_token_param_name"
        elif key == "idTokenParamTypes":
            suggest = "id_token_param_types"
        elif key == "ignoreSignatures":
            suggest = "ignore_signatures"
        elif key == "introspectJwtTokens":
            suggest = "introspect_jwt_tokens"
        elif key == "introspectionAccept":
            suggest = "introspection_accept"
        elif key == "introspectionCheckActive":
            suggest = "introspection_check_active"
        elif key == "introspectionEndpoint":
            suggest = "introspection_endpoint"
        elif key == "introspectionEndpointAuthMethod":
            suggest = "introspection_endpoint_auth_method"
        elif key == "introspectionHeadersClients":
            suggest = "introspection_headers_clients"
        elif key == "introspectionHeadersNames":
            suggest = "introspection_headers_names"
        elif key == "introspectionHeadersValues":
            suggest = "introspection_headers_values"
        elif key == "introspectionHint":
            suggest = "introspection_hint"
        elif key == "introspectionPostArgsClients":
            suggest = "introspection_post_args_clients"
        elif key == "introspectionPostArgsNames":
            suggest = "introspection_post_args_names"
        elif key == "introspectionPostArgsValues":
            suggest = "introspection_post_args_values"
        elif key == "introspectionTokenParamName":
            suggest = "introspection_token_param_name"
        elif key == "issuersAlloweds":
            suggest = "issuers_alloweds"
        elif key == "jwtSessionClaim":
            suggest = "jwt_session_claim"
        elif key == "jwtSessionCookie":
            suggest = "jwt_session_cookie"
        elif key == "loginAction":
            suggest = "login_action"
        elif key == "loginMethods":
            suggest = "login_methods"
        elif key == "loginRedirectMode":
            suggest = "login_redirect_mode"
        elif key == "loginRedirectUris":
            suggest = "login_redirect_uris"
        elif key == "loginTokens":
            suggest = "login_tokens"
        elif key == "logoutMethods":
            suggest = "logout_methods"
        elif key == "logoutPostArg":
            suggest = "logout_post_arg"
        elif key == "logoutQueryArg":
            suggest = "logout_query_arg"
        elif key == "logoutRedirectUris":
            suggest = "logout_redirect_uris"
        elif key == "logoutRevoke":
            suggest = "logout_revoke"
        elif key == "logoutRevokeAccessToken":
            suggest = "logout_revoke_access_token"
        elif key == "logoutRevokeRefreshToken":
            suggest = "logout_revoke_refresh_token"
        elif key == "logoutUriSuffix":
            suggest = "logout_uri_suffix"
        elif key == "maxAge":
            suggest = "max_age"
        elif key == "mtlsIntrospectionEndpoint":
            suggest = "mtls_introspection_endpoint"
        elif key == "mtlsRevocationEndpoint":
            suggest = "mtls_revocation_endpoint"
        elif key == "mtlsTokenEndpoint":
            suggest = "mtls_token_endpoint"
        elif key == "noProxy":
            suggest = "no_proxy"
        elif key == "passwordParamTypes":
            suggest = "password_param_types"
        elif key == "preserveQueryArgs":
            suggest = "preserve_query_args"
        elif key == "proofOfPossessionAuthMethodsValidation":
            suggest = "proof_of_possession_auth_methods_validation"
        elif key == "proofOfPossessionDpop":
            suggest = "proof_of_possession_dpop"
        elif key == "proofOfPossessionMtls":
            suggest = "proof_of_possession_mtls"
        elif key == "pushedAuthorizationRequestEndpoint":
            suggest = "pushed_authorization_request_endpoint"
        elif key == "pushedAuthorizationRequestEndpointAuthMethod":
            suggest = "pushed_authorization_request_endpoint_auth_method"
        elif key == "redirectUris":
            suggest = "redirect_uris"
        elif key == "rediscoveryLifetime":
            suggest = "rediscovery_lifetime"
        elif key == "refreshTokenParamName":
            suggest = "refresh_token_param_name"
        elif key == "refreshTokenParamTypes":
            suggest = "refresh_token_param_types"
        elif key == "refreshTokens":
            suggest = "refresh_tokens"
        elif key == "requireProofKeyForCodeExchange":
            suggest = "require_proof_key_for_code_exchange"
        elif key == "requirePushedAuthorizationRequests":
            suggest = "require_pushed_authorization_requests"
        elif key == "requireSignedRequestObject":
            suggest = "require_signed_request_object"
        elif key == "resolveDistributedClaims":
            suggest = "resolve_distributed_claims"
        elif key == "responseMode":
            suggest = "response_mode"
        elif key == "responseTypes":
            suggest = "response_types"
        elif key == "revocationEndpoint":
            suggest = "revocation_endpoint"
        elif key == "revocationEndpointAuthMethod":
            suggest = "revocation_endpoint_auth_method"
        elif key == "revocationTokenParamName":
            suggest = "revocation_token_param_name"
        elif key == "rolesClaims":
            suggest = "roles_claims"
        elif key == "rolesRequireds":
            suggest = "roles_requireds"
        elif key == "runOnPreflight":
            suggest = "run_on_preflight"
        elif key == "scopesClaims":
            suggest = "scopes_claims"
        elif key == "scopesRequireds":
            suggest = "scopes_requireds"
        elif key == "searchUserInfo":
            suggest = "search_user_info"
        elif key == "sessionAbsoluteTimeout":
            suggest = "session_absolute_timeout"
        elif key == "sessionAudience":
            suggest = "session_audience"
        elif key == "sessionCookieDomain":
            suggest = "session_cookie_domain"
        elif key == "sessionCookieHttpOnly":
            suggest = "session_cookie_http_only"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionCookiePath":
            suggest = "session_cookie_path"
        elif key == "sessionCookieSameSite":
            suggest = "session_cookie_same_site"
        elif key == "sessionCookieSecure":
            suggest = "session_cookie_secure"
        elif key == "sessionEnforceSameSubject":
            suggest = "session_enforce_same_subject"
        elif key == "sessionHashStorageKey":
            suggest = "session_hash_storage_key"
        elif key == "sessionHashSubject":
            suggest = "session_hash_subject"
        elif key == "sessionIdlingTimeout":
            suggest = "session_idling_timeout"
        elif key == "sessionMemcachedHost":
            suggest = "session_memcached_host"
        elif key == "sessionMemcachedPort":
            suggest = "session_memcached_port"
        elif key == "sessionMemcachedPrefix":
            suggest = "session_memcached_prefix"
        elif key == "sessionMemcachedSocket":
            suggest = "session_memcached_socket"
        elif key == "sessionRedisClusterMaxRedirections":
            suggest = "session_redis_cluster_max_redirections"
        elif key == "sessionRedisClusterNodes":
            suggest = "session_redis_cluster_nodes"
        elif key == "sessionRedisConnectTimeout":
            suggest = "session_redis_connect_timeout"
        elif key == "sessionRedisHost":
            suggest = "session_redis_host"
        elif key == "sessionRedisPassword":
            suggest = "session_redis_password"
        elif key == "sessionRedisPort":
            suggest = "session_redis_port"
        elif key == "sessionRedisPrefix":
            suggest = "session_redis_prefix"
        elif key == "sessionRedisReadTimeout":
            suggest = "session_redis_read_timeout"
        elif key == "sessionRedisSendTimeout":
            suggest = "session_redis_send_timeout"
        elif key == "sessionRedisServerName":
            suggest = "session_redis_server_name"
        elif key == "sessionRedisSocket":
            suggest = "session_redis_socket"
        elif key == "sessionRedisSsl":
            suggest = "session_redis_ssl"
        elif key == "sessionRedisSslVerify":
            suggest = "session_redis_ssl_verify"
        elif key == "sessionRedisUsername":
            suggest = "session_redis_username"
        elif key == "sessionRemember":
            suggest = "session_remember"
        elif key == "sessionRememberAbsoluteTimeout":
            suggest = "session_remember_absolute_timeout"
        elif key == "sessionRememberCookieName":
            suggest = "session_remember_cookie_name"
        elif key == "sessionRememberRollingTimeout":
            suggest = "session_remember_rolling_timeout"
        elif key == "sessionRequestHeaders":
            suggest = "session_request_headers"
        elif key == "sessionResponseHeaders":
            suggest = "session_response_headers"
        elif key == "sessionRollingTimeout":
            suggest = "session_rolling_timeout"
        elif key == "sessionSecret":
            suggest = "session_secret"
        elif key == "sessionStorage":
            suggest = "session_storage"
        elif key == "sessionStoreMetadata":
            suggest = "session_store_metadata"
        elif key == "sslVerify":
            suggest = "ssl_verify"
        elif key == "tlsClientAuthCertId":
            suggest = "tls_client_auth_cert_id"
        elif key == "tlsClientAuthSslVerify":
            suggest = "tls_client_auth_ssl_verify"
        elif key == "tokenCacheKeyIncludeScope":
            suggest = "token_cache_key_include_scope"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "tokenEndpointAuthMethod":
            suggest = "token_endpoint_auth_method"
        elif key == "tokenExchangeEndpoint":
            suggest = "token_exchange_endpoint"
        elif key == "tokenHeadersClients":
            suggest = "token_headers_clients"
        elif key == "tokenHeadersGrants":
            suggest = "token_headers_grants"
        elif key == "tokenHeadersNames":
            suggest = "token_headers_names"
        elif key == "tokenHeadersPrefix":
            suggest = "token_headers_prefix"
        elif key == "tokenHeadersReplays":
            suggest = "token_headers_replays"
        elif key == "tokenHeadersValues":
            suggest = "token_headers_values"
        elif key == "tokenPostArgsClients":
            suggest = "token_post_args_clients"
        elif key == "tokenPostArgsNames":
            suggest = "token_post_args_names"
        elif key == "tokenPostArgsValues":
            suggest = "token_post_args_values"
        elif key == "unauthorizedDestroySession":
            suggest = "unauthorized_destroy_session"
        elif key == "unauthorizedErrorMessage":
            suggest = "unauthorized_error_message"
        elif key == "unauthorizedRedirectUris":
            suggest = "unauthorized_redirect_uris"
        elif key == "unexpectedRedirectUris":
            suggest = "unexpected_redirect_uris"
        elif key == "upstreamAccessTokenHeader":
            suggest = "upstream_access_token_header"
        elif key == "upstreamAccessTokenJwkHeader":
            suggest = "upstream_access_token_jwk_header"
        elif key == "upstreamHeadersClaims":
            suggest = "upstream_headers_claims"
        elif key == "upstreamHeadersNames":
            suggest = "upstream_headers_names"
        elif key == "upstreamIdTokenHeader":
            suggest = "upstream_id_token_header"
        elif key == "upstreamIdTokenJwkHeader":
            suggest = "upstream_id_token_jwk_header"
        elif key == "upstreamIntrospectionHeader":
            suggest = "upstream_introspection_header"
        elif key == "upstreamIntrospectionJwtHeader":
            suggest = "upstream_introspection_jwt_header"
        elif key == "upstreamRefreshTokenHeader":
            suggest = "upstream_refresh_token_header"
        elif key == "upstreamSessionIdHeader":
            suggest = "upstream_session_id_header"
        elif key == "upstreamUserInfoHeader":
            suggest = "upstream_user_info_header"
        elif key == "upstreamUserInfoJwtHeader":
            suggest = "upstream_user_info_jwt_header"
        elif key == "userinfoAccept":
            suggest = "userinfo_accept"
        elif key == "userinfoEndpoint":
            suggest = "userinfo_endpoint"
        elif key == "userinfoHeadersClients":
            suggest = "userinfo_headers_clients"
        elif key == "userinfoHeadersNames":
            suggest = "userinfo_headers_names"
        elif key == "userinfoHeadersValues":
            suggest = "userinfo_headers_values"
        elif key == "userinfoQueryArgsClients":
            suggest = "userinfo_query_args_clients"
        elif key == "userinfoQueryArgsNames":
            suggest = "userinfo_query_args_names"
        elif key == "userinfoQueryArgsValues":
            suggest = "userinfo_query_args_values"
        elif key == "usingPseudoIssuer":
            suggest = "using_pseudo_issuer"
        elif key == "verifyClaims":
            suggest = "verify_claims"
        elif key == "verifyNonce":
            suggest = "verify_nonce"
        elif key == "verifyParameters":
            suggest = "verify_parameters"
        elif key == "verifySignature":
            suggest = "verify_signature"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOpenidConnectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOpenidConnectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOpenidConnectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous: Optional[str] = None,
                 audience_claims: Optional[Sequence[str]] = None,
                 audience_requireds: Optional[Sequence[str]] = None,
                 audiences: Optional[Sequence[str]] = None,
                 auth_methods: Optional[Sequence[str]] = None,
                 authenticated_groups_claims: Optional[Sequence[str]] = None,
                 authorization_cookie_domain: Optional[str] = None,
                 authorization_cookie_http_only: Optional[bool] = None,
                 authorization_cookie_name: Optional[str] = None,
                 authorization_cookie_path: Optional[str] = None,
                 authorization_cookie_same_site: Optional[str] = None,
                 authorization_cookie_secure: Optional[bool] = None,
                 authorization_endpoint: Optional[str] = None,
                 authorization_query_args_clients: Optional[Sequence[str]] = None,
                 authorization_query_args_names: Optional[Sequence[str]] = None,
                 authorization_query_args_values: Optional[Sequence[str]] = None,
                 authorization_rolling_timeout: Optional[float] = None,
                 bearer_token_cookie_name: Optional[str] = None,
                 bearer_token_param_types: Optional[Sequence[str]] = None,
                 by_username_ignore_case: Optional[bool] = None,
                 cache_introspection: Optional[bool] = None,
                 cache_token_exchange: Optional[bool] = None,
                 cache_tokens: Optional[bool] = None,
                 cache_tokens_salt: Optional[str] = None,
                 cache_ttl: Optional[float] = None,
                 cache_ttl_max: Optional[float] = None,
                 cache_ttl_min: Optional[float] = None,
                 cache_ttl_neg: Optional[float] = None,
                 cache_ttl_resurrect: Optional[float] = None,
                 cache_user_info: Optional[bool] = None,
                 client_algs: Optional[Sequence[str]] = None,
                 client_arg: Optional[str] = None,
                 client_auths: Optional[Sequence[str]] = None,
                 client_credentials_param_types: Optional[Sequence[str]] = None,
                 client_ids: Optional[Sequence[str]] = None,
                 client_jwks: Optional[Sequence['outputs.GatewayPluginOpenidConnectConfigClientJwk']] = None,
                 client_secrets: Optional[Sequence[str]] = None,
                 consumer_bies: Optional[Sequence[str]] = None,
                 consumer_claims: Optional[Sequence[str]] = None,
                 consumer_optional: Optional[bool] = None,
                 credential_claims: Optional[Sequence[str]] = None,
                 disable_sessions: Optional[Sequence[str]] = None,
                 discovery_headers_names: Optional[Sequence[str]] = None,
                 discovery_headers_values: Optional[Sequence[str]] = None,
                 display_errors: Optional[bool] = None,
                 domains: Optional[Sequence[str]] = None,
                 downstream_access_token_header: Optional[str] = None,
                 downstream_access_token_jwk_header: Optional[str] = None,
                 downstream_headers_claims: Optional[Sequence[str]] = None,
                 downstream_headers_names: Optional[Sequence[str]] = None,
                 downstream_id_token_header: Optional[str] = None,
                 downstream_id_token_jwk_header: Optional[str] = None,
                 downstream_introspection_header: Optional[str] = None,
                 downstream_introspection_jwt_header: Optional[str] = None,
                 downstream_refresh_token_header: Optional[str] = None,
                 downstream_session_id_header: Optional[str] = None,
                 downstream_user_info_header: Optional[str] = None,
                 downstream_user_info_jwt_header: Optional[str] = None,
                 dpop_proof_lifetime: Optional[float] = None,
                 dpop_use_nonce: Optional[bool] = None,
                 enable_hs_signatures: Optional[bool] = None,
                 end_session_endpoint: Optional[str] = None,
                 expose_error_code: Optional[bool] = None,
                 extra_jwks_uris: Optional[Sequence[str]] = None,
                 forbidden_destroy_session: Optional[bool] = None,
                 forbidden_error_message: Optional[str] = None,
                 forbidden_redirect_uris: Optional[Sequence[str]] = None,
                 groups_claims: Optional[Sequence[str]] = None,
                 groups_requireds: Optional[Sequence[str]] = None,
                 hide_credentials: Optional[bool] = None,
                 http_proxy: Optional[str] = None,
                 http_proxy_authorization: Optional[str] = None,
                 http_version: Optional[float] = None,
                 https_proxy: Optional[str] = None,
                 https_proxy_authorization: Optional[str] = None,
                 id_token_param_name: Optional[str] = None,
                 id_token_param_types: Optional[Sequence[str]] = None,
                 ignore_signatures: Optional[Sequence[str]] = None,
                 introspect_jwt_tokens: Optional[bool] = None,
                 introspection_accept: Optional[str] = None,
                 introspection_check_active: Optional[bool] = None,
                 introspection_endpoint: Optional[str] = None,
                 introspection_endpoint_auth_method: Optional[str] = None,
                 introspection_headers_clients: Optional[Sequence[str]] = None,
                 introspection_headers_names: Optional[Sequence[str]] = None,
                 introspection_headers_values: Optional[Sequence[str]] = None,
                 introspection_hint: Optional[str] = None,
                 introspection_post_args_clients: Optional[Sequence[str]] = None,
                 introspection_post_args_names: Optional[Sequence[str]] = None,
                 introspection_post_args_values: Optional[Sequence[str]] = None,
                 introspection_token_param_name: Optional[str] = None,
                 issuer: Optional[str] = None,
                 issuers_alloweds: Optional[Sequence[str]] = None,
                 jwt_session_claim: Optional[str] = None,
                 jwt_session_cookie: Optional[str] = None,
                 keepalive: Optional[bool] = None,
                 leeway: Optional[float] = None,
                 login_action: Optional[str] = None,
                 login_methods: Optional[Sequence[str]] = None,
                 login_redirect_mode: Optional[str] = None,
                 login_redirect_uris: Optional[Sequence[str]] = None,
                 login_tokens: Optional[Sequence[str]] = None,
                 logout_methods: Optional[Sequence[str]] = None,
                 logout_post_arg: Optional[str] = None,
                 logout_query_arg: Optional[str] = None,
                 logout_redirect_uris: Optional[Sequence[str]] = None,
                 logout_revoke: Optional[bool] = None,
                 logout_revoke_access_token: Optional[bool] = None,
                 logout_revoke_refresh_token: Optional[bool] = None,
                 logout_uri_suffix: Optional[str] = None,
                 max_age: Optional[float] = None,
                 mtls_introspection_endpoint: Optional[str] = None,
                 mtls_revocation_endpoint: Optional[str] = None,
                 mtls_token_endpoint: Optional[str] = None,
                 no_proxy: Optional[str] = None,
                 password_param_types: Optional[Sequence[str]] = None,
                 preserve_query_args: Optional[bool] = None,
                 proof_of_possession_auth_methods_validation: Optional[bool] = None,
                 proof_of_possession_dpop: Optional[str] = None,
                 proof_of_possession_mtls: Optional[str] = None,
                 pushed_authorization_request_endpoint: Optional[str] = None,
                 pushed_authorization_request_endpoint_auth_method: Optional[str] = None,
                 redirect_uris: Optional[Sequence[str]] = None,
                 rediscovery_lifetime: Optional[float] = None,
                 refresh_token_param_name: Optional[str] = None,
                 refresh_token_param_types: Optional[Sequence[str]] = None,
                 refresh_tokens: Optional[bool] = None,
                 require_proof_key_for_code_exchange: Optional[bool] = None,
                 require_pushed_authorization_requests: Optional[bool] = None,
                 require_signed_request_object: Optional[bool] = None,
                 resolve_distributed_claims: Optional[bool] = None,
                 response_mode: Optional[str] = None,
                 response_types: Optional[Sequence[str]] = None,
                 reverify: Optional[bool] = None,
                 revocation_endpoint: Optional[str] = None,
                 revocation_endpoint_auth_method: Optional[str] = None,
                 revocation_token_param_name: Optional[str] = None,
                 roles_claims: Optional[Sequence[str]] = None,
                 roles_requireds: Optional[Sequence[str]] = None,
                 run_on_preflight: Optional[bool] = None,
                 scopes: Optional[Sequence[str]] = None,
                 scopes_claims: Optional[Sequence[str]] = None,
                 scopes_requireds: Optional[Sequence[str]] = None,
                 search_user_info: Optional[bool] = None,
                 session_absolute_timeout: Optional[float] = None,
                 session_audience: Optional[str] = None,
                 session_cookie_domain: Optional[str] = None,
                 session_cookie_http_only: Optional[bool] = None,
                 session_cookie_name: Optional[str] = None,
                 session_cookie_path: Optional[str] = None,
                 session_cookie_same_site: Optional[str] = None,
                 session_cookie_secure: Optional[bool] = None,
                 session_enforce_same_subject: Optional[bool] = None,
                 session_hash_storage_key: Optional[bool] = None,
                 session_hash_subject: Optional[bool] = None,
                 session_idling_timeout: Optional[float] = None,
                 session_memcached_host: Optional[str] = None,
                 session_memcached_port: Optional[int] = None,
                 session_memcached_prefix: Optional[str] = None,
                 session_memcached_socket: Optional[str] = None,
                 session_redis_cluster_max_redirections: Optional[int] = None,
                 session_redis_cluster_nodes: Optional[Sequence['outputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNode']] = None,
                 session_redis_connect_timeout: Optional[int] = None,
                 session_redis_host: Optional[str] = None,
                 session_redis_password: Optional[str] = None,
                 session_redis_port: Optional[int] = None,
                 session_redis_prefix: Optional[str] = None,
                 session_redis_read_timeout: Optional[int] = None,
                 session_redis_send_timeout: Optional[int] = None,
                 session_redis_server_name: Optional[str] = None,
                 session_redis_socket: Optional[str] = None,
                 session_redis_ssl: Optional[bool] = None,
                 session_redis_ssl_verify: Optional[bool] = None,
                 session_redis_username: Optional[str] = None,
                 session_remember: Optional[bool] = None,
                 session_remember_absolute_timeout: Optional[float] = None,
                 session_remember_cookie_name: Optional[str] = None,
                 session_remember_rolling_timeout: Optional[float] = None,
                 session_request_headers: Optional[Sequence[str]] = None,
                 session_response_headers: Optional[Sequence[str]] = None,
                 session_rolling_timeout: Optional[float] = None,
                 session_secret: Optional[str] = None,
                 session_storage: Optional[str] = None,
                 session_store_metadata: Optional[bool] = None,
                 ssl_verify: Optional[bool] = None,
                 timeout: Optional[float] = None,
                 tls_client_auth_cert_id: Optional[str] = None,
                 tls_client_auth_ssl_verify: Optional[bool] = None,
                 token_cache_key_include_scope: Optional[bool] = None,
                 token_endpoint: Optional[str] = None,
                 token_endpoint_auth_method: Optional[str] = None,
                 token_exchange_endpoint: Optional[str] = None,
                 token_headers_clients: Optional[Sequence[str]] = None,
                 token_headers_grants: Optional[Sequence[str]] = None,
                 token_headers_names: Optional[Sequence[str]] = None,
                 token_headers_prefix: Optional[str] = None,
                 token_headers_replays: Optional[Sequence[str]] = None,
                 token_headers_values: Optional[Sequence[str]] = None,
                 token_post_args_clients: Optional[Sequence[str]] = None,
                 token_post_args_names: Optional[Sequence[str]] = None,
                 token_post_args_values: Optional[Sequence[str]] = None,
                 unauthorized_destroy_session: Optional[bool] = None,
                 unauthorized_error_message: Optional[str] = None,
                 unauthorized_redirect_uris: Optional[Sequence[str]] = None,
                 unexpected_redirect_uris: Optional[Sequence[str]] = None,
                 upstream_access_token_header: Optional[str] = None,
                 upstream_access_token_jwk_header: Optional[str] = None,
                 upstream_headers_claims: Optional[Sequence[str]] = None,
                 upstream_headers_names: Optional[Sequence[str]] = None,
                 upstream_id_token_header: Optional[str] = None,
                 upstream_id_token_jwk_header: Optional[str] = None,
                 upstream_introspection_header: Optional[str] = None,
                 upstream_introspection_jwt_header: Optional[str] = None,
                 upstream_refresh_token_header: Optional[str] = None,
                 upstream_session_id_header: Optional[str] = None,
                 upstream_user_info_header: Optional[str] = None,
                 upstream_user_info_jwt_header: Optional[str] = None,
                 userinfo_accept: Optional[str] = None,
                 userinfo_endpoint: Optional[str] = None,
                 userinfo_headers_clients: Optional[Sequence[str]] = None,
                 userinfo_headers_names: Optional[Sequence[str]] = None,
                 userinfo_headers_values: Optional[Sequence[str]] = None,
                 userinfo_query_args_clients: Optional[Sequence[str]] = None,
                 userinfo_query_args_names: Optional[Sequence[str]] = None,
                 userinfo_query_args_values: Optional[Sequence[str]] = None,
                 using_pseudo_issuer: Optional[bool] = None,
                 verify_claims: Optional[bool] = None,
                 verify_nonce: Optional[bool] = None,
                 verify_parameters: Optional[bool] = None,
                 verify_signature: Optional[bool] = None):
        """
        :param str anonymous: An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
        :param Sequence[str] audience_claims: The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] audience_requireds: The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param Sequence[str] audiences: The audience passed to the authorization endpoint.
        :param Sequence[str] auth_methods: Types of credentials/grants to enable.
        :param Sequence[str] authenticated_groups_claims: The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param str authorization_cookie_domain: The authorization cookie Domain flag.
        :param bool authorization_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str authorization_cookie_name: The authorization cookie name.
        :param str authorization_cookie_path: The authorization cookie Path flag.
        :param str authorization_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool authorization_cookie_secure: Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param str authorization_endpoint: The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
        :param Sequence[str] authorization_query_args_clients: Extra query arguments passed from the client to the authorization endpoint.
        :param Sequence[str] authorization_query_args_names: Extra query argument names passed to the authorization endpoint.
        :param Sequence[str] authorization_query_args_values: Extra query argument values passed to the authorization endpoint.
        :param float authorization_rolling_timeout: Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        :param str bearer_token_cookie_name: The name of the cookie in which the bearer token is passed.
        :param Sequence[str] bearer_token_param_types: Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
        :param bool by_username_ignore_case: If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
        :param bool cache_introspection: Cache the introspection endpoint requests.
        :param bool cache_token_exchange: Cache the token exchange endpoint requests.
        :param bool cache_tokens: Cache the token endpoint requests.
        :param str cache_tokens_salt: Salt used for generating the cache key that is used for caching the token endpoint requests.
        :param float cache_ttl: The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
        :param float cache_ttl_max: The maximum cache ttl in seconds (enforced).
        :param float cache_ttl_min: The minimum cache ttl in seconds (enforced).
        :param float cache_ttl_neg: The negative cache ttl in seconds.
        :param float cache_ttl_resurrect: The resurrection ttl in seconds.
        :param bool cache_user_info: Cache the user info requests.
        :param Sequence[str] client_algs: The algorithm to use for client*secret*jwt (only HS***) or private*key*jwt authentication.
        :param str client_arg: The client to use for this request (the selection is made with a request parameter with the same name).
        :param Sequence[str] client_auths: The default OpenID Connect client authentication method is 'client*secret*basic' (using 'Authorization: Basic' header), 'client*secret*post' (credentials in body), 'client*secret*jwt' (signed client assertion in body), 'private*key*jwt' (private key-signed assertion), 'tls*client*auth' (client certificate), 'self*signed*tls*client*auth' (self-signed client certificate), and 'none' (no authentication).
        :param Sequence[str] client_credentials_param_types: Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
        :param Sequence[str] client_ids: The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
        :param Sequence['GatewayPluginOpenidConnectConfigClientJwkArgs'] client_jwks: The JWK used for the private*key*jwt authentication.
        :param Sequence[str] client_secrets: The client secret.
        :param Sequence[str] consumer_bies: Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
        :param Sequence[str] consumer_claims: The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param bool consumer_optional: Do not terminate the request if consumer mapping fails.
        :param Sequence[str] credential_claims: The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] disable_sessions: Disable issuing the session cookie with the specified grants.
        :param Sequence[str] discovery_headers_names: Extra header names passed to the discovery endpoint.
        :param Sequence[str] discovery_headers_values: Extra header values passed to the discovery endpoint.
        :param bool display_errors: Display errors on failure responses.
        :param Sequence[str] domains: The allowed values for the `hd` claim.
        :param str downstream_access_token_header: The downstream access token header.
        :param str downstream_access_token_jwk_header: The downstream access token JWK header.
        :param Sequence[str] downstream_headers_claims: The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] downstream_headers_names: The downstream header names for the claim values.
        :param str downstream_id_token_header: The downstream id token header.
        :param str downstream_id_token_jwk_header: The downstream id token JWK header.
        :param str downstream_introspection_header: The downstream introspection header.
        :param str downstream_introspection_jwt_header: The downstream introspection JWT header.
        :param str downstream_refresh_token_header: The downstream refresh token header.
        :param str downstream_session_id_header: The downstream session id header.
        :param str downstream_user_info_header: The downstream user info header.
        :param str downstream_user_info_jwt_header: The downstream user info JWT header (in case the user info returns a JWT response).
        :param float dpop_proof_lifetime: Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
        :param bool dpop_use_nonce: Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
        :param bool enable_hs_signatures: Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
        :param str end_session_endpoint: The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
        :param bool expose_error_code: Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
        :param Sequence[str] extra_jwks_uris: JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
        :param bool forbidden_destroy_session: Destroy any active session for the forbidden requests.
        :param str forbidden_error_message: The error message for the forbidden requests (when not using the redirection).
        :param Sequence[str] forbidden_redirect_uris: Where to redirect the client on forbidden requests.
        :param Sequence[str] groups_claims: The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] groups_requireds: The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool hide_credentials: Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
        :param str http_proxy: The HTTP proxy.
        :param str http_proxy_authorization: The HTTP proxy authorization.
        :param float http_version: The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
        :param str https_proxy: The HTTPS proxy.
        :param str https_proxy_authorization: The HTTPS proxy authorization.
        :param str id_token_param_name: The name of the parameter used to pass the id token.
        :param Sequence[str] id_token_param_types: Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param Sequence[str] ignore_signatures: Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
        :param bool introspect_jwt_tokens: Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
        :param str introspection_accept: The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
        :param bool introspection_check_active: Check that the introspection response has an `active` claim with a value of `true`.
        :param str introspection_endpoint: The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
        :param str introspection_endpoint_auth_method: The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client*secret*basic", "client*secret*post", "client*secret*jwt", "private*key*jwt", "tls*client*auth", "self*signed*tls*client*auth", "none"]
        :param Sequence[str] introspection_headers_clients: Extra headers passed from the client to the introspection endpoint.
        :param Sequence[str] introspection_headers_names: Extra header names passed to the introspection endpoint.
        :param Sequence[str] introspection_headers_values: Extra header values passed to the introspection endpoint.
        :param str introspection_hint: Introspection hint parameter value passed to the introspection endpoint.
        :param Sequence[str] introspection_post_args_clients: Extra post arguments passed from the client to the introspection endpoint.
        :param Sequence[str] introspection_post_args_names: Extra post argument names passed to the introspection endpoint.
        :param Sequence[str] introspection_post_args_values: Extra post argument values passed to the introspection endpoint.
        :param str introspection_token_param_name: Designate token's parameter name for introspection.
        :param str issuer: The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
        :param Sequence[str] issuers_alloweds: The issuers allowed to be present in the tokens (`iss` claim).
        :param str jwt_session_claim: The claim to match against the JWT session cookie.
        :param str jwt_session_cookie: The name of the JWT session cookie.
        :param bool keepalive: Use keepalive with the HTTP client.
        :param float leeway: Defines leeway time (in seconds) for `auth_time`, `exp`, `iat`, and `nbf` claims
        :param str login_action: What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
        :param Sequence[str] login_methods: Enable login functionality with specified grants.
        :param str login_redirect_mode: Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
        :param Sequence[str] login_redirect_uris: Where to redirect the client when `login_action` is set to `redirect`.
        :param Sequence[str] login_tokens: What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
        :param Sequence[str] logout_methods: The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
        :param str logout_post_arg: The request body argument that activates the logout.
        :param str logout_query_arg: The request query argument that activates the logout.
        :param Sequence[str] logout_redirect_uris: Where to redirect the client after the logout.
        :param bool logout_revoke: Revoke tokens as part of the logout.
        :param bool logout_revoke_access_token: Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
        :param bool logout_revoke_refresh_token: Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
        :param str logout_uri_suffix: The request URI suffix that activates the logout.
        :param float max_age: The maximum age (in seconds) compared to the `auth_time` claim.
        :param str mtls_introspection_endpoint: Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str mtls_revocation_endpoint: Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str mtls_token_endpoint: Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str no_proxy: Do not use proxy with these hosts.
        :param Sequence[str] password_param_types: Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param bool preserve_query_args: With this parameter, you can preserve request query arguments even when doing authorization code flow.
        :param bool proof_of_possession_auth_methods_validation: If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
        :param str proof_of_possession_dpop: Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
        :param str proof_of_possession_mtls: Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
        :param str pushed_authorization_request_endpoint: The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
        :param str pushed_authorization_request_endpoint_auth_method: The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param Sequence[str] redirect_uris: The redirect URI passed to the authorization and token endpoints.
        :param float rediscovery_lifetime: Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
        :param str refresh_token_param_name: The name of the parameter used to pass the refresh token.
        :param Sequence[str] refresh_token_param_types: Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param bool refresh_tokens: Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
        :param bool require_proof_key_for_code_exchange: Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
        :param bool require_pushed_authorization_requests: Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
        :param bool require_signed_request_object: Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `require_signed_request_object`, and enabled automatically (in case the `require_signed_request_object` is missing, the feature will not be enabled).
        :param bool resolve_distributed_claims: Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
        :param str response_mode: Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `form_post`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `form_post` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "form_post", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
        :param Sequence[str] response_types: The response type passed to the authorization endpoint.
        :param bool reverify: Specifies whether to always verify tokens stored in the session.
        :param str revocation_endpoint: The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
        :param str revocation_endpoint_auth_method: The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param str revocation_token_param_name: Designate token's parameter name for revocation.
        :param Sequence[str] roles_claims: The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] roles_requireds: The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool run_on_preflight: Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
        :param Sequence[str] scopes: The scopes passed to the authorization and token endpoints.
        :param Sequence[str] scopes_claims: The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] scopes_requireds: The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool search_user_info: Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
        :param float session_absolute_timeout: Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        :param str session_audience: The session audience, which is the intended target application. For example `"my-application"`.
        :param str session_cookie_domain: The session cookie Domain flag.
        :param bool session_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str session_cookie_name: The session cookie name.
        :param str session_cookie_path: The session cookie Path flag.
        :param str session_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool session_cookie_secure: Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param bool session_enforce_same_subject: When set to `true`, audiences are forced to share the same subject.
        :param bool session_hash_storage_key: When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        :param bool session_hash_subject: When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        :param float session_idling_timeout: Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
        :param str session_memcached_host: The memcached host.
        :param int session_memcached_port: The memcached port.
        :param str session_memcached_prefix: The memcached session key prefix.
        :param str session_memcached_socket: The memcached unix socket path.
        :param int session_redis_cluster_max_redirections: The Redis cluster maximum redirects.
        :param Sequence['GatewayPluginOpenidConnectConfigSessionRedisClusterNodeArgs'] session_redis_cluster_nodes: The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        :param int session_redis_connect_timeout: Session redis connection timeout in milliseconds.
        :param str session_redis_host: The Redis host.
        :param str session_redis_password: Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
        :param int session_redis_port: The Redis port.
        :param str session_redis_prefix: The Redis session key prefix.
        :param int session_redis_read_timeout: Session redis read timeout in milliseconds.
        :param int session_redis_send_timeout: Session redis send timeout in milliseconds.
        :param str session_redis_server_name: The SNI used for connecting the Redis server.
        :param str session_redis_socket: The Redis unix socket path.
        :param bool session_redis_ssl: Use SSL/TLS for Redis connection.
        :param bool session_redis_ssl_verify: Verify identity provider server certificate.
        :param str session_redis_username: Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        :param bool session_remember: Enables or disables persistent sessions.
        :param float session_remember_absolute_timeout: Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        :param str session_remember_cookie_name: Persistent session cookie name. Use with the `remember` configuration parameter.
        :param float session_remember_rolling_timeout: Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
        :param Sequence[str] session_request_headers: Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
        :param Sequence[str] session_response_headers: Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
        :param float session_rolling_timeout: Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        :param str session_secret: The session secret.
        :param str session_storage: The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        :param bool session_store_metadata: Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
        :param bool ssl_verify: Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `lua_ssl_trusted_certificate`.
        :param float timeout: Network IO timeout in milliseconds.
        :param str tls_client_auth_cert_id: ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
        :param bool tls_client_auth_ssl_verify: Verify identity provider server certificate during mTLS client authentication.
        :param bool token_cache_key_include_scope: Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
        :param str token_endpoint: The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
        :param str token_endpoint_auth_method: The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param str token_exchange_endpoint: The token exchange endpoint.
        :param Sequence[str] token_headers_clients: Extra headers passed from the client to the token endpoint.
        :param Sequence[str] token_headers_grants: Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
        :param Sequence[str] token_headers_names: Extra header names passed to the token endpoint.
        :param str token_headers_prefix: Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
        :param Sequence[str] token_headers_replays: The names of token endpoint response headers to forward to the downstream client.
        :param Sequence[str] token_headers_values: Extra header values passed to the token endpoint.
        :param Sequence[str] token_post_args_clients: Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
        :param Sequence[str] token_post_args_names: Extra post argument names passed to the token endpoint.
        :param Sequence[str] token_post_args_values: Extra post argument values passed to the token endpoint.
        :param bool unauthorized_destroy_session: Destroy any active session for the unauthorized requests.
        :param str unauthorized_error_message: The error message for the unauthorized requests (when not using the redirection).
        :param Sequence[str] unauthorized_redirect_uris: Where to redirect the client on unauthorized requests.
        :param Sequence[str] unexpected_redirect_uris: Where to redirect the client when unexpected errors happen with the requests.
        :param str upstream_access_token_header: The upstream access token header.
        :param str upstream_access_token_jwk_header: The upstream access token JWK header.
        :param Sequence[str] upstream_headers_claims: The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] upstream_headers_names: The upstream header names for the claim values.
        :param str upstream_id_token_header: The upstream id token header.
        :param str upstream_id_token_jwk_header: The upstream id token JWK header.
        :param str upstream_introspection_header: The upstream introspection header.
        :param str upstream_introspection_jwt_header: The upstream introspection JWT header.
        :param str upstream_refresh_token_header: The upstream refresh token header.
        :param str upstream_session_id_header: The upstream session id header.
        :param str upstream_user_info_header: The upstream user info header.
        :param str upstream_user_info_jwt_header: The upstream user info JWT header (in case the user info returns a JWT response).
        :param str userinfo_accept: The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
        :param str userinfo_endpoint: The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
        :param Sequence[str] userinfo_headers_clients: Extra headers passed from the client to the user info endpoint.
        :param Sequence[str] userinfo_headers_names: Extra header names passed to the user info endpoint.
        :param Sequence[str] userinfo_headers_values: Extra header values passed to the user info endpoint.
        :param Sequence[str] userinfo_query_args_clients: Extra query arguments passed from the client to the user info endpoint.
        :param Sequence[str] userinfo_query_args_names: Extra query argument names passed to the user info endpoint.
        :param Sequence[str] userinfo_query_args_values: Extra query argument values passed to the user info endpoint.
        :param bool using_pseudo_issuer: If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
        :param bool verify_claims: Verify tokens for standard claims.
        :param bool verify_nonce: Verify nonce on authorization code flow.
        :param bool verify_parameters: Verify plugin configuration against discovery.
        :param bool verify_signature: Verify signature of tokens.
        """
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if audience_claims is not None:
            pulumi.set(__self__, "audience_claims", audience_claims)
        if audience_requireds is not None:
            pulumi.set(__self__, "audience_requireds", audience_requireds)
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if auth_methods is not None:
            pulumi.set(__self__, "auth_methods", auth_methods)
        if authenticated_groups_claims is not None:
            pulumi.set(__self__, "authenticated_groups_claims", authenticated_groups_claims)
        if authorization_cookie_domain is not None:
            pulumi.set(__self__, "authorization_cookie_domain", authorization_cookie_domain)
        if authorization_cookie_http_only is not None:
            pulumi.set(__self__, "authorization_cookie_http_only", authorization_cookie_http_only)
        if authorization_cookie_name is not None:
            pulumi.set(__self__, "authorization_cookie_name", authorization_cookie_name)
        if authorization_cookie_path is not None:
            pulumi.set(__self__, "authorization_cookie_path", authorization_cookie_path)
        if authorization_cookie_same_site is not None:
            pulumi.set(__self__, "authorization_cookie_same_site", authorization_cookie_same_site)
        if authorization_cookie_secure is not None:
            pulumi.set(__self__, "authorization_cookie_secure", authorization_cookie_secure)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if authorization_query_args_clients is not None:
            pulumi.set(__self__, "authorization_query_args_clients", authorization_query_args_clients)
        if authorization_query_args_names is not None:
            pulumi.set(__self__, "authorization_query_args_names", authorization_query_args_names)
        if authorization_query_args_values is not None:
            pulumi.set(__self__, "authorization_query_args_values", authorization_query_args_values)
        if authorization_rolling_timeout is not None:
            pulumi.set(__self__, "authorization_rolling_timeout", authorization_rolling_timeout)
        if bearer_token_cookie_name is not None:
            pulumi.set(__self__, "bearer_token_cookie_name", bearer_token_cookie_name)
        if bearer_token_param_types is not None:
            pulumi.set(__self__, "bearer_token_param_types", bearer_token_param_types)
        if by_username_ignore_case is not None:
            pulumi.set(__self__, "by_username_ignore_case", by_username_ignore_case)
        if cache_introspection is not None:
            pulumi.set(__self__, "cache_introspection", cache_introspection)
        if cache_token_exchange is not None:
            pulumi.set(__self__, "cache_token_exchange", cache_token_exchange)
        if cache_tokens is not None:
            pulumi.set(__self__, "cache_tokens", cache_tokens)
        if cache_tokens_salt is not None:
            pulumi.set(__self__, "cache_tokens_salt", cache_tokens_salt)
        if cache_ttl is not None:
            pulumi.set(__self__, "cache_ttl", cache_ttl)
        if cache_ttl_max is not None:
            pulumi.set(__self__, "cache_ttl_max", cache_ttl_max)
        if cache_ttl_min is not None:
            pulumi.set(__self__, "cache_ttl_min", cache_ttl_min)
        if cache_ttl_neg is not None:
            pulumi.set(__self__, "cache_ttl_neg", cache_ttl_neg)
        if cache_ttl_resurrect is not None:
            pulumi.set(__self__, "cache_ttl_resurrect", cache_ttl_resurrect)
        if cache_user_info is not None:
            pulumi.set(__self__, "cache_user_info", cache_user_info)
        if client_algs is not None:
            pulumi.set(__self__, "client_algs", client_algs)
        if client_arg is not None:
            pulumi.set(__self__, "client_arg", client_arg)
        if client_auths is not None:
            pulumi.set(__self__, "client_auths", client_auths)
        if client_credentials_param_types is not None:
            pulumi.set(__self__, "client_credentials_param_types", client_credentials_param_types)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if client_jwks is not None:
            pulumi.set(__self__, "client_jwks", client_jwks)
        if client_secrets is not None:
            pulumi.set(__self__, "client_secrets", client_secrets)
        if consumer_bies is not None:
            pulumi.set(__self__, "consumer_bies", consumer_bies)
        if consumer_claims is not None:
            pulumi.set(__self__, "consumer_claims", consumer_claims)
        if consumer_optional is not None:
            pulumi.set(__self__, "consumer_optional", consumer_optional)
        if credential_claims is not None:
            pulumi.set(__self__, "credential_claims", credential_claims)
        if disable_sessions is not None:
            pulumi.set(__self__, "disable_sessions", disable_sessions)
        if discovery_headers_names is not None:
            pulumi.set(__self__, "discovery_headers_names", discovery_headers_names)
        if discovery_headers_values is not None:
            pulumi.set(__self__, "discovery_headers_values", discovery_headers_values)
        if display_errors is not None:
            pulumi.set(__self__, "display_errors", display_errors)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if downstream_access_token_header is not None:
            pulumi.set(__self__, "downstream_access_token_header", downstream_access_token_header)
        if downstream_access_token_jwk_header is not None:
            pulumi.set(__self__, "downstream_access_token_jwk_header", downstream_access_token_jwk_header)
        if downstream_headers_claims is not None:
            pulumi.set(__self__, "downstream_headers_claims", downstream_headers_claims)
        if downstream_headers_names is not None:
            pulumi.set(__self__, "downstream_headers_names", downstream_headers_names)
        if downstream_id_token_header is not None:
            pulumi.set(__self__, "downstream_id_token_header", downstream_id_token_header)
        if downstream_id_token_jwk_header is not None:
            pulumi.set(__self__, "downstream_id_token_jwk_header", downstream_id_token_jwk_header)
        if downstream_introspection_header is not None:
            pulumi.set(__self__, "downstream_introspection_header", downstream_introspection_header)
        if downstream_introspection_jwt_header is not None:
            pulumi.set(__self__, "downstream_introspection_jwt_header", downstream_introspection_jwt_header)
        if downstream_refresh_token_header is not None:
            pulumi.set(__self__, "downstream_refresh_token_header", downstream_refresh_token_header)
        if downstream_session_id_header is not None:
            pulumi.set(__self__, "downstream_session_id_header", downstream_session_id_header)
        if downstream_user_info_header is not None:
            pulumi.set(__self__, "downstream_user_info_header", downstream_user_info_header)
        if downstream_user_info_jwt_header is not None:
            pulumi.set(__self__, "downstream_user_info_jwt_header", downstream_user_info_jwt_header)
        if dpop_proof_lifetime is not None:
            pulumi.set(__self__, "dpop_proof_lifetime", dpop_proof_lifetime)
        if dpop_use_nonce is not None:
            pulumi.set(__self__, "dpop_use_nonce", dpop_use_nonce)
        if enable_hs_signatures is not None:
            pulumi.set(__self__, "enable_hs_signatures", enable_hs_signatures)
        if end_session_endpoint is not None:
            pulumi.set(__self__, "end_session_endpoint", end_session_endpoint)
        if expose_error_code is not None:
            pulumi.set(__self__, "expose_error_code", expose_error_code)
        if extra_jwks_uris is not None:
            pulumi.set(__self__, "extra_jwks_uris", extra_jwks_uris)
        if forbidden_destroy_session is not None:
            pulumi.set(__self__, "forbidden_destroy_session", forbidden_destroy_session)
        if forbidden_error_message is not None:
            pulumi.set(__self__, "forbidden_error_message", forbidden_error_message)
        if forbidden_redirect_uris is not None:
            pulumi.set(__self__, "forbidden_redirect_uris", forbidden_redirect_uris)
        if groups_claims is not None:
            pulumi.set(__self__, "groups_claims", groups_claims)
        if groups_requireds is not None:
            pulumi.set(__self__, "groups_requireds", groups_requireds)
        if hide_credentials is not None:
            pulumi.set(__self__, "hide_credentials", hide_credentials)
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if http_proxy_authorization is not None:
            pulumi.set(__self__, "http_proxy_authorization", http_proxy_authorization)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if https_proxy_authorization is not None:
            pulumi.set(__self__, "https_proxy_authorization", https_proxy_authorization)
        if id_token_param_name is not None:
            pulumi.set(__self__, "id_token_param_name", id_token_param_name)
        if id_token_param_types is not None:
            pulumi.set(__self__, "id_token_param_types", id_token_param_types)
        if ignore_signatures is not None:
            pulumi.set(__self__, "ignore_signatures", ignore_signatures)
        if introspect_jwt_tokens is not None:
            pulumi.set(__self__, "introspect_jwt_tokens", introspect_jwt_tokens)
        if introspection_accept is not None:
            pulumi.set(__self__, "introspection_accept", introspection_accept)
        if introspection_check_active is not None:
            pulumi.set(__self__, "introspection_check_active", introspection_check_active)
        if introspection_endpoint is not None:
            pulumi.set(__self__, "introspection_endpoint", introspection_endpoint)
        if introspection_endpoint_auth_method is not None:
            pulumi.set(__self__, "introspection_endpoint_auth_method", introspection_endpoint_auth_method)
        if introspection_headers_clients is not None:
            pulumi.set(__self__, "introspection_headers_clients", introspection_headers_clients)
        if introspection_headers_names is not None:
            pulumi.set(__self__, "introspection_headers_names", introspection_headers_names)
        if introspection_headers_values is not None:
            pulumi.set(__self__, "introspection_headers_values", introspection_headers_values)
        if introspection_hint is not None:
            pulumi.set(__self__, "introspection_hint", introspection_hint)
        if introspection_post_args_clients is not None:
            pulumi.set(__self__, "introspection_post_args_clients", introspection_post_args_clients)
        if introspection_post_args_names is not None:
            pulumi.set(__self__, "introspection_post_args_names", introspection_post_args_names)
        if introspection_post_args_values is not None:
            pulumi.set(__self__, "introspection_post_args_values", introspection_post_args_values)
        if introspection_token_param_name is not None:
            pulumi.set(__self__, "introspection_token_param_name", introspection_token_param_name)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if issuers_alloweds is not None:
            pulumi.set(__self__, "issuers_alloweds", issuers_alloweds)
        if jwt_session_claim is not None:
            pulumi.set(__self__, "jwt_session_claim", jwt_session_claim)
        if jwt_session_cookie is not None:
            pulumi.set(__self__, "jwt_session_cookie", jwt_session_cookie)
        if keepalive is not None:
            pulumi.set(__self__, "keepalive", keepalive)
        if leeway is not None:
            pulumi.set(__self__, "leeway", leeway)
        if login_action is not None:
            pulumi.set(__self__, "login_action", login_action)
        if login_methods is not None:
            pulumi.set(__self__, "login_methods", login_methods)
        if login_redirect_mode is not None:
            pulumi.set(__self__, "login_redirect_mode", login_redirect_mode)
        if login_redirect_uris is not None:
            pulumi.set(__self__, "login_redirect_uris", login_redirect_uris)
        if login_tokens is not None:
            pulumi.set(__self__, "login_tokens", login_tokens)
        if logout_methods is not None:
            pulumi.set(__self__, "logout_methods", logout_methods)
        if logout_post_arg is not None:
            pulumi.set(__self__, "logout_post_arg", logout_post_arg)
        if logout_query_arg is not None:
            pulumi.set(__self__, "logout_query_arg", logout_query_arg)
        if logout_redirect_uris is not None:
            pulumi.set(__self__, "logout_redirect_uris", logout_redirect_uris)
        if logout_revoke is not None:
            pulumi.set(__self__, "logout_revoke", logout_revoke)
        if logout_revoke_access_token is not None:
            pulumi.set(__self__, "logout_revoke_access_token", logout_revoke_access_token)
        if logout_revoke_refresh_token is not None:
            pulumi.set(__self__, "logout_revoke_refresh_token", logout_revoke_refresh_token)
        if logout_uri_suffix is not None:
            pulumi.set(__self__, "logout_uri_suffix", logout_uri_suffix)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if mtls_introspection_endpoint is not None:
            pulumi.set(__self__, "mtls_introspection_endpoint", mtls_introspection_endpoint)
        if mtls_revocation_endpoint is not None:
            pulumi.set(__self__, "mtls_revocation_endpoint", mtls_revocation_endpoint)
        if mtls_token_endpoint is not None:
            pulumi.set(__self__, "mtls_token_endpoint", mtls_token_endpoint)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if password_param_types is not None:
            pulumi.set(__self__, "password_param_types", password_param_types)
        if preserve_query_args is not None:
            pulumi.set(__self__, "preserve_query_args", preserve_query_args)
        if proof_of_possession_auth_methods_validation is not None:
            pulumi.set(__self__, "proof_of_possession_auth_methods_validation", proof_of_possession_auth_methods_validation)
        if proof_of_possession_dpop is not None:
            pulumi.set(__self__, "proof_of_possession_dpop", proof_of_possession_dpop)
        if proof_of_possession_mtls is not None:
            pulumi.set(__self__, "proof_of_possession_mtls", proof_of_possession_mtls)
        if pushed_authorization_request_endpoint is not None:
            pulumi.set(__self__, "pushed_authorization_request_endpoint", pushed_authorization_request_endpoint)
        if pushed_authorization_request_endpoint_auth_method is not None:
            pulumi.set(__self__, "pushed_authorization_request_endpoint_auth_method", pushed_authorization_request_endpoint_auth_method)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if rediscovery_lifetime is not None:
            pulumi.set(__self__, "rediscovery_lifetime", rediscovery_lifetime)
        if refresh_token_param_name is not None:
            pulumi.set(__self__, "refresh_token_param_name", refresh_token_param_name)
        if refresh_token_param_types is not None:
            pulumi.set(__self__, "refresh_token_param_types", refresh_token_param_types)
        if refresh_tokens is not None:
            pulumi.set(__self__, "refresh_tokens", refresh_tokens)
        if require_proof_key_for_code_exchange is not None:
            pulumi.set(__self__, "require_proof_key_for_code_exchange", require_proof_key_for_code_exchange)
        if require_pushed_authorization_requests is not None:
            pulumi.set(__self__, "require_pushed_authorization_requests", require_pushed_authorization_requests)
        if require_signed_request_object is not None:
            pulumi.set(__self__, "require_signed_request_object", require_signed_request_object)
        if resolve_distributed_claims is not None:
            pulumi.set(__self__, "resolve_distributed_claims", resolve_distributed_claims)
        if response_mode is not None:
            pulumi.set(__self__, "response_mode", response_mode)
        if response_types is not None:
            pulumi.set(__self__, "response_types", response_types)
        if reverify is not None:
            pulumi.set(__self__, "reverify", reverify)
        if revocation_endpoint is not None:
            pulumi.set(__self__, "revocation_endpoint", revocation_endpoint)
        if revocation_endpoint_auth_method is not None:
            pulumi.set(__self__, "revocation_endpoint_auth_method", revocation_endpoint_auth_method)
        if revocation_token_param_name is not None:
            pulumi.set(__self__, "revocation_token_param_name", revocation_token_param_name)
        if roles_claims is not None:
            pulumi.set(__self__, "roles_claims", roles_claims)
        if roles_requireds is not None:
            pulumi.set(__self__, "roles_requireds", roles_requireds)
        if run_on_preflight is not None:
            pulumi.set(__self__, "run_on_preflight", run_on_preflight)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if scopes_claims is not None:
            pulumi.set(__self__, "scopes_claims", scopes_claims)
        if scopes_requireds is not None:
            pulumi.set(__self__, "scopes_requireds", scopes_requireds)
        if search_user_info is not None:
            pulumi.set(__self__, "search_user_info", search_user_info)
        if session_absolute_timeout is not None:
            pulumi.set(__self__, "session_absolute_timeout", session_absolute_timeout)
        if session_audience is not None:
            pulumi.set(__self__, "session_audience", session_audience)
        if session_cookie_domain is not None:
            pulumi.set(__self__, "session_cookie_domain", session_cookie_domain)
        if session_cookie_http_only is not None:
            pulumi.set(__self__, "session_cookie_http_only", session_cookie_http_only)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_cookie_path is not None:
            pulumi.set(__self__, "session_cookie_path", session_cookie_path)
        if session_cookie_same_site is not None:
            pulumi.set(__self__, "session_cookie_same_site", session_cookie_same_site)
        if session_cookie_secure is not None:
            pulumi.set(__self__, "session_cookie_secure", session_cookie_secure)
        if session_enforce_same_subject is not None:
            pulumi.set(__self__, "session_enforce_same_subject", session_enforce_same_subject)
        if session_hash_storage_key is not None:
            pulumi.set(__self__, "session_hash_storage_key", session_hash_storage_key)
        if session_hash_subject is not None:
            pulumi.set(__self__, "session_hash_subject", session_hash_subject)
        if session_idling_timeout is not None:
            pulumi.set(__self__, "session_idling_timeout", session_idling_timeout)
        if session_memcached_host is not None:
            pulumi.set(__self__, "session_memcached_host", session_memcached_host)
        if session_memcached_port is not None:
            pulumi.set(__self__, "session_memcached_port", session_memcached_port)
        if session_memcached_prefix is not None:
            pulumi.set(__self__, "session_memcached_prefix", session_memcached_prefix)
        if session_memcached_socket is not None:
            pulumi.set(__self__, "session_memcached_socket", session_memcached_socket)
        if session_redis_cluster_max_redirections is not None:
            pulumi.set(__self__, "session_redis_cluster_max_redirections", session_redis_cluster_max_redirections)
        if session_redis_cluster_nodes is not None:
            pulumi.set(__self__, "session_redis_cluster_nodes", session_redis_cluster_nodes)
        if session_redis_connect_timeout is not None:
            pulumi.set(__self__, "session_redis_connect_timeout", session_redis_connect_timeout)
        if session_redis_host is not None:
            pulumi.set(__self__, "session_redis_host", session_redis_host)
        if session_redis_password is not None:
            pulumi.set(__self__, "session_redis_password", session_redis_password)
        if session_redis_port is not None:
            pulumi.set(__self__, "session_redis_port", session_redis_port)
        if session_redis_prefix is not None:
            pulumi.set(__self__, "session_redis_prefix", session_redis_prefix)
        if session_redis_read_timeout is not None:
            pulumi.set(__self__, "session_redis_read_timeout", session_redis_read_timeout)
        if session_redis_send_timeout is not None:
            pulumi.set(__self__, "session_redis_send_timeout", session_redis_send_timeout)
        if session_redis_server_name is not None:
            pulumi.set(__self__, "session_redis_server_name", session_redis_server_name)
        if session_redis_socket is not None:
            pulumi.set(__self__, "session_redis_socket", session_redis_socket)
        if session_redis_ssl is not None:
            pulumi.set(__self__, "session_redis_ssl", session_redis_ssl)
        if session_redis_ssl_verify is not None:
            pulumi.set(__self__, "session_redis_ssl_verify", session_redis_ssl_verify)
        if session_redis_username is not None:
            pulumi.set(__self__, "session_redis_username", session_redis_username)
        if session_remember is not None:
            pulumi.set(__self__, "session_remember", session_remember)
        if session_remember_absolute_timeout is not None:
            pulumi.set(__self__, "session_remember_absolute_timeout", session_remember_absolute_timeout)
        if session_remember_cookie_name is not None:
            pulumi.set(__self__, "session_remember_cookie_name", session_remember_cookie_name)
        if session_remember_rolling_timeout is not None:
            pulumi.set(__self__, "session_remember_rolling_timeout", session_remember_rolling_timeout)
        if session_request_headers is not None:
            pulumi.set(__self__, "session_request_headers", session_request_headers)
        if session_response_headers is not None:
            pulumi.set(__self__, "session_response_headers", session_response_headers)
        if session_rolling_timeout is not None:
            pulumi.set(__self__, "session_rolling_timeout", session_rolling_timeout)
        if session_secret is not None:
            pulumi.set(__self__, "session_secret", session_secret)
        if session_storage is not None:
            pulumi.set(__self__, "session_storage", session_storage)
        if session_store_metadata is not None:
            pulumi.set(__self__, "session_store_metadata", session_store_metadata)
        if ssl_verify is not None:
            pulumi.set(__self__, "ssl_verify", ssl_verify)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_client_auth_cert_id is not None:
            pulumi.set(__self__, "tls_client_auth_cert_id", tls_client_auth_cert_id)
        if tls_client_auth_ssl_verify is not None:
            pulumi.set(__self__, "tls_client_auth_ssl_verify", tls_client_auth_ssl_verify)
        if token_cache_key_include_scope is not None:
            pulumi.set(__self__, "token_cache_key_include_scope", token_cache_key_include_scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if token_endpoint_auth_method is not None:
            pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)
        if token_exchange_endpoint is not None:
            pulumi.set(__self__, "token_exchange_endpoint", token_exchange_endpoint)
        if token_headers_clients is not None:
            pulumi.set(__self__, "token_headers_clients", token_headers_clients)
        if token_headers_grants is not None:
            pulumi.set(__self__, "token_headers_grants", token_headers_grants)
        if token_headers_names is not None:
            pulumi.set(__self__, "token_headers_names", token_headers_names)
        if token_headers_prefix is not None:
            pulumi.set(__self__, "token_headers_prefix", token_headers_prefix)
        if token_headers_replays is not None:
            pulumi.set(__self__, "token_headers_replays", token_headers_replays)
        if token_headers_values is not None:
            pulumi.set(__self__, "token_headers_values", token_headers_values)
        if token_post_args_clients is not None:
            pulumi.set(__self__, "token_post_args_clients", token_post_args_clients)
        if token_post_args_names is not None:
            pulumi.set(__self__, "token_post_args_names", token_post_args_names)
        if token_post_args_values is not None:
            pulumi.set(__self__, "token_post_args_values", token_post_args_values)
        if unauthorized_destroy_session is not None:
            pulumi.set(__self__, "unauthorized_destroy_session", unauthorized_destroy_session)
        if unauthorized_error_message is not None:
            pulumi.set(__self__, "unauthorized_error_message", unauthorized_error_message)
        if unauthorized_redirect_uris is not None:
            pulumi.set(__self__, "unauthorized_redirect_uris", unauthorized_redirect_uris)
        if unexpected_redirect_uris is not None:
            pulumi.set(__self__, "unexpected_redirect_uris", unexpected_redirect_uris)
        if upstream_access_token_header is not None:
            pulumi.set(__self__, "upstream_access_token_header", upstream_access_token_header)
        if upstream_access_token_jwk_header is not None:
            pulumi.set(__self__, "upstream_access_token_jwk_header", upstream_access_token_jwk_header)
        if upstream_headers_claims is not None:
            pulumi.set(__self__, "upstream_headers_claims", upstream_headers_claims)
        if upstream_headers_names is not None:
            pulumi.set(__self__, "upstream_headers_names", upstream_headers_names)
        if upstream_id_token_header is not None:
            pulumi.set(__self__, "upstream_id_token_header", upstream_id_token_header)
        if upstream_id_token_jwk_header is not None:
            pulumi.set(__self__, "upstream_id_token_jwk_header", upstream_id_token_jwk_header)
        if upstream_introspection_header is not None:
            pulumi.set(__self__, "upstream_introspection_header", upstream_introspection_header)
        if upstream_introspection_jwt_header is not None:
            pulumi.set(__self__, "upstream_introspection_jwt_header", upstream_introspection_jwt_header)
        if upstream_refresh_token_header is not None:
            pulumi.set(__self__, "upstream_refresh_token_header", upstream_refresh_token_header)
        if upstream_session_id_header is not None:
            pulumi.set(__self__, "upstream_session_id_header", upstream_session_id_header)
        if upstream_user_info_header is not None:
            pulumi.set(__self__, "upstream_user_info_header", upstream_user_info_header)
        if upstream_user_info_jwt_header is not None:
            pulumi.set(__self__, "upstream_user_info_jwt_header", upstream_user_info_jwt_header)
        if userinfo_accept is not None:
            pulumi.set(__self__, "userinfo_accept", userinfo_accept)
        if userinfo_endpoint is not None:
            pulumi.set(__self__, "userinfo_endpoint", userinfo_endpoint)
        if userinfo_headers_clients is not None:
            pulumi.set(__self__, "userinfo_headers_clients", userinfo_headers_clients)
        if userinfo_headers_names is not None:
            pulumi.set(__self__, "userinfo_headers_names", userinfo_headers_names)
        if userinfo_headers_values is not None:
            pulumi.set(__self__, "userinfo_headers_values", userinfo_headers_values)
        if userinfo_query_args_clients is not None:
            pulumi.set(__self__, "userinfo_query_args_clients", userinfo_query_args_clients)
        if userinfo_query_args_names is not None:
            pulumi.set(__self__, "userinfo_query_args_names", userinfo_query_args_names)
        if userinfo_query_args_values is not None:
            pulumi.set(__self__, "userinfo_query_args_values", userinfo_query_args_values)
        if using_pseudo_issuer is not None:
            pulumi.set(__self__, "using_pseudo_issuer", using_pseudo_issuer)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)
        if verify_nonce is not None:
            pulumi.set(__self__, "verify_nonce", verify_nonce)
        if verify_parameters is not None:
            pulumi.set(__self__, "verify_parameters", verify_parameters)
        if verify_signature is not None:
            pulumi.set(__self__, "verify_signature", verify_signature)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="audienceClaims")
    def audience_claims(self) -> Optional[Sequence[str]]:
        """
        The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "audience_claims")

    @property
    @pulumi.getter(name="audienceRequireds")
    def audience_requireds(self) -> Optional[Sequence[str]]:
        """
        The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "audience_requireds")

    @property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[str]]:
        """
        The audience passed to the authorization endpoint.
        """
        return pulumi.get(self, "audiences")

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Optional[Sequence[str]]:
        """
        Types of credentials/grants to enable.
        """
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="authenticatedGroupsClaims")
    def authenticated_groups_claims(self) -> Optional[Sequence[str]]:
        """
        The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "authenticated_groups_claims")

    @property
    @pulumi.getter(name="authorizationCookieDomain")
    def authorization_cookie_domain(self) -> Optional[str]:
        """
        The authorization cookie Domain flag.
        """
        return pulumi.get(self, "authorization_cookie_domain")

    @property
    @pulumi.getter(name="authorizationCookieHttpOnly")
    def authorization_cookie_http_only(self) -> Optional[bool]:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "authorization_cookie_http_only")

    @property
    @pulumi.getter(name="authorizationCookieName")
    def authorization_cookie_name(self) -> Optional[str]:
        """
        The authorization cookie name.
        """
        return pulumi.get(self, "authorization_cookie_name")

    @property
    @pulumi.getter(name="authorizationCookiePath")
    def authorization_cookie_path(self) -> Optional[str]:
        """
        The authorization cookie Path flag.
        """
        return pulumi.get(self, "authorization_cookie_path")

    @property
    @pulumi.getter(name="authorizationCookieSameSite")
    def authorization_cookie_same_site(self) -> Optional[str]:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "authorization_cookie_same_site")

    @property
    @pulumi.getter(name="authorizationCookieSecure")
    def authorization_cookie_secure(self) -> Optional[bool]:
        """
        Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "authorization_cookie_secure")

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="authorizationQueryArgsClients")
    def authorization_query_args_clients(self) -> Optional[Sequence[str]]:
        """
        Extra query arguments passed from the client to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_clients")

    @property
    @pulumi.getter(name="authorizationQueryArgsNames")
    def authorization_query_args_names(self) -> Optional[Sequence[str]]:
        """
        Extra query argument names passed to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_names")

    @property
    @pulumi.getter(name="authorizationQueryArgsValues")
    def authorization_query_args_values(self) -> Optional[Sequence[str]]:
        """
        Extra query argument values passed to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_values")

    @property
    @pulumi.getter(name="authorizationRollingTimeout")
    def authorization_rolling_timeout(self) -> Optional[float]:
        """
        Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "authorization_rolling_timeout")

    @property
    @pulumi.getter(name="bearerTokenCookieName")
    def bearer_token_cookie_name(self) -> Optional[str]:
        """
        The name of the cookie in which the bearer token is passed.
        """
        return pulumi.get(self, "bearer_token_cookie_name")

    @property
    @pulumi.getter(name="bearerTokenParamTypes")
    def bearer_token_param_types(self) -> Optional[Sequence[str]]:
        """
        Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
        """
        return pulumi.get(self, "bearer_token_param_types")

    @property
    @pulumi.getter(name="byUsernameIgnoreCase")
    def by_username_ignore_case(self) -> Optional[bool]:
        """
        If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
        """
        return pulumi.get(self, "by_username_ignore_case")

    @property
    @pulumi.getter(name="cacheIntrospection")
    def cache_introspection(self) -> Optional[bool]:
        """
        Cache the introspection endpoint requests.
        """
        return pulumi.get(self, "cache_introspection")

    @property
    @pulumi.getter(name="cacheTokenExchange")
    def cache_token_exchange(self) -> Optional[bool]:
        """
        Cache the token exchange endpoint requests.
        """
        return pulumi.get(self, "cache_token_exchange")

    @property
    @pulumi.getter(name="cacheTokens")
    def cache_tokens(self) -> Optional[bool]:
        """
        Cache the token endpoint requests.
        """
        return pulumi.get(self, "cache_tokens")

    @property
    @pulumi.getter(name="cacheTokensSalt")
    def cache_tokens_salt(self) -> Optional[str]:
        """
        Salt used for generating the cache key that is used for caching the token endpoint requests.
        """
        return pulumi.get(self, "cache_tokens_salt")

    @property
    @pulumi.getter(name="cacheTtl")
    def cache_ttl(self) -> Optional[float]:
        """
        The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
        """
        return pulumi.get(self, "cache_ttl")

    @property
    @pulumi.getter(name="cacheTtlMax")
    def cache_ttl_max(self) -> Optional[float]:
        """
        The maximum cache ttl in seconds (enforced).
        """
        return pulumi.get(self, "cache_ttl_max")

    @property
    @pulumi.getter(name="cacheTtlMin")
    def cache_ttl_min(self) -> Optional[float]:
        """
        The minimum cache ttl in seconds (enforced).
        """
        return pulumi.get(self, "cache_ttl_min")

    @property
    @pulumi.getter(name="cacheTtlNeg")
    def cache_ttl_neg(self) -> Optional[float]:
        """
        The negative cache ttl in seconds.
        """
        return pulumi.get(self, "cache_ttl_neg")

    @property
    @pulumi.getter(name="cacheTtlResurrect")
    def cache_ttl_resurrect(self) -> Optional[float]:
        """
        The resurrection ttl in seconds.
        """
        return pulumi.get(self, "cache_ttl_resurrect")

    @property
    @pulumi.getter(name="cacheUserInfo")
    def cache_user_info(self) -> Optional[bool]:
        """
        Cache the user info requests.
        """
        return pulumi.get(self, "cache_user_info")

    @property
    @pulumi.getter(name="clientAlgs")
    def client_algs(self) -> Optional[Sequence[str]]:
        """
        The algorithm to use for client*secret*jwt (only HS***) or private*key*jwt authentication.
        """
        return pulumi.get(self, "client_algs")

    @property
    @pulumi.getter(name="clientArg")
    def client_arg(self) -> Optional[str]:
        """
        The client to use for this request (the selection is made with a request parameter with the same name).
        """
        return pulumi.get(self, "client_arg")

    @property
    @pulumi.getter(name="clientAuths")
    def client_auths(self) -> Optional[Sequence[str]]:
        """
        The default OpenID Connect client authentication method is 'client*secret*basic' (using 'Authorization: Basic' header), 'client*secret*post' (credentials in body), 'client*secret*jwt' (signed client assertion in body), 'private*key*jwt' (private key-signed assertion), 'tls*client*auth' (client certificate), 'self*signed*tls*client*auth' (self-signed client certificate), and 'none' (no authentication).
        """
        return pulumi.get(self, "client_auths")

    @property
    @pulumi.getter(name="clientCredentialsParamTypes")
    def client_credentials_param_types(self) -> Optional[Sequence[str]]:
        """
        Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
        """
        return pulumi.get(self, "client_credentials_param_types")

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[Sequence[str]]:
        """
        The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
        """
        return pulumi.get(self, "client_ids")

    @property
    @pulumi.getter(name="clientJwks")
    def client_jwks(self) -> Optional[Sequence['outputs.GatewayPluginOpenidConnectConfigClientJwk']]:
        """
        The JWK used for the private*key*jwt authentication.
        """
        return pulumi.get(self, "client_jwks")

    @property
    @pulumi.getter(name="clientSecrets")
    def client_secrets(self) -> Optional[Sequence[str]]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secrets")

    @property
    @pulumi.getter(name="consumerBies")
    def consumer_bies(self) -> Optional[Sequence[str]]:
        """
        Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
        """
        return pulumi.get(self, "consumer_bies")

    @property
    @pulumi.getter(name="consumerClaims")
    def consumer_claims(self) -> Optional[Sequence[str]]:
        """
        The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "consumer_claims")

    @property
    @pulumi.getter(name="consumerOptional")
    def consumer_optional(self) -> Optional[bool]:
        """
        Do not terminate the request if consumer mapping fails.
        """
        return pulumi.get(self, "consumer_optional")

    @property
    @pulumi.getter(name="credentialClaims")
    def credential_claims(self) -> Optional[Sequence[str]]:
        """
        The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "credential_claims")

    @property
    @pulumi.getter(name="disableSessions")
    def disable_sessions(self) -> Optional[Sequence[str]]:
        """
        Disable issuing the session cookie with the specified grants.
        """
        return pulumi.get(self, "disable_sessions")

    @property
    @pulumi.getter(name="discoveryHeadersNames")
    def discovery_headers_names(self) -> Optional[Sequence[str]]:
        """
        Extra header names passed to the discovery endpoint.
        """
        return pulumi.get(self, "discovery_headers_names")

    @property
    @pulumi.getter(name="discoveryHeadersValues")
    def discovery_headers_values(self) -> Optional[Sequence[str]]:
        """
        Extra header values passed to the discovery endpoint.
        """
        return pulumi.get(self, "discovery_headers_values")

    @property
    @pulumi.getter(name="displayErrors")
    def display_errors(self) -> Optional[bool]:
        """
        Display errors on failure responses.
        """
        return pulumi.get(self, "display_errors")

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        The allowed values for the `hd` claim.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="downstreamAccessTokenHeader")
    def downstream_access_token_header(self) -> Optional[str]:
        """
        The downstream access token header.
        """
        return pulumi.get(self, "downstream_access_token_header")

    @property
    @pulumi.getter(name="downstreamAccessTokenJwkHeader")
    def downstream_access_token_jwk_header(self) -> Optional[str]:
        """
        The downstream access token JWK header.
        """
        return pulumi.get(self, "downstream_access_token_jwk_header")

    @property
    @pulumi.getter(name="downstreamHeadersClaims")
    def downstream_headers_claims(self) -> Optional[Sequence[str]]:
        """
        The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "downstream_headers_claims")

    @property
    @pulumi.getter(name="downstreamHeadersNames")
    def downstream_headers_names(self) -> Optional[Sequence[str]]:
        """
        The downstream header names for the claim values.
        """
        return pulumi.get(self, "downstream_headers_names")

    @property
    @pulumi.getter(name="downstreamIdTokenHeader")
    def downstream_id_token_header(self) -> Optional[str]:
        """
        The downstream id token header.
        """
        return pulumi.get(self, "downstream_id_token_header")

    @property
    @pulumi.getter(name="downstreamIdTokenJwkHeader")
    def downstream_id_token_jwk_header(self) -> Optional[str]:
        """
        The downstream id token JWK header.
        """
        return pulumi.get(self, "downstream_id_token_jwk_header")

    @property
    @pulumi.getter(name="downstreamIntrospectionHeader")
    def downstream_introspection_header(self) -> Optional[str]:
        """
        The downstream introspection header.
        """
        return pulumi.get(self, "downstream_introspection_header")

    @property
    @pulumi.getter(name="downstreamIntrospectionJwtHeader")
    def downstream_introspection_jwt_header(self) -> Optional[str]:
        """
        The downstream introspection JWT header.
        """
        return pulumi.get(self, "downstream_introspection_jwt_header")

    @property
    @pulumi.getter(name="downstreamRefreshTokenHeader")
    def downstream_refresh_token_header(self) -> Optional[str]:
        """
        The downstream refresh token header.
        """
        return pulumi.get(self, "downstream_refresh_token_header")

    @property
    @pulumi.getter(name="downstreamSessionIdHeader")
    def downstream_session_id_header(self) -> Optional[str]:
        """
        The downstream session id header.
        """
        return pulumi.get(self, "downstream_session_id_header")

    @property
    @pulumi.getter(name="downstreamUserInfoHeader")
    def downstream_user_info_header(self) -> Optional[str]:
        """
        The downstream user info header.
        """
        return pulumi.get(self, "downstream_user_info_header")

    @property
    @pulumi.getter(name="downstreamUserInfoJwtHeader")
    def downstream_user_info_jwt_header(self) -> Optional[str]:
        """
        The downstream user info JWT header (in case the user info returns a JWT response).
        """
        return pulumi.get(self, "downstream_user_info_jwt_header")

    @property
    @pulumi.getter(name="dpopProofLifetime")
    def dpop_proof_lifetime(self) -> Optional[float]:
        """
        Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
        """
        return pulumi.get(self, "dpop_proof_lifetime")

    @property
    @pulumi.getter(name="dpopUseNonce")
    def dpop_use_nonce(self) -> Optional[bool]:
        """
        Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
        """
        return pulumi.get(self, "dpop_use_nonce")

    @property
    @pulumi.getter(name="enableHsSignatures")
    def enable_hs_signatures(self) -> Optional[bool]:
        """
        Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
        """
        return pulumi.get(self, "enable_hs_signatures")

    @property
    @pulumi.getter(name="endSessionEndpoint")
    def end_session_endpoint(self) -> Optional[str]:
        """
        The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "end_session_endpoint")

    @property
    @pulumi.getter(name="exposeErrorCode")
    def expose_error_code(self) -> Optional[bool]:
        """
        Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
        """
        return pulumi.get(self, "expose_error_code")

    @property
    @pulumi.getter(name="extraJwksUris")
    def extra_jwks_uris(self) -> Optional[Sequence[str]]:
        """
        JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
        """
        return pulumi.get(self, "extra_jwks_uris")

    @property
    @pulumi.getter(name="forbiddenDestroySession")
    def forbidden_destroy_session(self) -> Optional[bool]:
        """
        Destroy any active session for the forbidden requests.
        """
        return pulumi.get(self, "forbidden_destroy_session")

    @property
    @pulumi.getter(name="forbiddenErrorMessage")
    def forbidden_error_message(self) -> Optional[str]:
        """
        The error message for the forbidden requests (when not using the redirection).
        """
        return pulumi.get(self, "forbidden_error_message")

    @property
    @pulumi.getter(name="forbiddenRedirectUris")
    def forbidden_redirect_uris(self) -> Optional[Sequence[str]]:
        """
        Where to redirect the client on forbidden requests.
        """
        return pulumi.get(self, "forbidden_redirect_uris")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Optional[Sequence[str]]:
        """
        The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsRequireds")
    def groups_requireds(self) -> Optional[Sequence[str]]:
        """
        The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "groups_requireds")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> Optional[bool]:
        """
        Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[str]:
        """
        The HTTP proxy.
        """
        return pulumi.get(self, "http_proxy")

    @property
    @pulumi.getter(name="httpProxyAuthorization")
    def http_proxy_authorization(self) -> Optional[str]:
        """
        The HTTP proxy authorization.
        """
        return pulumi.get(self, "http_proxy_authorization")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[float]:
        """
        The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[str]:
        """
        The HTTPS proxy.
        """
        return pulumi.get(self, "https_proxy")

    @property
    @pulumi.getter(name="httpsProxyAuthorization")
    def https_proxy_authorization(self) -> Optional[str]:
        """
        The HTTPS proxy authorization.
        """
        return pulumi.get(self, "https_proxy_authorization")

    @property
    @pulumi.getter(name="idTokenParamName")
    def id_token_param_name(self) -> Optional[str]:
        """
        The name of the parameter used to pass the id token.
        """
        return pulumi.get(self, "id_token_param_name")

    @property
    @pulumi.getter(name="idTokenParamTypes")
    def id_token_param_types(self) -> Optional[Sequence[str]]:
        """
        Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "id_token_param_types")

    @property
    @pulumi.getter(name="ignoreSignatures")
    def ignore_signatures(self) -> Optional[Sequence[str]]:
        """
        Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
        """
        return pulumi.get(self, "ignore_signatures")

    @property
    @pulumi.getter(name="introspectJwtTokens")
    def introspect_jwt_tokens(self) -> Optional[bool]:
        """
        Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
        """
        return pulumi.get(self, "introspect_jwt_tokens")

    @property
    @pulumi.getter(name="introspectionAccept")
    def introspection_accept(self) -> Optional[str]:
        """
        The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
        """
        return pulumi.get(self, "introspection_accept")

    @property
    @pulumi.getter(name="introspectionCheckActive")
    def introspection_check_active(self) -> Optional[bool]:
        """
        Check that the introspection response has an `active` claim with a value of `true`.
        """
        return pulumi.get(self, "introspection_check_active")

    @property
    @pulumi.getter(name="introspectionEndpoint")
    def introspection_endpoint(self) -> Optional[str]:
        """
        The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "introspection_endpoint")

    @property
    @pulumi.getter(name="introspectionEndpointAuthMethod")
    def introspection_endpoint_auth_method(self) -> Optional[str]:
        """
        The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client*secret*basic", "client*secret*post", "client*secret*jwt", "private*key*jwt", "tls*client*auth", "self*signed*tls*client*auth", "none"]
        """
        return pulumi.get(self, "introspection_endpoint_auth_method")

    @property
    @pulumi.getter(name="introspectionHeadersClients")
    def introspection_headers_clients(self) -> Optional[Sequence[str]]:
        """
        Extra headers passed from the client to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_clients")

    @property
    @pulumi.getter(name="introspectionHeadersNames")
    def introspection_headers_names(self) -> Optional[Sequence[str]]:
        """
        Extra header names passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_names")

    @property
    @pulumi.getter(name="introspectionHeadersValues")
    def introspection_headers_values(self) -> Optional[Sequence[str]]:
        """
        Extra header values passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_values")

    @property
    @pulumi.getter(name="introspectionHint")
    def introspection_hint(self) -> Optional[str]:
        """
        Introspection hint parameter value passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_hint")

    @property
    @pulumi.getter(name="introspectionPostArgsClients")
    def introspection_post_args_clients(self) -> Optional[Sequence[str]]:
        """
        Extra post arguments passed from the client to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_clients")

    @property
    @pulumi.getter(name="introspectionPostArgsNames")
    def introspection_post_args_names(self) -> Optional[Sequence[str]]:
        """
        Extra post argument names passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_names")

    @property
    @pulumi.getter(name="introspectionPostArgsValues")
    def introspection_post_args_values(self) -> Optional[Sequence[str]]:
        """
        Extra post argument values passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_values")

    @property
    @pulumi.getter(name="introspectionTokenParamName")
    def introspection_token_param_name(self) -> Optional[str]:
        """
        Designate token's parameter name for introspection.
        """
        return pulumi.get(self, "introspection_token_param_name")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="issuersAlloweds")
    def issuers_alloweds(self) -> Optional[Sequence[str]]:
        """
        The issuers allowed to be present in the tokens (`iss` claim).
        """
        return pulumi.get(self, "issuers_alloweds")

    @property
    @pulumi.getter(name="jwtSessionClaim")
    def jwt_session_claim(self) -> Optional[str]:
        """
        The claim to match against the JWT session cookie.
        """
        return pulumi.get(self, "jwt_session_claim")

    @property
    @pulumi.getter(name="jwtSessionCookie")
    def jwt_session_cookie(self) -> Optional[str]:
        """
        The name of the JWT session cookie.
        """
        return pulumi.get(self, "jwt_session_cookie")

    @property
    @pulumi.getter
    def keepalive(self) -> Optional[bool]:
        """
        Use keepalive with the HTTP client.
        """
        return pulumi.get(self, "keepalive")

    @property
    @pulumi.getter
    def leeway(self) -> Optional[float]:
        """
        Defines leeway time (in seconds) for `auth_time`, `exp`, `iat`, and `nbf` claims
        """
        return pulumi.get(self, "leeway")

    @property
    @pulumi.getter(name="loginAction")
    def login_action(self) -> Optional[str]:
        """
        What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
        """
        return pulumi.get(self, "login_action")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Optional[Sequence[str]]:
        """
        Enable login functionality with specified grants.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter(name="loginRedirectMode")
    def login_redirect_mode(self) -> Optional[str]:
        """
        Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
        """
        return pulumi.get(self, "login_redirect_mode")

    @property
    @pulumi.getter(name="loginRedirectUris")
    def login_redirect_uris(self) -> Optional[Sequence[str]]:
        """
        Where to redirect the client when `login_action` is set to `redirect`.
        """
        return pulumi.get(self, "login_redirect_uris")

    @property
    @pulumi.getter(name="loginTokens")
    def login_tokens(self) -> Optional[Sequence[str]]:
        """
        What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
        """
        return pulumi.get(self, "login_tokens")

    @property
    @pulumi.getter(name="logoutMethods")
    def logout_methods(self) -> Optional[Sequence[str]]:
        """
        The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
        """
        return pulumi.get(self, "logout_methods")

    @property
    @pulumi.getter(name="logoutPostArg")
    def logout_post_arg(self) -> Optional[str]:
        """
        The request body argument that activates the logout.
        """
        return pulumi.get(self, "logout_post_arg")

    @property
    @pulumi.getter(name="logoutQueryArg")
    def logout_query_arg(self) -> Optional[str]:
        """
        The request query argument that activates the logout.
        """
        return pulumi.get(self, "logout_query_arg")

    @property
    @pulumi.getter(name="logoutRedirectUris")
    def logout_redirect_uris(self) -> Optional[Sequence[str]]:
        """
        Where to redirect the client after the logout.
        """
        return pulumi.get(self, "logout_redirect_uris")

    @property
    @pulumi.getter(name="logoutRevoke")
    def logout_revoke(self) -> Optional[bool]:
        """
        Revoke tokens as part of the logout.
        """
        return pulumi.get(self, "logout_revoke")

    @property
    @pulumi.getter(name="logoutRevokeAccessToken")
    def logout_revoke_access_token(self) -> Optional[bool]:
        """
        Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
        """
        return pulumi.get(self, "logout_revoke_access_token")

    @property
    @pulumi.getter(name="logoutRevokeRefreshToken")
    def logout_revoke_refresh_token(self) -> Optional[bool]:
        """
        Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
        """
        return pulumi.get(self, "logout_revoke_refresh_token")

    @property
    @pulumi.getter(name="logoutUriSuffix")
    def logout_uri_suffix(self) -> Optional[str]:
        """
        The request URI suffix that activates the logout.
        """
        return pulumi.get(self, "logout_uri_suffix")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[float]:
        """
        The maximum age (in seconds) compared to the `auth_time` claim.
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="mtlsIntrospectionEndpoint")
    def mtls_introspection_endpoint(self) -> Optional[str]:
        """
        Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_introspection_endpoint")

    @property
    @pulumi.getter(name="mtlsRevocationEndpoint")
    def mtls_revocation_endpoint(self) -> Optional[str]:
        """
        Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_revocation_endpoint")

    @property
    @pulumi.getter(name="mtlsTokenEndpoint")
    def mtls_token_endpoint(self) -> Optional[str]:
        """
        Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_token_endpoint")

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[str]:
        """
        Do not use proxy with these hosts.
        """
        return pulumi.get(self, "no_proxy")

    @property
    @pulumi.getter(name="passwordParamTypes")
    def password_param_types(self) -> Optional[Sequence[str]]:
        """
        Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "password_param_types")

    @property
    @pulumi.getter(name="preserveQueryArgs")
    def preserve_query_args(self) -> Optional[bool]:
        """
        With this parameter, you can preserve request query arguments even when doing authorization code flow.
        """
        return pulumi.get(self, "preserve_query_args")

    @property
    @pulumi.getter(name="proofOfPossessionAuthMethodsValidation")
    def proof_of_possession_auth_methods_validation(self) -> Optional[bool]:
        """
        If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
        """
        return pulumi.get(self, "proof_of_possession_auth_methods_validation")

    @property
    @pulumi.getter(name="proofOfPossessionDpop")
    def proof_of_possession_dpop(self) -> Optional[str]:
        """
        Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
        """
        return pulumi.get(self, "proof_of_possession_dpop")

    @property
    @pulumi.getter(name="proofOfPossessionMtls")
    def proof_of_possession_mtls(self) -> Optional[str]:
        """
        Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
        """
        return pulumi.get(self, "proof_of_possession_mtls")

    @property
    @pulumi.getter(name="pushedAuthorizationRequestEndpoint")
    def pushed_authorization_request_endpoint(self) -> Optional[str]:
        """
        The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "pushed_authorization_request_endpoint")

    @property
    @pulumi.getter(name="pushedAuthorizationRequestEndpointAuthMethod")
    def pushed_authorization_request_endpoint_auth_method(self) -> Optional[str]:
        """
        The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "pushed_authorization_request_endpoint_auth_method")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[str]]:
        """
        The redirect URI passed to the authorization and token endpoints.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="rediscoveryLifetime")
    def rediscovery_lifetime(self) -> Optional[float]:
        """
        Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
        """
        return pulumi.get(self, "rediscovery_lifetime")

    @property
    @pulumi.getter(name="refreshTokenParamName")
    def refresh_token_param_name(self) -> Optional[str]:
        """
        The name of the parameter used to pass the refresh token.
        """
        return pulumi.get(self, "refresh_token_param_name")

    @property
    @pulumi.getter(name="refreshTokenParamTypes")
    def refresh_token_param_types(self) -> Optional[Sequence[str]]:
        """
        Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "refresh_token_param_types")

    @property
    @pulumi.getter(name="refreshTokens")
    def refresh_tokens(self) -> Optional[bool]:
        """
        Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
        """
        return pulumi.get(self, "refresh_tokens")

    @property
    @pulumi.getter(name="requireProofKeyForCodeExchange")
    def require_proof_key_for_code_exchange(self) -> Optional[bool]:
        """
        Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
        """
        return pulumi.get(self, "require_proof_key_for_code_exchange")

    @property
    @pulumi.getter(name="requirePushedAuthorizationRequests")
    def require_pushed_authorization_requests(self) -> Optional[bool]:
        """
        Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
        """
        return pulumi.get(self, "require_pushed_authorization_requests")

    @property
    @pulumi.getter(name="requireSignedRequestObject")
    def require_signed_request_object(self) -> Optional[bool]:
        """
        Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `require_signed_request_object`, and enabled automatically (in case the `require_signed_request_object` is missing, the feature will not be enabled).
        """
        return pulumi.get(self, "require_signed_request_object")

    @property
    @pulumi.getter(name="resolveDistributedClaims")
    def resolve_distributed_claims(self) -> Optional[bool]:
        """
        Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
        """
        return pulumi.get(self, "resolve_distributed_claims")

    @property
    @pulumi.getter(name="responseMode")
    def response_mode(self) -> Optional[str]:
        """
        Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `form_post`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `form_post` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "form_post", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
        """
        return pulumi.get(self, "response_mode")

    @property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> Optional[Sequence[str]]:
        """
        The response type passed to the authorization endpoint.
        """
        return pulumi.get(self, "response_types")

    @property
    @pulumi.getter
    def reverify(self) -> Optional[bool]:
        """
        Specifies whether to always verify tokens stored in the session.
        """
        return pulumi.get(self, "reverify")

    @property
    @pulumi.getter(name="revocationEndpoint")
    def revocation_endpoint(self) -> Optional[str]:
        """
        The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "revocation_endpoint")

    @property
    @pulumi.getter(name="revocationEndpointAuthMethod")
    def revocation_endpoint_auth_method(self) -> Optional[str]:
        """
        The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "revocation_endpoint_auth_method")

    @property
    @pulumi.getter(name="revocationTokenParamName")
    def revocation_token_param_name(self) -> Optional[str]:
        """
        Designate token's parameter name for revocation.
        """
        return pulumi.get(self, "revocation_token_param_name")

    @property
    @pulumi.getter(name="rolesClaims")
    def roles_claims(self) -> Optional[Sequence[str]]:
        """
        The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "roles_claims")

    @property
    @pulumi.getter(name="rolesRequireds")
    def roles_requireds(self) -> Optional[Sequence[str]]:
        """
        The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "roles_requireds")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> Optional[bool]:
        """
        Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
        """
        return pulumi.get(self, "run_on_preflight")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The scopes passed to the authorization and token endpoints.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="scopesClaims")
    def scopes_claims(self) -> Optional[Sequence[str]]:
        """
        The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "scopes_claims")

    @property
    @pulumi.getter(name="scopesRequireds")
    def scopes_requireds(self) -> Optional[Sequence[str]]:
        """
        The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "scopes_requireds")

    @property
    @pulumi.getter(name="searchUserInfo")
    def search_user_info(self) -> Optional[bool]:
        """
        Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
        """
        return pulumi.get(self, "search_user_info")

    @property
    @pulumi.getter(name="sessionAbsoluteTimeout")
    def session_absolute_timeout(self) -> Optional[float]:
        """
        Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        """
        return pulumi.get(self, "session_absolute_timeout")

    @property
    @pulumi.getter(name="sessionAudience")
    def session_audience(self) -> Optional[str]:
        """
        The session audience, which is the intended target application. For example `"my-application"`.
        """
        return pulumi.get(self, "session_audience")

    @property
    @pulumi.getter(name="sessionCookieDomain")
    def session_cookie_domain(self) -> Optional[str]:
        """
        The session cookie Domain flag.
        """
        return pulumi.get(self, "session_cookie_domain")

    @property
    @pulumi.getter(name="sessionCookieHttpOnly")
    def session_cookie_http_only(self) -> Optional[bool]:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "session_cookie_http_only")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The session cookie name.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionCookiePath")
    def session_cookie_path(self) -> Optional[str]:
        """
        The session cookie Path flag.
        """
        return pulumi.get(self, "session_cookie_path")

    @property
    @pulumi.getter(name="sessionCookieSameSite")
    def session_cookie_same_site(self) -> Optional[str]:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "session_cookie_same_site")

    @property
    @pulumi.getter(name="sessionCookieSecure")
    def session_cookie_secure(self) -> Optional[bool]:
        """
        Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "session_cookie_secure")

    @property
    @pulumi.getter(name="sessionEnforceSameSubject")
    def session_enforce_same_subject(self) -> Optional[bool]:
        """
        When set to `true`, audiences are forced to share the same subject.
        """
        return pulumi.get(self, "session_enforce_same_subject")

    @property
    @pulumi.getter(name="sessionHashStorageKey")
    def session_hash_storage_key(self) -> Optional[bool]:
        """
        When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        """
        return pulumi.get(self, "session_hash_storage_key")

    @property
    @pulumi.getter(name="sessionHashSubject")
    def session_hash_subject(self) -> Optional[bool]:
        """
        When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        """
        return pulumi.get(self, "session_hash_subject")

    @property
    @pulumi.getter(name="sessionIdlingTimeout")
    def session_idling_timeout(self) -> Optional[float]:
        """
        Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
        """
        return pulumi.get(self, "session_idling_timeout")

    @property
    @pulumi.getter(name="sessionMemcachedHost")
    def session_memcached_host(self) -> Optional[str]:
        """
        The memcached host.
        """
        return pulumi.get(self, "session_memcached_host")

    @property
    @pulumi.getter(name="sessionMemcachedPort")
    def session_memcached_port(self) -> Optional[int]:
        """
        The memcached port.
        """
        return pulumi.get(self, "session_memcached_port")

    @property
    @pulumi.getter(name="sessionMemcachedPrefix")
    def session_memcached_prefix(self) -> Optional[str]:
        """
        The memcached session key prefix.
        """
        return pulumi.get(self, "session_memcached_prefix")

    @property
    @pulumi.getter(name="sessionMemcachedSocket")
    def session_memcached_socket(self) -> Optional[str]:
        """
        The memcached unix socket path.
        """
        return pulumi.get(self, "session_memcached_socket")

    @property
    @pulumi.getter(name="sessionRedisClusterMaxRedirections")
    def session_redis_cluster_max_redirections(self) -> Optional[int]:
        """
        The Redis cluster maximum redirects.
        """
        return pulumi.get(self, "session_redis_cluster_max_redirections")

    @property
    @pulumi.getter(name="sessionRedisClusterNodes")
    def session_redis_cluster_nodes(self) -> Optional[Sequence['outputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNode']]:
        """
        The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        """
        return pulumi.get(self, "session_redis_cluster_nodes")

    @property
    @pulumi.getter(name="sessionRedisConnectTimeout")
    def session_redis_connect_timeout(self) -> Optional[int]:
        """
        Session redis connection timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_connect_timeout")

    @property
    @pulumi.getter(name="sessionRedisHost")
    def session_redis_host(self) -> Optional[str]:
        """
        The Redis host.
        """
        return pulumi.get(self, "session_redis_host")

    @property
    @pulumi.getter(name="sessionRedisPassword")
    def session_redis_password(self) -> Optional[str]:
        """
        Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "session_redis_password")

    @property
    @pulumi.getter(name="sessionRedisPort")
    def session_redis_port(self) -> Optional[int]:
        """
        The Redis port.
        """
        return pulumi.get(self, "session_redis_port")

    @property
    @pulumi.getter(name="sessionRedisPrefix")
    def session_redis_prefix(self) -> Optional[str]:
        """
        The Redis session key prefix.
        """
        return pulumi.get(self, "session_redis_prefix")

    @property
    @pulumi.getter(name="sessionRedisReadTimeout")
    def session_redis_read_timeout(self) -> Optional[int]:
        """
        Session redis read timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_read_timeout")

    @property
    @pulumi.getter(name="sessionRedisSendTimeout")
    def session_redis_send_timeout(self) -> Optional[int]:
        """
        Session redis send timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_send_timeout")

    @property
    @pulumi.getter(name="sessionRedisServerName")
    def session_redis_server_name(self) -> Optional[str]:
        """
        The SNI used for connecting the Redis server.
        """
        return pulumi.get(self, "session_redis_server_name")

    @property
    @pulumi.getter(name="sessionRedisSocket")
    def session_redis_socket(self) -> Optional[str]:
        """
        The Redis unix socket path.
        """
        return pulumi.get(self, "session_redis_socket")

    @property
    @pulumi.getter(name="sessionRedisSsl")
    def session_redis_ssl(self) -> Optional[bool]:
        """
        Use SSL/TLS for Redis connection.
        """
        return pulumi.get(self, "session_redis_ssl")

    @property
    @pulumi.getter(name="sessionRedisSslVerify")
    def session_redis_ssl_verify(self) -> Optional[bool]:
        """
        Verify identity provider server certificate.
        """
        return pulumi.get(self, "session_redis_ssl_verify")

    @property
    @pulumi.getter(name="sessionRedisUsername")
    def session_redis_username(self) -> Optional[str]:
        """
        Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "session_redis_username")

    @property
    @pulumi.getter(name="sessionRemember")
    def session_remember(self) -> Optional[bool]:
        """
        Enables or disables persistent sessions.
        """
        return pulumi.get(self, "session_remember")

    @property
    @pulumi.getter(name="sessionRememberAbsoluteTimeout")
    def session_remember_absolute_timeout(self) -> Optional[float]:
        """
        Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        """
        return pulumi.get(self, "session_remember_absolute_timeout")

    @property
    @pulumi.getter(name="sessionRememberCookieName")
    def session_remember_cookie_name(self) -> Optional[str]:
        """
        Persistent session cookie name. Use with the `remember` configuration parameter.
        """
        return pulumi.get(self, "session_remember_cookie_name")

    @property
    @pulumi.getter(name="sessionRememberRollingTimeout")
    def session_remember_rolling_timeout(self) -> Optional[float]:
        """
        Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "session_remember_rolling_timeout")

    @property
    @pulumi.getter(name="sessionRequestHeaders")
    def session_request_headers(self) -> Optional[Sequence[str]]:
        """
        Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
        """
        return pulumi.get(self, "session_request_headers")

    @property
    @pulumi.getter(name="sessionResponseHeaders")
    def session_response_headers(self) -> Optional[Sequence[str]]:
        """
        Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
        """
        return pulumi.get(self, "session_response_headers")

    @property
    @pulumi.getter(name="sessionRollingTimeout")
    def session_rolling_timeout(self) -> Optional[float]:
        """
        Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "session_rolling_timeout")

    @property
    @pulumi.getter(name="sessionSecret")
    def session_secret(self) -> Optional[str]:
        """
        The session secret.
        """
        return pulumi.get(self, "session_secret")

    @property
    @pulumi.getter(name="sessionStorage")
    def session_storage(self) -> Optional[str]:
        """
        The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        """
        return pulumi.get(self, "session_storage")

    @property
    @pulumi.getter(name="sessionStoreMetadata")
    def session_store_metadata(self) -> Optional[bool]:
        """
        Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
        """
        return pulumi.get(self, "session_store_metadata")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> Optional[bool]:
        """
        Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `lua_ssl_trusted_certificate`.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        """
        Network IO timeout in milliseconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsClientAuthCertId")
    def tls_client_auth_cert_id(self) -> Optional[str]:
        """
        ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
        """
        return pulumi.get(self, "tls_client_auth_cert_id")

    @property
    @pulumi.getter(name="tlsClientAuthSslVerify")
    def tls_client_auth_ssl_verify(self) -> Optional[bool]:
        """
        Verify identity provider server certificate during mTLS client authentication.
        """
        return pulumi.get(self, "tls_client_auth_ssl_verify")

    @property
    @pulumi.getter(name="tokenCacheKeyIncludeScope")
    def token_cache_key_include_scope(self) -> Optional[bool]:
        """
        Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
        """
        return pulumi.get(self, "token_cache_key_include_scope")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> Optional[str]:
        """
        The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @property
    @pulumi.getter(name="tokenExchangeEndpoint")
    def token_exchange_endpoint(self) -> Optional[str]:
        """
        The token exchange endpoint.
        """
        return pulumi.get(self, "token_exchange_endpoint")

    @property
    @pulumi.getter(name="tokenHeadersClients")
    def token_headers_clients(self) -> Optional[Sequence[str]]:
        """
        Extra headers passed from the client to the token endpoint.
        """
        return pulumi.get(self, "token_headers_clients")

    @property
    @pulumi.getter(name="tokenHeadersGrants")
    def token_headers_grants(self) -> Optional[Sequence[str]]:
        """
        Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
        """
        return pulumi.get(self, "token_headers_grants")

    @property
    @pulumi.getter(name="tokenHeadersNames")
    def token_headers_names(self) -> Optional[Sequence[str]]:
        """
        Extra header names passed to the token endpoint.
        """
        return pulumi.get(self, "token_headers_names")

    @property
    @pulumi.getter(name="tokenHeadersPrefix")
    def token_headers_prefix(self) -> Optional[str]:
        """
        Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
        """
        return pulumi.get(self, "token_headers_prefix")

    @property
    @pulumi.getter(name="tokenHeadersReplays")
    def token_headers_replays(self) -> Optional[Sequence[str]]:
        """
        The names of token endpoint response headers to forward to the downstream client.
        """
        return pulumi.get(self, "token_headers_replays")

    @property
    @pulumi.getter(name="tokenHeadersValues")
    def token_headers_values(self) -> Optional[Sequence[str]]:
        """
        Extra header values passed to the token endpoint.
        """
        return pulumi.get(self, "token_headers_values")

    @property
    @pulumi.getter(name="tokenPostArgsClients")
    def token_post_args_clients(self) -> Optional[Sequence[str]]:
        """
        Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_clients")

    @property
    @pulumi.getter(name="tokenPostArgsNames")
    def token_post_args_names(self) -> Optional[Sequence[str]]:
        """
        Extra post argument names passed to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_names")

    @property
    @pulumi.getter(name="tokenPostArgsValues")
    def token_post_args_values(self) -> Optional[Sequence[str]]:
        """
        Extra post argument values passed to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_values")

    @property
    @pulumi.getter(name="unauthorizedDestroySession")
    def unauthorized_destroy_session(self) -> Optional[bool]:
        """
        Destroy any active session for the unauthorized requests.
        """
        return pulumi.get(self, "unauthorized_destroy_session")

    @property
    @pulumi.getter(name="unauthorizedErrorMessage")
    def unauthorized_error_message(self) -> Optional[str]:
        """
        The error message for the unauthorized requests (when not using the redirection).
        """
        return pulumi.get(self, "unauthorized_error_message")

    @property
    @pulumi.getter(name="unauthorizedRedirectUris")
    def unauthorized_redirect_uris(self) -> Optional[Sequence[str]]:
        """
        Where to redirect the client on unauthorized requests.
        """
        return pulumi.get(self, "unauthorized_redirect_uris")

    @property
    @pulumi.getter(name="unexpectedRedirectUris")
    def unexpected_redirect_uris(self) -> Optional[Sequence[str]]:
        """
        Where to redirect the client when unexpected errors happen with the requests.
        """
        return pulumi.get(self, "unexpected_redirect_uris")

    @property
    @pulumi.getter(name="upstreamAccessTokenHeader")
    def upstream_access_token_header(self) -> Optional[str]:
        """
        The upstream access token header.
        """
        return pulumi.get(self, "upstream_access_token_header")

    @property
    @pulumi.getter(name="upstreamAccessTokenJwkHeader")
    def upstream_access_token_jwk_header(self) -> Optional[str]:
        """
        The upstream access token JWK header.
        """
        return pulumi.get(self, "upstream_access_token_jwk_header")

    @property
    @pulumi.getter(name="upstreamHeadersClaims")
    def upstream_headers_claims(self) -> Optional[Sequence[str]]:
        """
        The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "upstream_headers_claims")

    @property
    @pulumi.getter(name="upstreamHeadersNames")
    def upstream_headers_names(self) -> Optional[Sequence[str]]:
        """
        The upstream header names for the claim values.
        """
        return pulumi.get(self, "upstream_headers_names")

    @property
    @pulumi.getter(name="upstreamIdTokenHeader")
    def upstream_id_token_header(self) -> Optional[str]:
        """
        The upstream id token header.
        """
        return pulumi.get(self, "upstream_id_token_header")

    @property
    @pulumi.getter(name="upstreamIdTokenJwkHeader")
    def upstream_id_token_jwk_header(self) -> Optional[str]:
        """
        The upstream id token JWK header.
        """
        return pulumi.get(self, "upstream_id_token_jwk_header")

    @property
    @pulumi.getter(name="upstreamIntrospectionHeader")
    def upstream_introspection_header(self) -> Optional[str]:
        """
        The upstream introspection header.
        """
        return pulumi.get(self, "upstream_introspection_header")

    @property
    @pulumi.getter(name="upstreamIntrospectionJwtHeader")
    def upstream_introspection_jwt_header(self) -> Optional[str]:
        """
        The upstream introspection JWT header.
        """
        return pulumi.get(self, "upstream_introspection_jwt_header")

    @property
    @pulumi.getter(name="upstreamRefreshTokenHeader")
    def upstream_refresh_token_header(self) -> Optional[str]:
        """
        The upstream refresh token header.
        """
        return pulumi.get(self, "upstream_refresh_token_header")

    @property
    @pulumi.getter(name="upstreamSessionIdHeader")
    def upstream_session_id_header(self) -> Optional[str]:
        """
        The upstream session id header.
        """
        return pulumi.get(self, "upstream_session_id_header")

    @property
    @pulumi.getter(name="upstreamUserInfoHeader")
    def upstream_user_info_header(self) -> Optional[str]:
        """
        The upstream user info header.
        """
        return pulumi.get(self, "upstream_user_info_header")

    @property
    @pulumi.getter(name="upstreamUserInfoJwtHeader")
    def upstream_user_info_jwt_header(self) -> Optional[str]:
        """
        The upstream user info JWT header (in case the user info returns a JWT response).
        """
        return pulumi.get(self, "upstream_user_info_jwt_header")

    @property
    @pulumi.getter(name="userinfoAccept")
    def userinfo_accept(self) -> Optional[str]:
        """
        The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
        """
        return pulumi.get(self, "userinfo_accept")

    @property
    @pulumi.getter(name="userinfoEndpoint")
    def userinfo_endpoint(self) -> Optional[str]:
        """
        The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "userinfo_endpoint")

    @property
    @pulumi.getter(name="userinfoHeadersClients")
    def userinfo_headers_clients(self) -> Optional[Sequence[str]]:
        """
        Extra headers passed from the client to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_clients")

    @property
    @pulumi.getter(name="userinfoHeadersNames")
    def userinfo_headers_names(self) -> Optional[Sequence[str]]:
        """
        Extra header names passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_names")

    @property
    @pulumi.getter(name="userinfoHeadersValues")
    def userinfo_headers_values(self) -> Optional[Sequence[str]]:
        """
        Extra header values passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_values")

    @property
    @pulumi.getter(name="userinfoQueryArgsClients")
    def userinfo_query_args_clients(self) -> Optional[Sequence[str]]:
        """
        Extra query arguments passed from the client to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_clients")

    @property
    @pulumi.getter(name="userinfoQueryArgsNames")
    def userinfo_query_args_names(self) -> Optional[Sequence[str]]:
        """
        Extra query argument names passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_names")

    @property
    @pulumi.getter(name="userinfoQueryArgsValues")
    def userinfo_query_args_values(self) -> Optional[Sequence[str]]:
        """
        Extra query argument values passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_values")

    @property
    @pulumi.getter(name="usingPseudoIssuer")
    def using_pseudo_issuer(self) -> Optional[bool]:
        """
        If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
        """
        return pulumi.get(self, "using_pseudo_issuer")

    @property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[bool]:
        """
        Verify tokens for standard claims.
        """
        return pulumi.get(self, "verify_claims")

    @property
    @pulumi.getter(name="verifyNonce")
    def verify_nonce(self) -> Optional[bool]:
        """
        Verify nonce on authorization code flow.
        """
        return pulumi.get(self, "verify_nonce")

    @property
    @pulumi.getter(name="verifyParameters")
    def verify_parameters(self) -> Optional[bool]:
        """
        Verify plugin configuration against discovery.
        """
        return pulumi.get(self, "verify_parameters")

    @property
    @pulumi.getter(name="verifySignature")
    def verify_signature(self) -> Optional[bool]:
        """
        Verify signature of tokens.
        """
        return pulumi.get(self, "verify_signature")


@pulumi.output_type
class GatewayPluginOpenidConnectConfigClientJwk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyOps":
            suggest = "key_ops"
        elif key == "x5tNumberS256":
            suggest = "x5t_number_s256"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOpenidConnectConfigClientJwk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOpenidConnectConfigClientJwk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOpenidConnectConfigClientJwk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alg: Optional[str] = None,
                 crv: Optional[str] = None,
                 d: Optional[str] = None,
                 dp: Optional[str] = None,
                 dq: Optional[str] = None,
                 e: Optional[str] = None,
                 issuer: Optional[str] = None,
                 k: Optional[str] = None,
                 key_ops: Optional[Sequence[str]] = None,
                 kid: Optional[str] = None,
                 kty: Optional[str] = None,
                 n: Optional[str] = None,
                 oth: Optional[str] = None,
                 p: Optional[str] = None,
                 q: Optional[str] = None,
                 qi: Optional[str] = None,
                 r: Optional[str] = None,
                 t: Optional[str] = None,
                 use: Optional[str] = None,
                 x: Optional[str] = None,
                 x5cs: Optional[Sequence[str]] = None,
                 x5t: Optional[str] = None,
                 x5t_number_s256: Optional[str] = None,
                 x5u: Optional[str] = None,
                 y: Optional[str] = None):
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if crv is not None:
            pulumi.set(__self__, "crv", crv)
        if d is not None:
            pulumi.set(__self__, "d", d)
        if dp is not None:
            pulumi.set(__self__, "dp", dp)
        if dq is not None:
            pulumi.set(__self__, "dq", dq)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if oth is not None:
            pulumi.set(__self__, "oth", oth)
        if p is not None:
            pulumi.set(__self__, "p", p)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if qi is not None:
            pulumi.set(__self__, "qi", qi)
        if r is not None:
            pulumi.set(__self__, "r", r)
        if t is not None:
            pulumi.set(__self__, "t", t)
        if use is not None:
            pulumi.set(__self__, "use", use)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x5cs is not None:
            pulumi.set(__self__, "x5cs", x5cs)
        if x5t is not None:
            pulumi.set(__self__, "x5t", x5t)
        if x5t_number_s256 is not None:
            pulumi.set(__self__, "x5t_number_s256", x5t_number_s256)
        if x5u is not None:
            pulumi.set(__self__, "x5u", x5u)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def alg(self) -> Optional[str]:
        return pulumi.get(self, "alg")

    @property
    @pulumi.getter
    def crv(self) -> Optional[str]:
        return pulumi.get(self, "crv")

    @property
    @pulumi.getter
    def d(self) -> Optional[str]:
        return pulumi.get(self, "d")

    @property
    @pulumi.getter
    def dp(self) -> Optional[str]:
        return pulumi.get(self, "dp")

    @property
    @pulumi.getter
    def dq(self) -> Optional[str]:
        return pulumi.get(self, "dq")

    @property
    @pulumi.getter
    def e(self) -> Optional[str]:
        return pulumi.get(self, "e")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def k(self) -> Optional[str]:
        return pulumi.get(self, "k")

    @property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "key_ops")

    @property
    @pulumi.getter
    def kid(self) -> Optional[str]:
        return pulumi.get(self, "kid")

    @property
    @pulumi.getter
    def kty(self) -> Optional[str]:
        return pulumi.get(self, "kty")

    @property
    @pulumi.getter
    def n(self) -> Optional[str]:
        return pulumi.get(self, "n")

    @property
    @pulumi.getter
    def oth(self) -> Optional[str]:
        return pulumi.get(self, "oth")

    @property
    @pulumi.getter
    def p(self) -> Optional[str]:
        return pulumi.get(self, "p")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def qi(self) -> Optional[str]:
        return pulumi.get(self, "qi")

    @property
    @pulumi.getter
    def r(self) -> Optional[str]:
        return pulumi.get(self, "r")

    @property
    @pulumi.getter
    def t(self) -> Optional[str]:
        return pulumi.get(self, "t")

    @property
    @pulumi.getter
    def use(self) -> Optional[str]:
        return pulumi.get(self, "use")

    @property
    @pulumi.getter
    def x(self) -> Optional[str]:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def x5cs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "x5cs")

    @property
    @pulumi.getter
    def x5t(self) -> Optional[str]:
        return pulumi.get(self, "x5t")

    @property
    @pulumi.getter(name="x5tNumberS256")
    def x5t_number_s256(self) -> Optional[str]:
        return pulumi.get(self, "x5t_number_s256")

    @property
    @pulumi.getter
    def x5u(self) -> Optional[str]:
        return pulumi.get(self, "x5u")

    @property
    @pulumi.getter
    def y(self) -> Optional[str]:
        return pulumi.get(self, "y")


@pulumi.output_type
class GatewayPluginOpenidConnectConfigSessionRedisClusterNode(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str ip: A string representing a host name, such as example.com.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayPluginOpenidConnectConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpenidConnectConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpenidConnectRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpenidConnectService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpentelemetryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchFlushDelay":
            suggest = "batch_flush_delay"
        elif key == "batchSpanCount":
            suggest = "batch_span_count"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "headerType":
            suggest = "header_type"
        elif key == "httpResponseHeaderForTraceid":
            suggest = "http_response_header_for_traceid"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "resourceAttributes":
            suggest = "resource_attributes"
        elif key == "samplingRate":
            suggest = "sampling_rate"
        elif key == "sendTimeout":
            suggest = "send_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOpentelemetryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOpentelemetryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOpentelemetryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_flush_delay: Optional[int] = None,
                 batch_span_count: Optional[int] = None,
                 connect_timeout: Optional[int] = None,
                 endpoint: Optional[str] = None,
                 header_type: Optional[str] = None,
                 headers: Optional[Mapping[str, str]] = None,
                 http_response_header_for_traceid: Optional[str] = None,
                 propagation: Optional['outputs.GatewayPluginOpentelemetryConfigPropagation'] = None,
                 queue: Optional['outputs.GatewayPluginOpentelemetryConfigQueue'] = None,
                 read_timeout: Optional[int] = None,
                 resource_attributes: Optional[Mapping[str, str]] = None,
                 sampling_rate: Optional[float] = None,
                 send_timeout: Optional[int] = None):
        """
        :param int batch_flush_delay: The delay, in seconds, between two consecutive batches.
        :param int batch_span_count: The number of spans to be sent in a single batch.
        :param int connect_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str endpoint: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str header_type: must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
        :param Mapping[str, str] headers: The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
        :param int read_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param float sampling_rate: Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracing_sampling_rate` setting from kong.conf.
        :param int send_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        if batch_flush_delay is not None:
            pulumi.set(__self__, "batch_flush_delay", batch_flush_delay)
        if batch_span_count is not None:
            pulumi.set(__self__, "batch_span_count", batch_span_count)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if header_type is not None:
            pulumi.set(__self__, "header_type", header_type)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_response_header_for_traceid is not None:
            pulumi.set(__self__, "http_response_header_for_traceid", http_response_header_for_traceid)
        if propagation is not None:
            pulumi.set(__self__, "propagation", propagation)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if resource_attributes is not None:
            pulumi.set(__self__, "resource_attributes", resource_attributes)
        if sampling_rate is not None:
            pulumi.set(__self__, "sampling_rate", sampling_rate)
        if send_timeout is not None:
            pulumi.set(__self__, "send_timeout", send_timeout)

    @property
    @pulumi.getter(name="batchFlushDelay")
    def batch_flush_delay(self) -> Optional[int]:
        """
        The delay, in seconds, between two consecutive batches.
        """
        return pulumi.get(self, "batch_flush_delay")

    @property
    @pulumi.getter(name="batchSpanCount")
    def batch_span_count(self) -> Optional[int]:
        """
        The number of spans to be sent in a single batch.
        """
        return pulumi.get(self, "batch_span_count")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="headerType")
    def header_type(self) -> Optional[str]:
        """
        must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
        """
        return pulumi.get(self, "header_type")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="httpResponseHeaderForTraceid")
    def http_response_header_for_traceid(self) -> Optional[str]:
        return pulumi.get(self, "http_response_header_for_traceid")

    @property
    @pulumi.getter
    def propagation(self) -> Optional['outputs.GatewayPluginOpentelemetryConfigPropagation']:
        return pulumi.get(self, "propagation")

    @property
    @pulumi.getter
    def queue(self) -> Optional['outputs.GatewayPluginOpentelemetryConfigQueue']:
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="resourceAttributes")
    def resource_attributes(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "resource_attributes")

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> Optional[float]:
        """
        Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracing_sampling_rate` setting from kong.conf.
        """
        return pulumi.get(self, "sampling_rate")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "send_timeout")


@pulumi.output_type
class GatewayPluginOpentelemetryConfigPropagation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultFormat":
            suggest = "default_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOpentelemetryConfigPropagation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOpentelemetryConfigPropagation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOpentelemetryConfigPropagation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clears: Optional[Sequence[str]] = None,
                 default_format: Optional[str] = None,
                 extracts: Optional[Sequence[str]] = None,
                 injects: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] clears: Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
        :param str default_format: The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. Not Null; must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
        :param Sequence[str] extracts: Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
        :param Sequence[str] injects: Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
        """
        if clears is not None:
            pulumi.set(__self__, "clears", clears)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if extracts is not None:
            pulumi.set(__self__, "extracts", extracts)
        if injects is not None:
            pulumi.set(__self__, "injects", injects)

    @property
    @pulumi.getter
    def clears(self) -> Optional[Sequence[str]]:
        """
        Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
        """
        return pulumi.get(self, "clears")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        """
        The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. Not Null; must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
        """
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def extracts(self) -> Optional[Sequence[str]]:
        """
        Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
        """
        return pulumi.get(self, "extracts")

    @property
    @pulumi.getter
    def injects(self) -> Optional[Sequence[str]]:
        """
        Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
        """
        return pulumi.get(self, "injects")


@pulumi.output_type
class GatewayPluginOpentelemetryConfigQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialRetryDelay":
            suggest = "initial_retry_delay"
        elif key == "maxBatchSize":
            suggest = "max_batch_size"
        elif key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCoalescingDelay":
            suggest = "max_coalescing_delay"
        elif key == "maxEntries":
            suggest = "max_entries"
        elif key == "maxRetryDelay":
            suggest = "max_retry_delay"
        elif key == "maxRetryTime":
            suggest = "max_retry_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginOpentelemetryConfigQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginOpentelemetryConfigQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginOpentelemetryConfigQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_retry_delay: Optional[float] = None,
                 max_batch_size: Optional[int] = None,
                 max_bytes: Optional[int] = None,
                 max_coalescing_delay: Optional[float] = None,
                 max_entries: Optional[int] = None,
                 max_retry_delay: Optional[float] = None,
                 max_retry_time: Optional[float] = None):
        """
        :param float initial_retry_delay: Time in seconds before the initial retry is made for a failing batch.
        :param int max_batch_size: Maximum number of entries that can be processed at a time.
        :param int max_bytes: Maximum number of bytes that can be waiting on a queue, requires string content.
        :param float max_coalescing_delay: Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        :param int max_entries: Maximum number of entries that can be waiting on the queue.
        :param float max_retry_delay: Maximum time in seconds between retries, caps exponential backoff.
        :param float max_retry_time: Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        if initial_retry_delay is not None:
            pulumi.set(__self__, "initial_retry_delay", initial_retry_delay)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_coalescing_delay is not None:
            pulumi.set(__self__, "max_coalescing_delay", max_coalescing_delay)
        if max_entries is not None:
            pulumi.set(__self__, "max_entries", max_entries)
        if max_retry_delay is not None:
            pulumi.set(__self__, "max_retry_delay", max_retry_delay)
        if max_retry_time is not None:
            pulumi.set(__self__, "max_retry_time", max_retry_time)

    @property
    @pulumi.getter(name="initialRetryDelay")
    def initial_retry_delay(self) -> Optional[float]:
        """
        Time in seconds before the initial retry is made for a failing batch.
        """
        return pulumi.get(self, "initial_retry_delay")

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[int]:
        """
        Maximum number of entries that can be processed at a time.
        """
        return pulumi.get(self, "max_batch_size")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[int]:
        """
        Maximum number of bytes that can be waiting on a queue, requires string content.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxCoalescingDelay")
    def max_coalescing_delay(self) -> Optional[float]:
        """
        Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        """
        return pulumi.get(self, "max_coalescing_delay")

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> Optional[int]:
        """
        Maximum number of entries that can be waiting on the queue.
        """
        return pulumi.get(self, "max_entries")

    @property
    @pulumi.getter(name="maxRetryDelay")
    def max_retry_delay(self) -> Optional[float]:
        """
        Maximum time in seconds between retries, caps exponential backoff.
        """
        return pulumi.get(self, "max_retry_delay")

    @property
    @pulumi.getter(name="maxRetryTime")
    def max_retry_time(self) -> Optional[float]:
        """
        Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        return pulumi.get(self, "max_retry_time")


@pulumi.output_type
class GatewayPluginOpentelemetryConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpentelemetryConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpentelemetryRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginOpentelemetryService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPostFunctionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyFilters":
            suggest = "body_filters"
        elif key == "headerFilters":
            suggest = "header_filters"
        elif key == "wsClientFrames":
            suggest = "ws_client_frames"
        elif key == "wsCloses":
            suggest = "ws_closes"
        elif key == "wsHandshakes":
            suggest = "ws_handshakes"
        elif key == "wsUpstreamFrames":
            suggest = "ws_upstream_frames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginPostFunctionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginPostFunctionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginPostFunctionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accesses: Optional[Sequence[str]] = None,
                 body_filters: Optional[Sequence[str]] = None,
                 certificates: Optional[Sequence[str]] = None,
                 header_filters: Optional[Sequence[str]] = None,
                 logs: Optional[Sequence[str]] = None,
                 rewrites: Optional[Sequence[str]] = None,
                 ws_client_frames: Optional[Sequence[str]] = None,
                 ws_closes: Optional[Sequence[str]] = None,
                 ws_handshakes: Optional[Sequence[str]] = None,
                 ws_upstream_frames: Optional[Sequence[str]] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if body_filters is not None:
            pulumi.set(__self__, "body_filters", body_filters)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if header_filters is not None:
            pulumi.set(__self__, "header_filters", header_filters)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if rewrites is not None:
            pulumi.set(__self__, "rewrites", rewrites)
        if ws_client_frames is not None:
            pulumi.set(__self__, "ws_client_frames", ws_client_frames)
        if ws_closes is not None:
            pulumi.set(__self__, "ws_closes", ws_closes)
        if ws_handshakes is not None:
            pulumi.set(__self__, "ws_handshakes", ws_handshakes)
        if ws_upstream_frames is not None:
            pulumi.set(__self__, "ws_upstream_frames", ws_upstream_frames)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="bodyFilters")
    def body_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "body_filters")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="headerFilters")
    def header_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "header_filters")

    @property
    @pulumi.getter
    def logs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def rewrites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter(name="wsClientFrames")
    def ws_client_frames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_client_frames")

    @property
    @pulumi.getter(name="wsCloses")
    def ws_closes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_closes")

    @property
    @pulumi.getter(name="wsHandshakes")
    def ws_handshakes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_handshakes")

    @property
    @pulumi.getter(name="wsUpstreamFrames")
    def ws_upstream_frames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_upstream_frames")


@pulumi.output_type
class GatewayPluginPostFunctionConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPostFunctionConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPostFunctionRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPostFunctionService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPreFunctionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyFilters":
            suggest = "body_filters"
        elif key == "headerFilters":
            suggest = "header_filters"
        elif key == "wsClientFrames":
            suggest = "ws_client_frames"
        elif key == "wsCloses":
            suggest = "ws_closes"
        elif key == "wsHandshakes":
            suggest = "ws_handshakes"
        elif key == "wsUpstreamFrames":
            suggest = "ws_upstream_frames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginPreFunctionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginPreFunctionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginPreFunctionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accesses: Optional[Sequence[str]] = None,
                 body_filters: Optional[Sequence[str]] = None,
                 certificates: Optional[Sequence[str]] = None,
                 header_filters: Optional[Sequence[str]] = None,
                 logs: Optional[Sequence[str]] = None,
                 rewrites: Optional[Sequence[str]] = None,
                 ws_client_frames: Optional[Sequence[str]] = None,
                 ws_closes: Optional[Sequence[str]] = None,
                 ws_handshakes: Optional[Sequence[str]] = None,
                 ws_upstream_frames: Optional[Sequence[str]] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if body_filters is not None:
            pulumi.set(__self__, "body_filters", body_filters)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if header_filters is not None:
            pulumi.set(__self__, "header_filters", header_filters)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if rewrites is not None:
            pulumi.set(__self__, "rewrites", rewrites)
        if ws_client_frames is not None:
            pulumi.set(__self__, "ws_client_frames", ws_client_frames)
        if ws_closes is not None:
            pulumi.set(__self__, "ws_closes", ws_closes)
        if ws_handshakes is not None:
            pulumi.set(__self__, "ws_handshakes", ws_handshakes)
        if ws_upstream_frames is not None:
            pulumi.set(__self__, "ws_upstream_frames", ws_upstream_frames)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="bodyFilters")
    def body_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "body_filters")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="headerFilters")
    def header_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "header_filters")

    @property
    @pulumi.getter
    def logs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def rewrites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter(name="wsClientFrames")
    def ws_client_frames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_client_frames")

    @property
    @pulumi.getter(name="wsCloses")
    def ws_closes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_closes")

    @property
    @pulumi.getter(name="wsHandshakes")
    def ws_handshakes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_handshakes")

    @property
    @pulumi.getter(name="wsUpstreamFrames")
    def ws_upstream_frames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ws_upstream_frames")


@pulumi.output_type
class GatewayPluginPreFunctionConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPreFunctionConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPreFunctionRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPreFunctionService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPrometheusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthMetrics":
            suggest = "bandwidth_metrics"
        elif key == "latencyMetrics":
            suggest = "latency_metrics"
        elif key == "perConsumer":
            suggest = "per_consumer"
        elif key == "statusCodeMetrics":
            suggest = "status_code_metrics"
        elif key == "upstreamHealthMetrics":
            suggest = "upstream_health_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginPrometheusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginPrometheusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginPrometheusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_metrics: Optional[bool] = None,
                 latency_metrics: Optional[bool] = None,
                 per_consumer: Optional[bool] = None,
                 status_code_metrics: Optional[bool] = None,
                 upstream_health_metrics: Optional[bool] = None):
        """
        :param bool bandwidth_metrics: A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidth_bytes` and `stream_sessions_total` metrics will be exported.
        :param bool latency_metrics: A boolean value that determines if latency metrics should be collected. If enabled, `kong_latency_ms`, `upstream_latency_ms` and `request_latency_ms` metrics will be exported.
        :param bool per_consumer: A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kong_http_requests_total` and `kong_bandwidth_bytes` metrics fill in the consumer label when available.
        :param bool status_code_metrics: A boolean value that determines if status code metrics should be collected. If enabled, `http_requests_total`, `stream_sessions_total` metrics will be exported.
        :param bool upstream_health_metrics: A boolean value that determines if upstream metrics should be collected. If enabled, `upstream_target_health` metric will be exported.
        """
        if bandwidth_metrics is not None:
            pulumi.set(__self__, "bandwidth_metrics", bandwidth_metrics)
        if latency_metrics is not None:
            pulumi.set(__self__, "latency_metrics", latency_metrics)
        if per_consumer is not None:
            pulumi.set(__self__, "per_consumer", per_consumer)
        if status_code_metrics is not None:
            pulumi.set(__self__, "status_code_metrics", status_code_metrics)
        if upstream_health_metrics is not None:
            pulumi.set(__self__, "upstream_health_metrics", upstream_health_metrics)

    @property
    @pulumi.getter(name="bandwidthMetrics")
    def bandwidth_metrics(self) -> Optional[bool]:
        """
        A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidth_bytes` and `stream_sessions_total` metrics will be exported.
        """
        return pulumi.get(self, "bandwidth_metrics")

    @property
    @pulumi.getter(name="latencyMetrics")
    def latency_metrics(self) -> Optional[bool]:
        """
        A boolean value that determines if latency metrics should be collected. If enabled, `kong_latency_ms`, `upstream_latency_ms` and `request_latency_ms` metrics will be exported.
        """
        return pulumi.get(self, "latency_metrics")

    @property
    @pulumi.getter(name="perConsumer")
    def per_consumer(self) -> Optional[bool]:
        """
        A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kong_http_requests_total` and `kong_bandwidth_bytes` metrics fill in the consumer label when available.
        """
        return pulumi.get(self, "per_consumer")

    @property
    @pulumi.getter(name="statusCodeMetrics")
    def status_code_metrics(self) -> Optional[bool]:
        """
        A boolean value that determines if status code metrics should be collected. If enabled, `http_requests_total`, `stream_sessions_total` metrics will be exported.
        """
        return pulumi.get(self, "status_code_metrics")

    @property
    @pulumi.getter(name="upstreamHealthMetrics")
    def upstream_health_metrics(self) -> Optional[bool]:
        """
        A boolean value that determines if upstream metrics should be collected. If enabled, `upstream_target_health` metric will be exported.
        """
        return pulumi.get(self, "upstream_health_metrics")


@pulumi.output_type
class GatewayPluginPrometheusConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPrometheusConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPrometheusRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginPrometheusService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginProxyCacheConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheControl":
            suggest = "cache_control"
        elif key == "cacheTtl":
            suggest = "cache_ttl"
        elif key == "contentTypes":
            suggest = "content_types"
        elif key == "ignoreUriCase":
            suggest = "ignore_uri_case"
        elif key == "requestMethods":
            suggest = "request_methods"
        elif key == "responseCodes":
            suggest = "response_codes"
        elif key == "responseHeaders":
            suggest = "response_headers"
        elif key == "storageTtl":
            suggest = "storage_ttl"
        elif key == "varyHeaders":
            suggest = "vary_headers"
        elif key == "varyQueryParams":
            suggest = "vary_query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginProxyCacheConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginProxyCacheConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginProxyCacheConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_control: Optional[bool] = None,
                 cache_ttl: Optional[int] = None,
                 content_types: Optional[Sequence[str]] = None,
                 ignore_uri_case: Optional[bool] = None,
                 memory: Optional['outputs.GatewayPluginProxyCacheConfigMemory'] = None,
                 request_methods: Optional[Sequence[str]] = None,
                 response_codes: Optional[Sequence[int]] = None,
                 response_headers: Optional['outputs.GatewayPluginProxyCacheConfigResponseHeaders'] = None,
                 storage_ttl: Optional[int] = None,
                 strategy: Optional[str] = None,
                 vary_headers: Optional[Sequence[str]] = None,
                 vary_query_params: Optional[Sequence[str]] = None):
        """
        :param bool cache_control: When enabled, respect the Cache-Control behaviors defined in RFC7234.
        :param int cache_ttl: TTL, in seconds, of cache entities.
        :param Sequence[str] content_types: Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
        :param Sequence[str] request_methods: Downstream request methods considered cacheable.
        :param Sequence[int] response_codes: Upstream response status code considered cacheable.
        :param 'GatewayPluginProxyCacheConfigResponseHeadersArgs' response_headers: Caching related diagnostic headers that should be included in cached responses
        :param int storage_ttl: Number of seconds to keep resources in the storage backend. This value is independent of `cache_ttl` or resource TTLs defined by Cache-Control behaviors.
        :param str strategy: The backing data store in which to hold cache entities. must be one of ["memory"]
        :param Sequence[str] vary_headers: Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
        :param Sequence[str] vary_query_params: Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
        """
        if cache_control is not None:
            pulumi.set(__self__, "cache_control", cache_control)
        if cache_ttl is not None:
            pulumi.set(__self__, "cache_ttl", cache_ttl)
        if content_types is not None:
            pulumi.set(__self__, "content_types", content_types)
        if ignore_uri_case is not None:
            pulumi.set(__self__, "ignore_uri_case", ignore_uri_case)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if request_methods is not None:
            pulumi.set(__self__, "request_methods", request_methods)
        if response_codes is not None:
            pulumi.set(__self__, "response_codes", response_codes)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if storage_ttl is not None:
            pulumi.set(__self__, "storage_ttl", storage_ttl)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if vary_headers is not None:
            pulumi.set(__self__, "vary_headers", vary_headers)
        if vary_query_params is not None:
            pulumi.set(__self__, "vary_query_params", vary_query_params)

    @property
    @pulumi.getter(name="cacheControl")
    def cache_control(self) -> Optional[bool]:
        """
        When enabled, respect the Cache-Control behaviors defined in RFC7234.
        """
        return pulumi.get(self, "cache_control")

    @property
    @pulumi.getter(name="cacheTtl")
    def cache_ttl(self) -> Optional[int]:
        """
        TTL, in seconds, of cache entities.
        """
        return pulumi.get(self, "cache_ttl")

    @property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Optional[Sequence[str]]:
        """
        Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
        """
        return pulumi.get(self, "content_types")

    @property
    @pulumi.getter(name="ignoreUriCase")
    def ignore_uri_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_uri_case")

    @property
    @pulumi.getter
    def memory(self) -> Optional['outputs.GatewayPluginProxyCacheConfigMemory']:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Optional[Sequence[str]]:
        """
        Downstream request methods considered cacheable.
        """
        return pulumi.get(self, "request_methods")

    @property
    @pulumi.getter(name="responseCodes")
    def response_codes(self) -> Optional[Sequence[int]]:
        """
        Upstream response status code considered cacheable.
        """
        return pulumi.get(self, "response_codes")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional['outputs.GatewayPluginProxyCacheConfigResponseHeaders']:
        """
        Caching related diagnostic headers that should be included in cached responses
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="storageTtl")
    def storage_ttl(self) -> Optional[int]:
        """
        Number of seconds to keep resources in the storage backend. This value is independent of `cache_ttl` or resource TTLs defined by Cache-Control behaviors.
        """
        return pulumi.get(self, "storage_ttl")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The backing data store in which to hold cache entities. must be one of ["memory"]
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="varyHeaders")
    def vary_headers(self) -> Optional[Sequence[str]]:
        """
        Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
        """
        return pulumi.get(self, "vary_headers")

    @property
    @pulumi.getter(name="varyQueryParams")
    def vary_query_params(self) -> Optional[Sequence[str]]:
        """
        Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
        """
        return pulumi.get(self, "vary_query_params")


@pulumi.output_type
class GatewayPluginProxyCacheConfigMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dictionaryName":
            suggest = "dictionary_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginProxyCacheConfigMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginProxyCacheConfigMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginProxyCacheConfigMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dictionary_name: Optional[str] = None):
        """
        :param str dictionary_name: The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
        """
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)

    @property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[str]:
        """
        The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
        """
        return pulumi.get(self, "dictionary_name")


@pulumi.output_type
class GatewayPluginProxyCacheConfigResponseHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xCacheKey":
            suggest = "x_cache_key"
        elif key == "xCacheStatus":
            suggest = "x_cache_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginProxyCacheConfigResponseHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginProxyCacheConfigResponseHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginProxyCacheConfigResponseHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 age: Optional[bool] = None,
                 x_cache_key: Optional[bool] = None,
                 x_cache_status: Optional[bool] = None):
        if age is not None:
            pulumi.set(__self__, "age", age)
        if x_cache_key is not None:
            pulumi.set(__self__, "x_cache_key", x_cache_key)
        if x_cache_status is not None:
            pulumi.set(__self__, "x_cache_status", x_cache_status)

    @property
    @pulumi.getter
    def age(self) -> Optional[bool]:
        return pulumi.get(self, "age")

    @property
    @pulumi.getter(name="xCacheKey")
    def x_cache_key(self) -> Optional[bool]:
        return pulumi.get(self, "x_cache_key")

    @property
    @pulumi.getter(name="xCacheStatus")
    def x_cache_status(self) -> Optional[bool]:
        return pulumi.get(self, "x_cache_status")


@pulumi.output_type
class GatewayPluginProxyCacheConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginProxyCacheConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginProxyCacheRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginProxyCacheService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroups":
            suggest = "consumer_groups"
        elif key == "dictionaryName":
            suggest = "dictionary_name"
        elif key == "disablePenalty":
            suggest = "disable_penalty"
        elif key == "enforceConsumerGroups":
            suggest = "enforce_consumer_groups"
        elif key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "hideClientHeaders":
            suggest = "hide_client_headers"
        elif key == "retryAfterJitterMax":
            suggest = "retry_after_jitter_max"
        elif key == "syncRate":
            suggest = "sync_rate"
        elif key == "windowSizes":
            suggest = "window_sizes"
        elif key == "windowType":
            suggest = "window_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRateLimitingAdvancedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRateLimitingAdvancedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRateLimitingAdvancedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_groups: Optional[Sequence[str]] = None,
                 dictionary_name: Optional[str] = None,
                 disable_penalty: Optional[bool] = None,
                 enforce_consumer_groups: Optional[bool] = None,
                 error_code: Optional[float] = None,
                 error_message: Optional[str] = None,
                 header_name: Optional[str] = None,
                 hide_client_headers: Optional[bool] = None,
                 identifier: Optional[str] = None,
                 limits: Optional[Sequence[float]] = None,
                 namespace: Optional[str] = None,
                 path: Optional[str] = None,
                 redis: Optional['outputs.GatewayPluginRateLimitingAdvancedConfigRedis'] = None,
                 retry_after_jitter_max: Optional[float] = None,
                 strategy: Optional[str] = None,
                 sync_rate: Optional[float] = None,
                 window_sizes: Optional[Sequence[float]] = None,
                 window_type: Optional[str] = None):
        """
        :param Sequence[str] consumer_groups: List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforce_consumer_groups` is set to `true`.
        :param str dictionary_name: The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
        :param bool disable_penalty: If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
        :param bool enforce_consumer_groups: Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforce_consumer_groups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforce_consumer_groups` to `true` to re-enforce the groups.
        :param float error_code: Set a custom error code to return when the rate limit is exceeded.
        :param str error_message: Set a custom error message to return when the rate limit is exceeded.
        :param str header_name: A string representing an HTTP header name.
        :param bool hide_client_headers: Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
        :param str identifier: The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
        :param Sequence[float] limits: One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
        :param str namespace: The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `sync_rate`, `window_size`, `dictionary_name`, need to be the same.
        :param str path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param float retry_after_jitter_max: The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
        :param str strategy: The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
        :param float sync_rate: How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
        :param Sequence[float] window_sizes: One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
        :param str window_type: Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
        """
        if consumer_groups is not None:
            pulumi.set(__self__, "consumer_groups", consumer_groups)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if disable_penalty is not None:
            pulumi.set(__self__, "disable_penalty", disable_penalty)
        if enforce_consumer_groups is not None:
            pulumi.set(__self__, "enforce_consumer_groups", enforce_consumer_groups)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if hide_client_headers is not None:
            pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)
        if retry_after_jitter_max is not None:
            pulumi.set(__self__, "retry_after_jitter_max", retry_after_jitter_max)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if sync_rate is not None:
            pulumi.set(__self__, "sync_rate", sync_rate)
        if window_sizes is not None:
            pulumi.set(__self__, "window_sizes", window_sizes)
        if window_type is not None:
            pulumi.set(__self__, "window_type", window_type)

    @property
    @pulumi.getter(name="consumerGroups")
    def consumer_groups(self) -> Optional[Sequence[str]]:
        """
        List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforce_consumer_groups` is set to `true`.
        """
        return pulumi.get(self, "consumer_groups")

    @property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[str]:
        """
        The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
        """
        return pulumi.get(self, "dictionary_name")

    @property
    @pulumi.getter(name="disablePenalty")
    def disable_penalty(self) -> Optional[bool]:
        """
        If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
        """
        return pulumi.get(self, "disable_penalty")

    @property
    @pulumi.getter(name="enforceConsumerGroups")
    def enforce_consumer_groups(self) -> Optional[bool]:
        """
        Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforce_consumer_groups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforce_consumer_groups` to `true` to re-enforce the groups.
        """
        return pulumi.get(self, "enforce_consumer_groups")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[float]:
        """
        Set a custom error code to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Set a custom error message to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> Optional[bool]:
        """
        Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
        """
        return pulumi.get(self, "hide_client_headers")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence[float]]:
        """
        One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `sync_rate`, `window_size`, `dictionary_name`, need to be the same.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def redis(self) -> Optional['outputs.GatewayPluginRateLimitingAdvancedConfigRedis']:
        return pulumi.get(self, "redis")

    @property
    @pulumi.getter(name="retryAfterJitterMax")
    def retry_after_jitter_max(self) -> Optional[float]:
        """
        The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
        """
        return pulumi.get(self, "retry_after_jitter_max")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="syncRate")
    def sync_rate(self) -> Optional[float]:
        """
        How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
        """
        return pulumi.get(self, "sync_rate")

    @property
    @pulumi.getter(name="windowSizes")
    def window_sizes(self) -> Optional[Sequence[float]]:
        """
        One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
        """
        return pulumi.get(self, "window_sizes")

    @property
    @pulumi.getter(name="windowType")
    def window_type(self) -> Optional[str]:
        """
        Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
        """
        return pulumi.get(self, "window_type")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedConfigRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterAddresses":
            suggest = "cluster_addresses"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "keepaliveBacklog":
            suggest = "keepalive_backlog"
        elif key == "keepalivePoolSize":
            suggest = "keepalive_pool_size"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "sendTimeout":
            suggest = "send_timeout"
        elif key == "sentinelAddresses":
            suggest = "sentinel_addresses"
        elif key == "sentinelMaster":
            suggest = "sentinel_master"
        elif key == "sentinelPassword":
            suggest = "sentinel_password"
        elif key == "sentinelRole":
            suggest = "sentinel_role"
        elif key == "sentinelUsername":
            suggest = "sentinel_username"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "sslVerify":
            suggest = "ssl_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRateLimitingAdvancedConfigRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRateLimitingAdvancedConfigRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRateLimitingAdvancedConfigRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_addresses: Optional[Sequence[str]] = None,
                 connect_timeout: Optional[int] = None,
                 database: Optional[int] = None,
                 host: Optional[str] = None,
                 keepalive_backlog: Optional[int] = None,
                 keepalive_pool_size: Optional[int] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 read_timeout: Optional[int] = None,
                 send_timeout: Optional[int] = None,
                 sentinel_addresses: Optional[Sequence[str]] = None,
                 sentinel_master: Optional[str] = None,
                 sentinel_password: Optional[str] = None,
                 sentinel_role: Optional[str] = None,
                 sentinel_username: Optional[str] = None,
                 server_name: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 ssl_verify: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 username: Optional[str] = None):
        """
        :param Sequence[str] cluster_addresses: Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
        :param int connect_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param int database: Database to use for the Redis connection when using the `redis` strategy
        :param str host: A string representing a host name, such as example.com.
        :param int keepalive_backlog: Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalive_pool_size`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalive_pool_size`.
        :param int keepalive_pool_size: The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalive_pool_size` nor `keepalive_backlog` is specified, no pool is created. If `keepalive_pool_size` isn't specified but `keepalive_backlog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
        :param str password: Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param int read_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param int send_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param Sequence[str] sentinel_addresses: Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
        :param str sentinel_master: Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
        :param str sentinel_password: Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
        :param str sentinel_role: Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
        :param str sentinel_username: Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
        :param str server_name: A string representing an SNI (server name indication) value for TLS.
        :param bool ssl: If set to true, uses SSL to connect to Redis.
        :param bool ssl_verify: If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        :param int timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str username: Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        if cluster_addresses is not None:
            pulumi.set(__self__, "cluster_addresses", cluster_addresses)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keepalive_backlog is not None:
            pulumi.set(__self__, "keepalive_backlog", keepalive_backlog)
        if keepalive_pool_size is not None:
            pulumi.set(__self__, "keepalive_pool_size", keepalive_pool_size)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if send_timeout is not None:
            pulumi.set(__self__, "send_timeout", send_timeout)
        if sentinel_addresses is not None:
            pulumi.set(__self__, "sentinel_addresses", sentinel_addresses)
        if sentinel_master is not None:
            pulumi.set(__self__, "sentinel_master", sentinel_master)
        if sentinel_password is not None:
            pulumi.set(__self__, "sentinel_password", sentinel_password)
        if sentinel_role is not None:
            pulumi.set(__self__, "sentinel_role", sentinel_role)
        if sentinel_username is not None:
            pulumi.set(__self__, "sentinel_username", sentinel_username)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_verify is not None:
            pulumi.set(__self__, "ssl_verify", ssl_verify)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clusterAddresses")
    def cluster_addresses(self) -> Optional[Sequence[str]]:
        """
        Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
        """
        return pulumi.get(self, "cluster_addresses")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def database(self) -> Optional[int]:
        """
        Database to use for the Redis connection when using the `redis` strategy
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepaliveBacklog")
    def keepalive_backlog(self) -> Optional[int]:
        """
        Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalive_pool_size`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalive_pool_size`.
        """
        return pulumi.get(self, "keepalive_backlog")

    @property
    @pulumi.getter(name="keepalivePoolSize")
    def keepalive_pool_size(self) -> Optional[int]:
        """
        The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalive_pool_size` nor `keepalive_backlog` is specified, no pool is created. If `keepalive_pool_size` isn't specified but `keepalive_backlog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
        """
        return pulumi.get(self, "keepalive_pool_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "send_timeout")

    @property
    @pulumi.getter(name="sentinelAddresses")
    def sentinel_addresses(self) -> Optional[Sequence[str]]:
        """
        Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
        """
        return pulumi.get(self, "sentinel_addresses")

    @property
    @pulumi.getter(name="sentinelMaster")
    def sentinel_master(self) -> Optional[str]:
        """
        Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
        """
        return pulumi.get(self, "sentinel_master")

    @property
    @pulumi.getter(name="sentinelPassword")
    def sentinel_password(self) -> Optional[str]:
        """
        Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
        """
        return pulumi.get(self, "sentinel_password")

    @property
    @pulumi.getter(name="sentinelRole")
    def sentinel_role(self) -> Optional[str]:
        """
        Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
        """
        return pulumi.get(self, "sentinel_role")

    @property
    @pulumi.getter(name="sentinelUsername")
    def sentinel_username(self) -> Optional[str]:
        """
        Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
        """
        return pulumi.get(self, "sentinel_username")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        A string representing an SNI (server name indication) value for TLS.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        If set to true, uses SSL to connect to Redis.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> Optional[bool]:
        """
        If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingAdvancedService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "faultTolerant":
            suggest = "fault_tolerant"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "hideClientHeaders":
            suggest = "hide_client_headers"
        elif key == "limitBy":
            suggest = "limit_by"
        elif key == "syncRate":
            suggest = "sync_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRateLimitingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRateLimitingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRateLimitingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[float] = None,
                 error_code: Optional[float] = None,
                 error_message: Optional[str] = None,
                 fault_tolerant: Optional[bool] = None,
                 header_name: Optional[str] = None,
                 hide_client_headers: Optional[bool] = None,
                 hour: Optional[float] = None,
                 limit_by: Optional[str] = None,
                 minute: Optional[float] = None,
                 month: Optional[float] = None,
                 path: Optional[str] = None,
                 policy: Optional[str] = None,
                 redis: Optional['outputs.GatewayPluginRateLimitingConfigRedis'] = None,
                 second: Optional[float] = None,
                 sync_rate: Optional[float] = None,
                 year: Optional[float] = None):
        """
        :param float day: The number of HTTP requests that can be made per day.
        :param float error_code: Set a custom error code to return when the rate limit is exceeded.
        :param str error_message: Set a custom error message to return when the rate limit is exceeded.
        :param bool fault_tolerant: A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
        :param str header_name: A string representing an HTTP header name.
        :param bool hide_client_headers: Optionally hide informative response headers.
        :param float hour: The number of HTTP requests that can be made per hour.
        :param str limit_by: The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
        :param float minute: The number of HTTP requests that can be made per minute.
        :param float month: The number of HTTP requests that can be made per month.
        :param str path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str policy: The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
        :param 'GatewayPluginRateLimitingConfigRedisArgs' redis: Redis configuration
        :param float second: The number of HTTP requests that can be made per second.
        :param float sync_rate: How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
        :param float year: The number of HTTP requests that can be made per year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if fault_tolerant is not None:
            pulumi.set(__self__, "fault_tolerant", fault_tolerant)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if hide_client_headers is not None:
            pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if limit_by is not None:
            pulumi.set(__self__, "limit_by", limit_by)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)
        if second is not None:
            pulumi.set(__self__, "second", second)
        if sync_rate is not None:
            pulumi.set(__self__, "sync_rate", sync_rate)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per day.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[float]:
        """
        Set a custom error code to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Set a custom error message to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="faultTolerant")
    def fault_tolerant(self) -> Optional[bool]:
        """
        A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
        """
        return pulumi.get(self, "fault_tolerant")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> Optional[bool]:
        """
        Optionally hide informative response headers.
        """
        return pulumi.get(self, "hide_client_headers")

    @property
    @pulumi.getter
    def hour(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per hour.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter(name="limitBy")
    def limit_by(self) -> Optional[str]:
        """
        The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
        """
        return pulumi.get(self, "limit_by")

    @property
    @pulumi.getter
    def minute(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per minute.
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter
    def month(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per month.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def redis(self) -> Optional['outputs.GatewayPluginRateLimitingConfigRedis']:
        """
        Redis configuration
        """
        return pulumi.get(self, "redis")

    @property
    @pulumi.getter
    def second(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per second.
        """
        return pulumi.get(self, "second")

    @property
    @pulumi.getter(name="syncRate")
    def sync_rate(self) -> Optional[float]:
        """
        How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
        """
        return pulumi.get(self, "sync_rate")

    @property
    @pulumi.getter
    def year(self) -> Optional[float]:
        """
        The number of HTTP requests that can be made per year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class GatewayPluginRateLimitingConfigRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"
        elif key == "sslVerify":
            suggest = "ssl_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRateLimitingConfigRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRateLimitingConfigRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRateLimitingConfigRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[int] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 server_name: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 ssl_verify: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 username: Optional[str] = None):
        """
        :param int database: Database to use for the Redis connection when using the `redis` strategy
        :param str host: A string representing a host name, such as example.com.
        :param str password: Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param str server_name: A string representing an SNI (server name indication) value for TLS.
        :param bool ssl: If set to true, uses SSL to connect to Redis.
        :param bool ssl_verify: If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        :param int timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str username: Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_verify is not None:
            pulumi.set(__self__, "ssl_verify", ssl_verify)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Optional[int]:
        """
        Database to use for the Redis connection when using the `redis` strategy
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        A string representing an SNI (server name indication) value for TLS.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        If set to true, uses SSL to connect to Redis.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> Optional[bool]:
        """
        If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GatewayPluginRateLimitingConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRateLimitingService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTerminationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTerminationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTerminationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTerminationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 content_type: Optional[str] = None,
                 echo: Optional[bool] = None,
                 message: Optional[str] = None,
                 status_code: Optional[int] = None,
                 trigger: Optional[str] = None):
        """
        :param str body: The raw response body to send. This is mutually exclusive with the `config.message` field.
        :param str content_type: Content type of the raw response configured with `config.body`.
        :param bool echo: When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
        :param str message: The message to send, if using the default response generator.
        :param int status_code: The response code to send. Must be an integer between 100 and 599.
        :param str trigger: A string representing an HTTP header name.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if echo is not None:
            pulumi.set(__self__, "echo", echo)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The raw response body to send. This is mutually exclusive with the `config.message` field.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        Content type of the raw response configured with `config.body`.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def echo(self) -> Optional[bool]:
        """
        When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
        """
        return pulumi.get(self, "echo")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The message to send, if using the default response generator.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        The response code to send. Must be an integer between 100 and 599.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def trigger(self) -> Optional[str]:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class GatewayPluginRequestTerminationConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTerminationConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTerminationRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTerminationService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotsInKeys":
            suggest = "dots_in_keys"
        elif key == "httpMethod":
            suggest = "http_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTransformerAdvancedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTransformerAdvancedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTransformerAdvancedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAdd'] = None,
                 allow: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAllow'] = None,
                 append: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAppend'] = None,
                 dots_in_keys: Optional[bool] = None,
                 http_method: Optional[str] = None,
                 remove: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigRemove'] = None,
                 rename: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigRename'] = None,
                 replace: Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigReplace'] = None):
        """
        :param bool dots_in_keys: Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
        :param str http_method: A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if dots_in_keys is not None:
            pulumi.set(__self__, "dots_in_keys", dots_in_keys)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rename is not None:
            pulumi.set(__self__, "rename", rename)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAdd']:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAllow']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def append(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigAppend']:
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="dotsInKeys")
    def dots_in_keys(self) -> Optional[bool]:
        """
        Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
        """
        return pulumi.get(self, "dots_in_keys")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def remove(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigRemove']:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigRename']:
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.GatewayPluginRequestTransformerAdvancedConfigReplace']:
        return pulumi.get(self, "replace")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTransformerAdvancedConfigAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigAllow(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigAppend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTransformerAdvancedConfigAppend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigAppend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigAppend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigRemove(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigRename(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConfigReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTransformerAdvancedConfigReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTransformerAdvancedConfigReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None,
                 uri: Optional[str] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerAdvancedService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginRequestTransformerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginRequestTransformerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginRequestTransformerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add: Optional['outputs.GatewayPluginRequestTransformerConfigAdd'] = None,
                 append: Optional['outputs.GatewayPluginRequestTransformerConfigAppend'] = None,
                 http_method: Optional[str] = None,
                 remove: Optional['outputs.GatewayPluginRequestTransformerConfigRemove'] = None,
                 rename: Optional['outputs.GatewayPluginRequestTransformerConfigRename'] = None,
                 replace: Optional['outputs.GatewayPluginRequestTransformerConfigReplace'] = None):
        """
        :param str http_method: A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rename is not None:
            pulumi.set(__self__, "rename", rename)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.GatewayPluginRequestTransformerConfigAdd']:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def append(self) -> Optional['outputs.GatewayPluginRequestTransformerConfigAppend']:
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def remove(self) -> Optional['outputs.GatewayPluginRequestTransformerConfigRemove']:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> Optional['outputs.GatewayPluginRequestTransformerConfigRename']:
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.GatewayPluginRequestTransformerConfigReplace']:
        return pulumi.get(self, "replace")


@pulumi.output_type
class GatewayPluginRequestTransformerConfigAdd(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerConfigAppend(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerConfigRemove(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerConfigRename(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GatewayPluginRequestTransformerConfigReplace(dict):
    def __init__(__self__, *,
                 bodies: Optional[Sequence[str]] = None,
                 headers: Optional[Sequence[str]] = None,
                 querystrings: Optional[Sequence[str]] = None,
                 uri: Optional[str] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if querystrings is not None:
            pulumi.set(__self__, "querystrings", querystrings)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "querystrings")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GatewayPluginRequestTransformerConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginRequestTransformerService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dotsInKeys":
            suggest = "dots_in_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAdd'] = None,
                 allow: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAllow'] = None,
                 append: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAppend'] = None,
                 dots_in_keys: Optional[bool] = None,
                 remove: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigRemove'] = None,
                 rename: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigRename'] = None,
                 replace: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigReplace'] = None,
                 transform: Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigTransform'] = None):
        """
        :param bool dots_in_keys: Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if dots_in_keys is not None:
            pulumi.set(__self__, "dots_in_keys", dots_in_keys)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rename is not None:
            pulumi.set(__self__, "rename", rename)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)
        if transform is not None:
            pulumi.set(__self__, "transform", transform)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAdd']:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAllow']:
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def append(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigAppend']:
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="dotsInKeys")
    def dots_in_keys(self) -> Optional[bool]:
        """
        Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
        """
        return pulumi.get(self, "dots_in_keys")

    @property
    @pulumi.getter
    def remove(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigRemove']:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigRename']:
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigReplace']:
        return pulumi.get(self, "replace")

    @property
    @pulumi.getter
    def transform(self) -> Optional['outputs.GatewayPluginResponseTransformerAdvancedConfigTransform']:
        return pulumi.get(self, "transform")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"
        elif key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigAllow(dict):
    def __init__(__self__, *,
                 jsons: Optional[Sequence[str]] = None):
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigAppend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"
        elif key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigAppend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigAppend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigAppend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigRemove(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigRemove. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigRemove.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigRemove.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigRename(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigRename. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigRename.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigRename.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"
        elif key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 headers: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        """
        :param str body: String with which to replace the entire response body.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        String with which to replace the entire response body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConfigTransform(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ifStatuses":
            suggest = "if_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerAdvancedConfigTransform. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigTransform.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerAdvancedConfigTransform.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 functions: Optional[Sequence[str]] = None,
                 if_statuses: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if if_statuses is not None:
            pulumi.set(__self__, "if_statuses", if_statuses)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def functions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "functions")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerAdvancedService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerConfig(dict):
    def __init__(__self__, *,
                 add: Optional['outputs.GatewayPluginResponseTransformerConfigAdd'] = None,
                 append: Optional['outputs.GatewayPluginResponseTransformerConfigAppend'] = None,
                 remove: Optional['outputs.GatewayPluginResponseTransformerConfigRemove'] = None,
                 rename: Optional['outputs.GatewayPluginResponseTransformerConfigRename'] = None,
                 replace: Optional['outputs.GatewayPluginResponseTransformerConfigReplace'] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if rename is not None:
            pulumi.set(__self__, "rename", rename)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.GatewayPluginResponseTransformerConfigAdd']:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def append(self) -> Optional['outputs.GatewayPluginResponseTransformerConfigAppend']:
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def remove(self) -> Optional['outputs.GatewayPluginResponseTransformerConfigRemove']:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> Optional['outputs.GatewayPluginResponseTransformerConfigRename']:
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.GatewayPluginResponseTransformerConfigReplace']:
        return pulumi.get(self, "replace")


@pulumi.output_type
class GatewayPluginResponseTransformerConfigAdd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerConfigAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerConfigAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerConfigAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerConfigAppend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerConfigAppend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerConfigAppend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerConfigAppend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerConfigRemove(dict):
    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerConfigRename(dict):
    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class GatewayPluginResponseTransformerConfigReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonTypes":
            suggest = "json_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginResponseTransformerConfigReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginResponseTransformerConfigReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginResponseTransformerConfigReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence[str]] = None,
                 json_types: Optional[Sequence[str]] = None,
                 jsons: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if json_types is not None:
            pulumi.set(__self__, "json_types", json_types)
        if jsons is not None:
            pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Optional[Sequence[str]]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GatewayPluginResponseTransformerConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginResponseTransformerService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginSamlConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assertionConsumerPath":
            suggest = "assertion_consumer_path"
        elif key == "idpCertificate":
            suggest = "idp_certificate"
        elif key == "idpSsoUrl":
            suggest = "idp_sso_url"
        elif key == "nameidFormat":
            suggest = "nameid_format"
        elif key == "requestDigestAlgorithm":
            suggest = "request_digest_algorithm"
        elif key == "requestSignatureAlgorithm":
            suggest = "request_signature_algorithm"
        elif key == "requestSigningCertificate":
            suggest = "request_signing_certificate"
        elif key == "requestSigningKey":
            suggest = "request_signing_key"
        elif key == "responseDigestAlgorithm":
            suggest = "response_digest_algorithm"
        elif key == "responseEncryptionKey":
            suggest = "response_encryption_key"
        elif key == "responseSignatureAlgorithm":
            suggest = "response_signature_algorithm"
        elif key == "sessionAbsoluteTimeout":
            suggest = "session_absolute_timeout"
        elif key == "sessionAudience":
            suggest = "session_audience"
        elif key == "sessionCookieDomain":
            suggest = "session_cookie_domain"
        elif key == "sessionCookieHttpOnly":
            suggest = "session_cookie_http_only"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionCookiePath":
            suggest = "session_cookie_path"
        elif key == "sessionCookieSameSite":
            suggest = "session_cookie_same_site"
        elif key == "sessionCookieSecure":
            suggest = "session_cookie_secure"
        elif key == "sessionEnforceSameSubject":
            suggest = "session_enforce_same_subject"
        elif key == "sessionHashStorageKey":
            suggest = "session_hash_storage_key"
        elif key == "sessionHashSubject":
            suggest = "session_hash_subject"
        elif key == "sessionIdlingTimeout":
            suggest = "session_idling_timeout"
        elif key == "sessionMemcachedHost":
            suggest = "session_memcached_host"
        elif key == "sessionMemcachedPort":
            suggest = "session_memcached_port"
        elif key == "sessionMemcachedPrefix":
            suggest = "session_memcached_prefix"
        elif key == "sessionMemcachedSocket":
            suggest = "session_memcached_socket"
        elif key == "sessionRedisClusterMaxRedirections":
            suggest = "session_redis_cluster_max_redirections"
        elif key == "sessionRedisClusterNodes":
            suggest = "session_redis_cluster_nodes"
        elif key == "sessionRedisConnectTimeout":
            suggest = "session_redis_connect_timeout"
        elif key == "sessionRedisHost":
            suggest = "session_redis_host"
        elif key == "sessionRedisPassword":
            suggest = "session_redis_password"
        elif key == "sessionRedisPort":
            suggest = "session_redis_port"
        elif key == "sessionRedisPrefix":
            suggest = "session_redis_prefix"
        elif key == "sessionRedisReadTimeout":
            suggest = "session_redis_read_timeout"
        elif key == "sessionRedisSendTimeout":
            suggest = "session_redis_send_timeout"
        elif key == "sessionRedisServerName":
            suggest = "session_redis_server_name"
        elif key == "sessionRedisSocket":
            suggest = "session_redis_socket"
        elif key == "sessionRedisSsl":
            suggest = "session_redis_ssl"
        elif key == "sessionRedisSslVerify":
            suggest = "session_redis_ssl_verify"
        elif key == "sessionRedisUsername":
            suggest = "session_redis_username"
        elif key == "sessionRemember":
            suggest = "session_remember"
        elif key == "sessionRememberAbsoluteTimeout":
            suggest = "session_remember_absolute_timeout"
        elif key == "sessionRememberCookieName":
            suggest = "session_remember_cookie_name"
        elif key == "sessionRememberRollingTimeout":
            suggest = "session_remember_rolling_timeout"
        elif key == "sessionRequestHeaders":
            suggest = "session_request_headers"
        elif key == "sessionResponseHeaders":
            suggest = "session_response_headers"
        elif key == "sessionRollingTimeout":
            suggest = "session_rolling_timeout"
        elif key == "sessionSecret":
            suggest = "session_secret"
        elif key == "sessionStorage":
            suggest = "session_storage"
        elif key == "sessionStoreMetadata":
            suggest = "session_store_metadata"
        elif key == "validateAssertionSignature":
            suggest = "validate_assertion_signature"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginSamlConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginSamlConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginSamlConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous: Optional[str] = None,
                 assertion_consumer_path: Optional[str] = None,
                 idp_certificate: Optional[str] = None,
                 idp_sso_url: Optional[str] = None,
                 issuer: Optional[str] = None,
                 nameid_format: Optional[str] = None,
                 request_digest_algorithm: Optional[str] = None,
                 request_signature_algorithm: Optional[str] = None,
                 request_signing_certificate: Optional[str] = None,
                 request_signing_key: Optional[str] = None,
                 response_digest_algorithm: Optional[str] = None,
                 response_encryption_key: Optional[str] = None,
                 response_signature_algorithm: Optional[str] = None,
                 session_absolute_timeout: Optional[float] = None,
                 session_audience: Optional[str] = None,
                 session_cookie_domain: Optional[str] = None,
                 session_cookie_http_only: Optional[bool] = None,
                 session_cookie_name: Optional[str] = None,
                 session_cookie_path: Optional[str] = None,
                 session_cookie_same_site: Optional[str] = None,
                 session_cookie_secure: Optional[bool] = None,
                 session_enforce_same_subject: Optional[bool] = None,
                 session_hash_storage_key: Optional[bool] = None,
                 session_hash_subject: Optional[bool] = None,
                 session_idling_timeout: Optional[float] = None,
                 session_memcached_host: Optional[str] = None,
                 session_memcached_port: Optional[int] = None,
                 session_memcached_prefix: Optional[str] = None,
                 session_memcached_socket: Optional[str] = None,
                 session_redis_cluster_max_redirections: Optional[int] = None,
                 session_redis_cluster_nodes: Optional[Sequence['outputs.GatewayPluginSamlConfigSessionRedisClusterNode']] = None,
                 session_redis_connect_timeout: Optional[int] = None,
                 session_redis_host: Optional[str] = None,
                 session_redis_password: Optional[str] = None,
                 session_redis_port: Optional[int] = None,
                 session_redis_prefix: Optional[str] = None,
                 session_redis_read_timeout: Optional[int] = None,
                 session_redis_send_timeout: Optional[int] = None,
                 session_redis_server_name: Optional[str] = None,
                 session_redis_socket: Optional[str] = None,
                 session_redis_ssl: Optional[bool] = None,
                 session_redis_ssl_verify: Optional[bool] = None,
                 session_redis_username: Optional[str] = None,
                 session_remember: Optional[bool] = None,
                 session_remember_absolute_timeout: Optional[float] = None,
                 session_remember_cookie_name: Optional[str] = None,
                 session_remember_rolling_timeout: Optional[float] = None,
                 session_request_headers: Optional[Sequence[str]] = None,
                 session_response_headers: Optional[Sequence[str]] = None,
                 session_rolling_timeout: Optional[float] = None,
                 session_secret: Optional[str] = None,
                 session_storage: Optional[str] = None,
                 session_store_metadata: Optional[bool] = None,
                 validate_assertion_signature: Optional[bool] = None):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
        :param str assertion_consumer_path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str idp_certificate: The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
        :param str idp_sso_url: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str issuer: The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
        :param str nameid_format: The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
        :param str request_digest_algorithm: The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        :param str request_signature_algorithm: The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        :param str request_signing_certificate: The certificate for signing requests.
        :param str request_signing_key: The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `request_signing_certificate` parameter must be set as well.
        :param str response_digest_algorithm: The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        :param str response_encryption_key: The private encryption key required to decrypt encrypted assertions.
        :param str response_signature_algorithm: The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        :param float session_absolute_timeout: The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        :param str session_audience: The session audience, for example "my-application"
        :param str session_cookie_domain: The session cookie domain flag.
        :param bool session_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str session_cookie_name: The session cookie name.
        :param str session_cookie_path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str session_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool session_cookie_secure: The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param bool session_enforce_same_subject: When set to `true`, audiences are forced to share the same subject.
        :param bool session_hash_storage_key: When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        :param bool session_hash_subject: When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        :param float session_idling_timeout: The session cookie idle time in seconds.
        :param str session_memcached_host: The memcached host.
        :param int session_memcached_port: An integer representing a port number between 0 and 65535, inclusive.
        :param str session_memcached_prefix: The memcached session key prefix.
        :param str session_memcached_socket: The memcached unix socket path.
        :param int session_redis_cluster_max_redirections: The Redis cluster maximum redirects.
        :param Sequence['GatewayPluginSamlConfigSessionRedisClusterNodeArgs'] session_redis_cluster_nodes: The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        :param int session_redis_connect_timeout: The Redis connection timeout in milliseconds.
        :param str session_redis_host: The Redis host IP.
        :param str session_redis_password: Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
        :param int session_redis_port: An integer representing a port number between 0 and 65535, inclusive.
        :param str session_redis_prefix: The Redis session key prefix.
        :param int session_redis_read_timeout: The Redis read timeout in milliseconds.
        :param int session_redis_send_timeout: The Redis send timeout in milliseconds.
        :param str session_redis_server_name: The SNI used for connecting to the Redis server.
        :param str session_redis_socket: The Redis unix socket path.
        :param bool session_redis_ssl: Use SSL/TLS for the Redis connection.
        :param bool session_redis_ssl_verify: Verify the Redis server certificate.
        :param str session_redis_username: Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
        :param bool session_remember: Enables or disables persistent sessions
        :param float session_remember_absolute_timeout: Persistent session absolute timeout in seconds.
        :param str session_remember_cookie_name: Persistent session cookie name
        :param float session_remember_rolling_timeout: Persistent session rolling timeout in seconds.
        :param float session_rolling_timeout: The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        :param str session_secret: The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
        :param str session_storage: The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        :param bool session_store_metadata: Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specific_audience` belonging to a specific subject.
        :param bool validate_assertion_signature: Enable signature validation for SAML responses.
        """
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if assertion_consumer_path is not None:
            pulumi.set(__self__, "assertion_consumer_path", assertion_consumer_path)
        if idp_certificate is not None:
            pulumi.set(__self__, "idp_certificate", idp_certificate)
        if idp_sso_url is not None:
            pulumi.set(__self__, "idp_sso_url", idp_sso_url)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if nameid_format is not None:
            pulumi.set(__self__, "nameid_format", nameid_format)
        if request_digest_algorithm is not None:
            pulumi.set(__self__, "request_digest_algorithm", request_digest_algorithm)
        if request_signature_algorithm is not None:
            pulumi.set(__self__, "request_signature_algorithm", request_signature_algorithm)
        if request_signing_certificate is not None:
            pulumi.set(__self__, "request_signing_certificate", request_signing_certificate)
        if request_signing_key is not None:
            pulumi.set(__self__, "request_signing_key", request_signing_key)
        if response_digest_algorithm is not None:
            pulumi.set(__self__, "response_digest_algorithm", response_digest_algorithm)
        if response_encryption_key is not None:
            pulumi.set(__self__, "response_encryption_key", response_encryption_key)
        if response_signature_algorithm is not None:
            pulumi.set(__self__, "response_signature_algorithm", response_signature_algorithm)
        if session_absolute_timeout is not None:
            pulumi.set(__self__, "session_absolute_timeout", session_absolute_timeout)
        if session_audience is not None:
            pulumi.set(__self__, "session_audience", session_audience)
        if session_cookie_domain is not None:
            pulumi.set(__self__, "session_cookie_domain", session_cookie_domain)
        if session_cookie_http_only is not None:
            pulumi.set(__self__, "session_cookie_http_only", session_cookie_http_only)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_cookie_path is not None:
            pulumi.set(__self__, "session_cookie_path", session_cookie_path)
        if session_cookie_same_site is not None:
            pulumi.set(__self__, "session_cookie_same_site", session_cookie_same_site)
        if session_cookie_secure is not None:
            pulumi.set(__self__, "session_cookie_secure", session_cookie_secure)
        if session_enforce_same_subject is not None:
            pulumi.set(__self__, "session_enforce_same_subject", session_enforce_same_subject)
        if session_hash_storage_key is not None:
            pulumi.set(__self__, "session_hash_storage_key", session_hash_storage_key)
        if session_hash_subject is not None:
            pulumi.set(__self__, "session_hash_subject", session_hash_subject)
        if session_idling_timeout is not None:
            pulumi.set(__self__, "session_idling_timeout", session_idling_timeout)
        if session_memcached_host is not None:
            pulumi.set(__self__, "session_memcached_host", session_memcached_host)
        if session_memcached_port is not None:
            pulumi.set(__self__, "session_memcached_port", session_memcached_port)
        if session_memcached_prefix is not None:
            pulumi.set(__self__, "session_memcached_prefix", session_memcached_prefix)
        if session_memcached_socket is not None:
            pulumi.set(__self__, "session_memcached_socket", session_memcached_socket)
        if session_redis_cluster_max_redirections is not None:
            pulumi.set(__self__, "session_redis_cluster_max_redirections", session_redis_cluster_max_redirections)
        if session_redis_cluster_nodes is not None:
            pulumi.set(__self__, "session_redis_cluster_nodes", session_redis_cluster_nodes)
        if session_redis_connect_timeout is not None:
            pulumi.set(__self__, "session_redis_connect_timeout", session_redis_connect_timeout)
        if session_redis_host is not None:
            pulumi.set(__self__, "session_redis_host", session_redis_host)
        if session_redis_password is not None:
            pulumi.set(__self__, "session_redis_password", session_redis_password)
        if session_redis_port is not None:
            pulumi.set(__self__, "session_redis_port", session_redis_port)
        if session_redis_prefix is not None:
            pulumi.set(__self__, "session_redis_prefix", session_redis_prefix)
        if session_redis_read_timeout is not None:
            pulumi.set(__self__, "session_redis_read_timeout", session_redis_read_timeout)
        if session_redis_send_timeout is not None:
            pulumi.set(__self__, "session_redis_send_timeout", session_redis_send_timeout)
        if session_redis_server_name is not None:
            pulumi.set(__self__, "session_redis_server_name", session_redis_server_name)
        if session_redis_socket is not None:
            pulumi.set(__self__, "session_redis_socket", session_redis_socket)
        if session_redis_ssl is not None:
            pulumi.set(__self__, "session_redis_ssl", session_redis_ssl)
        if session_redis_ssl_verify is not None:
            pulumi.set(__self__, "session_redis_ssl_verify", session_redis_ssl_verify)
        if session_redis_username is not None:
            pulumi.set(__self__, "session_redis_username", session_redis_username)
        if session_remember is not None:
            pulumi.set(__self__, "session_remember", session_remember)
        if session_remember_absolute_timeout is not None:
            pulumi.set(__self__, "session_remember_absolute_timeout", session_remember_absolute_timeout)
        if session_remember_cookie_name is not None:
            pulumi.set(__self__, "session_remember_cookie_name", session_remember_cookie_name)
        if session_remember_rolling_timeout is not None:
            pulumi.set(__self__, "session_remember_rolling_timeout", session_remember_rolling_timeout)
        if session_request_headers is not None:
            pulumi.set(__self__, "session_request_headers", session_request_headers)
        if session_response_headers is not None:
            pulumi.set(__self__, "session_response_headers", session_response_headers)
        if session_rolling_timeout is not None:
            pulumi.set(__self__, "session_rolling_timeout", session_rolling_timeout)
        if session_secret is not None:
            pulumi.set(__self__, "session_secret", session_secret)
        if session_storage is not None:
            pulumi.set(__self__, "session_storage", session_storage)
        if session_store_metadata is not None:
            pulumi.set(__self__, "session_store_metadata", session_store_metadata)
        if validate_assertion_signature is not None:
            pulumi.set(__self__, "validate_assertion_signature", validate_assertion_signature)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[str]:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="assertionConsumerPath")
    def assertion_consumer_path(self) -> Optional[str]:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "assertion_consumer_path")

    @property
    @pulumi.getter(name="idpCertificate")
    def idp_certificate(self) -> Optional[str]:
        """
        The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
        """
        return pulumi.get(self, "idp_certificate")

    @property
    @pulumi.getter(name="idpSsoUrl")
    def idp_sso_url(self) -> Optional[str]:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "idp_sso_url")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="nameidFormat")
    def nameid_format(self) -> Optional[str]:
        """
        The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
        """
        return pulumi.get(self, "nameid_format")

    @property
    @pulumi.getter(name="requestDigestAlgorithm")
    def request_digest_algorithm(self) -> Optional[str]:
        """
        The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        """
        return pulumi.get(self, "request_digest_algorithm")

    @property
    @pulumi.getter(name="requestSignatureAlgorithm")
    def request_signature_algorithm(self) -> Optional[str]:
        """
        The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        """
        return pulumi.get(self, "request_signature_algorithm")

    @property
    @pulumi.getter(name="requestSigningCertificate")
    def request_signing_certificate(self) -> Optional[str]:
        """
        The certificate for signing requests.
        """
        return pulumi.get(self, "request_signing_certificate")

    @property
    @pulumi.getter(name="requestSigningKey")
    def request_signing_key(self) -> Optional[str]:
        """
        The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `request_signing_certificate` parameter must be set as well.
        """
        return pulumi.get(self, "request_signing_key")

    @property
    @pulumi.getter(name="responseDigestAlgorithm")
    def response_digest_algorithm(self) -> Optional[str]:
        """
        The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        """
        return pulumi.get(self, "response_digest_algorithm")

    @property
    @pulumi.getter(name="responseEncryptionKey")
    def response_encryption_key(self) -> Optional[str]:
        """
        The private encryption key required to decrypt encrypted assertions.
        """
        return pulumi.get(self, "response_encryption_key")

    @property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> Optional[str]:
        """
        The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        """
        return pulumi.get(self, "response_signature_algorithm")

    @property
    @pulumi.getter(name="sessionAbsoluteTimeout")
    def session_absolute_timeout(self) -> Optional[float]:
        """
        The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        """
        return pulumi.get(self, "session_absolute_timeout")

    @property
    @pulumi.getter(name="sessionAudience")
    def session_audience(self) -> Optional[str]:
        """
        The session audience, for example "my-application"
        """
        return pulumi.get(self, "session_audience")

    @property
    @pulumi.getter(name="sessionCookieDomain")
    def session_cookie_domain(self) -> Optional[str]:
        """
        The session cookie domain flag.
        """
        return pulumi.get(self, "session_cookie_domain")

    @property
    @pulumi.getter(name="sessionCookieHttpOnly")
    def session_cookie_http_only(self) -> Optional[bool]:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "session_cookie_http_only")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The session cookie name.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionCookiePath")
    def session_cookie_path(self) -> Optional[str]:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "session_cookie_path")

    @property
    @pulumi.getter(name="sessionCookieSameSite")
    def session_cookie_same_site(self) -> Optional[str]:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "session_cookie_same_site")

    @property
    @pulumi.getter(name="sessionCookieSecure")
    def session_cookie_secure(self) -> Optional[bool]:
        """
        The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "session_cookie_secure")

    @property
    @pulumi.getter(name="sessionEnforceSameSubject")
    def session_enforce_same_subject(self) -> Optional[bool]:
        """
        When set to `true`, audiences are forced to share the same subject.
        """
        return pulumi.get(self, "session_enforce_same_subject")

    @property
    @pulumi.getter(name="sessionHashStorageKey")
    def session_hash_storage_key(self) -> Optional[bool]:
        """
        When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        """
        return pulumi.get(self, "session_hash_storage_key")

    @property
    @pulumi.getter(name="sessionHashSubject")
    def session_hash_subject(self) -> Optional[bool]:
        """
        When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        """
        return pulumi.get(self, "session_hash_subject")

    @property
    @pulumi.getter(name="sessionIdlingTimeout")
    def session_idling_timeout(self) -> Optional[float]:
        """
        The session cookie idle time in seconds.
        """
        return pulumi.get(self, "session_idling_timeout")

    @property
    @pulumi.getter(name="sessionMemcachedHost")
    def session_memcached_host(self) -> Optional[str]:
        """
        The memcached host.
        """
        return pulumi.get(self, "session_memcached_host")

    @property
    @pulumi.getter(name="sessionMemcachedPort")
    def session_memcached_port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "session_memcached_port")

    @property
    @pulumi.getter(name="sessionMemcachedPrefix")
    def session_memcached_prefix(self) -> Optional[str]:
        """
        The memcached session key prefix.
        """
        return pulumi.get(self, "session_memcached_prefix")

    @property
    @pulumi.getter(name="sessionMemcachedSocket")
    def session_memcached_socket(self) -> Optional[str]:
        """
        The memcached unix socket path.
        """
        return pulumi.get(self, "session_memcached_socket")

    @property
    @pulumi.getter(name="sessionRedisClusterMaxRedirections")
    def session_redis_cluster_max_redirections(self) -> Optional[int]:
        """
        The Redis cluster maximum redirects.
        """
        return pulumi.get(self, "session_redis_cluster_max_redirections")

    @property
    @pulumi.getter(name="sessionRedisClusterNodes")
    def session_redis_cluster_nodes(self) -> Optional[Sequence['outputs.GatewayPluginSamlConfigSessionRedisClusterNode']]:
        """
        The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        """
        return pulumi.get(self, "session_redis_cluster_nodes")

    @property
    @pulumi.getter(name="sessionRedisConnectTimeout")
    def session_redis_connect_timeout(self) -> Optional[int]:
        """
        The Redis connection timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_connect_timeout")

    @property
    @pulumi.getter(name="sessionRedisHost")
    def session_redis_host(self) -> Optional[str]:
        """
        The Redis host IP.
        """
        return pulumi.get(self, "session_redis_host")

    @property
    @pulumi.getter(name="sessionRedisPassword")
    def session_redis_password(self) -> Optional[str]:
        """
        Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
        """
        return pulumi.get(self, "session_redis_password")

    @property
    @pulumi.getter(name="sessionRedisPort")
    def session_redis_port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "session_redis_port")

    @property
    @pulumi.getter(name="sessionRedisPrefix")
    def session_redis_prefix(self) -> Optional[str]:
        """
        The Redis session key prefix.
        """
        return pulumi.get(self, "session_redis_prefix")

    @property
    @pulumi.getter(name="sessionRedisReadTimeout")
    def session_redis_read_timeout(self) -> Optional[int]:
        """
        The Redis read timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_read_timeout")

    @property
    @pulumi.getter(name="sessionRedisSendTimeout")
    def session_redis_send_timeout(self) -> Optional[int]:
        """
        The Redis send timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_send_timeout")

    @property
    @pulumi.getter(name="sessionRedisServerName")
    def session_redis_server_name(self) -> Optional[str]:
        """
        The SNI used for connecting to the Redis server.
        """
        return pulumi.get(self, "session_redis_server_name")

    @property
    @pulumi.getter(name="sessionRedisSocket")
    def session_redis_socket(self) -> Optional[str]:
        """
        The Redis unix socket path.
        """
        return pulumi.get(self, "session_redis_socket")

    @property
    @pulumi.getter(name="sessionRedisSsl")
    def session_redis_ssl(self) -> Optional[bool]:
        """
        Use SSL/TLS for the Redis connection.
        """
        return pulumi.get(self, "session_redis_ssl")

    @property
    @pulumi.getter(name="sessionRedisSslVerify")
    def session_redis_ssl_verify(self) -> Optional[bool]:
        """
        Verify the Redis server certificate.
        """
        return pulumi.get(self, "session_redis_ssl_verify")

    @property
    @pulumi.getter(name="sessionRedisUsername")
    def session_redis_username(self) -> Optional[str]:
        """
        Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
        """
        return pulumi.get(self, "session_redis_username")

    @property
    @pulumi.getter(name="sessionRemember")
    def session_remember(self) -> Optional[bool]:
        """
        Enables or disables persistent sessions
        """
        return pulumi.get(self, "session_remember")

    @property
    @pulumi.getter(name="sessionRememberAbsoluteTimeout")
    def session_remember_absolute_timeout(self) -> Optional[float]:
        """
        Persistent session absolute timeout in seconds.
        """
        return pulumi.get(self, "session_remember_absolute_timeout")

    @property
    @pulumi.getter(name="sessionRememberCookieName")
    def session_remember_cookie_name(self) -> Optional[str]:
        """
        Persistent session cookie name
        """
        return pulumi.get(self, "session_remember_cookie_name")

    @property
    @pulumi.getter(name="sessionRememberRollingTimeout")
    def session_remember_rolling_timeout(self) -> Optional[float]:
        """
        Persistent session rolling timeout in seconds.
        """
        return pulumi.get(self, "session_remember_rolling_timeout")

    @property
    @pulumi.getter(name="sessionRequestHeaders")
    def session_request_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "session_request_headers")

    @property
    @pulumi.getter(name="sessionResponseHeaders")
    def session_response_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "session_response_headers")

    @property
    @pulumi.getter(name="sessionRollingTimeout")
    def session_rolling_timeout(self) -> Optional[float]:
        """
        The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        """
        return pulumi.get(self, "session_rolling_timeout")

    @property
    @pulumi.getter(name="sessionSecret")
    def session_secret(self) -> Optional[str]:
        """
        The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
        """
        return pulumi.get(self, "session_secret")

    @property
    @pulumi.getter(name="sessionStorage")
    def session_storage(self) -> Optional[str]:
        """
        The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        """
        return pulumi.get(self, "session_storage")

    @property
    @pulumi.getter(name="sessionStoreMetadata")
    def session_store_metadata(self) -> Optional[bool]:
        """
        Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specific_audience` belonging to a specific subject.
        """
        return pulumi.get(self, "session_store_metadata")

    @property
    @pulumi.getter(name="validateAssertionSignature")
    def validate_assertion_signature(self) -> Optional[bool]:
        """
        Enable signature validation for SAML responses.
        """
        return pulumi.get(self, "validate_assertion_signature")


@pulumi.output_type
class GatewayPluginSamlConfigSessionRedisClusterNode(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str ip: A string representing a host name, such as example.com.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayPluginSamlConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginSamlConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginSamlRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginSamlService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginStatsdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowStatusCodes":
            suggest = "allow_status_codes"
        elif key == "consumerIdentifierDefault":
            suggest = "consumer_identifier_default"
        elif key == "flushTimeout":
            suggest = "flush_timeout"
        elif key == "hostnameInPrefix":
            suggest = "hostname_in_prefix"
        elif key == "queueSize":
            suggest = "queue_size"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "serviceIdentifierDefault":
            suggest = "service_identifier_default"
        elif key == "tagStyle":
            suggest = "tag_style"
        elif key == "udpPacketSize":
            suggest = "udp_packet_size"
        elif key == "useTcp":
            suggest = "use_tcp"
        elif key == "workspaceIdentifierDefault":
            suggest = "workspace_identifier_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginStatsdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginStatsdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginStatsdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_status_codes: Optional[Sequence[str]] = None,
                 consumer_identifier_default: Optional[str] = None,
                 flush_timeout: Optional[float] = None,
                 host: Optional[str] = None,
                 hostname_in_prefix: Optional[bool] = None,
                 metrics: Optional[Sequence['outputs.GatewayPluginStatsdConfigMetric']] = None,
                 port: Optional[int] = None,
                 prefix: Optional[str] = None,
                 queue: Optional['outputs.GatewayPluginStatsdConfigQueue'] = None,
                 queue_size: Optional[int] = None,
                 retry_count: Optional[int] = None,
                 service_identifier_default: Optional[str] = None,
                 tag_style: Optional[str] = None,
                 udp_packet_size: Optional[float] = None,
                 use_tcp: Optional[bool] = None,
                 workspace_identifier_default: Optional[str] = None):
        """
        :param Sequence[str] allow_status_codes: List of status code ranges that are allowed to be logged in metrics.
        :param str consumer_identifier_default: must be one of ["consumer*id", "custom*id", "username"]
        :param str host: The IP address or hostname of StatsD server to send data to.
        :param Sequence['GatewayPluginStatsdConfigMetricArgs'] metrics: List of metrics to be logged.
        :param int port: The port of StatsD server to send data to.
        :param str prefix: String to prefix to each metric's name.
        :param str service_identifier_default: must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
        :param str tag_style: must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
        :param str workspace_identifier_default: must be one of ["workspace*id", "workspace*name"]
        """
        if allow_status_codes is not None:
            pulumi.set(__self__, "allow_status_codes", allow_status_codes)
        if consumer_identifier_default is not None:
            pulumi.set(__self__, "consumer_identifier_default", consumer_identifier_default)
        if flush_timeout is not None:
            pulumi.set(__self__, "flush_timeout", flush_timeout)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hostname_in_prefix is not None:
            pulumi.set(__self__, "hostname_in_prefix", hostname_in_prefix)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if service_identifier_default is not None:
            pulumi.set(__self__, "service_identifier_default", service_identifier_default)
        if tag_style is not None:
            pulumi.set(__self__, "tag_style", tag_style)
        if udp_packet_size is not None:
            pulumi.set(__self__, "udp_packet_size", udp_packet_size)
        if use_tcp is not None:
            pulumi.set(__self__, "use_tcp", use_tcp)
        if workspace_identifier_default is not None:
            pulumi.set(__self__, "workspace_identifier_default", workspace_identifier_default)

    @property
    @pulumi.getter(name="allowStatusCodes")
    def allow_status_codes(self) -> Optional[Sequence[str]]:
        """
        List of status code ranges that are allowed to be logged in metrics.
        """
        return pulumi.get(self, "allow_status_codes")

    @property
    @pulumi.getter(name="consumerIdentifierDefault")
    def consumer_identifier_default(self) -> Optional[str]:
        """
        must be one of ["consumer*id", "custom*id", "username"]
        """
        return pulumi.get(self, "consumer_identifier_default")

    @property
    @pulumi.getter(name="flushTimeout")
    def flush_timeout(self) -> Optional[float]:
        return pulumi.get(self, "flush_timeout")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The IP address or hostname of StatsD server to send data to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="hostnameInPrefix")
    def hostname_in_prefix(self) -> Optional[bool]:
        return pulumi.get(self, "hostname_in_prefix")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.GatewayPluginStatsdConfigMetric']]:
        """
        List of metrics to be logged.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of StatsD server to send data to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        String to prefix to each metric's name.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def queue(self) -> Optional['outputs.GatewayPluginStatsdConfigQueue']:
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[int]:
        return pulumi.get(self, "queue_size")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="serviceIdentifierDefault")
    def service_identifier_default(self) -> Optional[str]:
        """
        must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
        """
        return pulumi.get(self, "service_identifier_default")

    @property
    @pulumi.getter(name="tagStyle")
    def tag_style(self) -> Optional[str]:
        """
        must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
        """
        return pulumi.get(self, "tag_style")

    @property
    @pulumi.getter(name="udpPacketSize")
    def udp_packet_size(self) -> Optional[float]:
        return pulumi.get(self, "udp_packet_size")

    @property
    @pulumi.getter(name="useTcp")
    def use_tcp(self) -> Optional[bool]:
        return pulumi.get(self, "use_tcp")

    @property
    @pulumi.getter(name="workspaceIdentifierDefault")
    def workspace_identifier_default(self) -> Optional[str]:
        """
        must be one of ["workspace*id", "workspace*name"]
        """
        return pulumi.get(self, "workspace_identifier_default")


@pulumi.output_type
class GatewayPluginStatsdConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerIdentifier":
            suggest = "consumer_identifier"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "serviceIdentifier":
            suggest = "service_identifier"
        elif key == "statType":
            suggest = "stat_type"
        elif key == "workspaceIdentifier":
            suggest = "workspace_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginStatsdConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginStatsdConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginStatsdConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_identifier: Optional[str] = None,
                 name: Optional[str] = None,
                 sample_rate: Optional[float] = None,
                 service_identifier: Optional[str] = None,
                 stat_type: Optional[str] = None,
                 workspace_identifier: Optional[str] = None):
        """
        :param str consumer_identifier: Authenticated user detail. must be one of ["consumer*id", "custom*id", "username"]
        :param str name: StatsD metric’s name. Not Null; must be one of ["kong*latency", "latency", "request*count", "request*per*user", "request*size", "response*size", "status*count", "status*count*per*user", "unique*users", "upstream*latency", "status*count*per*workspace", "status*count*per*user*per*route", "shdict*usage", "cache*datastore*hits*total", "cache*datastore*misses_total"]
        :param float sample_rate: Sampling rate
        :param str service_identifier: Service detail. must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
        :param str stat_type: Determines what sort of event a metric represents. Not Null; must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
        :param str workspace_identifier: Workspace detail. must be one of ["workspace*id", "workspace*name"]
        """
        if consumer_identifier is not None:
            pulumi.set(__self__, "consumer_identifier", consumer_identifier)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if service_identifier is not None:
            pulumi.set(__self__, "service_identifier", service_identifier)
        if stat_type is not None:
            pulumi.set(__self__, "stat_type", stat_type)
        if workspace_identifier is not None:
            pulumi.set(__self__, "workspace_identifier", workspace_identifier)

    @property
    @pulumi.getter(name="consumerIdentifier")
    def consumer_identifier(self) -> Optional[str]:
        """
        Authenticated user detail. must be one of ["consumer*id", "custom*id", "username"]
        """
        return pulumi.get(self, "consumer_identifier")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        StatsD metric’s name. Not Null; must be one of ["kong*latency", "latency", "request*count", "request*per*user", "request*size", "response*size", "status*count", "status*count*per*user", "unique*users", "upstream*latency", "status*count*per*workspace", "status*count*per*user*per*route", "shdict*usage", "cache*datastore*hits*total", "cache*datastore*misses_total"]
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        Sampling rate
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="serviceIdentifier")
    def service_identifier(self) -> Optional[str]:
        """
        Service detail. must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
        """
        return pulumi.get(self, "service_identifier")

    @property
    @pulumi.getter(name="statType")
    def stat_type(self) -> Optional[str]:
        """
        Determines what sort of event a metric represents. Not Null; must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
        """
        return pulumi.get(self, "stat_type")

    @property
    @pulumi.getter(name="workspaceIdentifier")
    def workspace_identifier(self) -> Optional[str]:
        """
        Workspace detail. must be one of ["workspace*id", "workspace*name"]
        """
        return pulumi.get(self, "workspace_identifier")


@pulumi.output_type
class GatewayPluginStatsdConfigQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialRetryDelay":
            suggest = "initial_retry_delay"
        elif key == "maxBatchSize":
            suggest = "max_batch_size"
        elif key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCoalescingDelay":
            suggest = "max_coalescing_delay"
        elif key == "maxEntries":
            suggest = "max_entries"
        elif key == "maxRetryDelay":
            suggest = "max_retry_delay"
        elif key == "maxRetryTime":
            suggest = "max_retry_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPluginStatsdConfigQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPluginStatsdConfigQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPluginStatsdConfigQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_retry_delay: Optional[float] = None,
                 max_batch_size: Optional[int] = None,
                 max_bytes: Optional[int] = None,
                 max_coalescing_delay: Optional[float] = None,
                 max_entries: Optional[int] = None,
                 max_retry_delay: Optional[float] = None,
                 max_retry_time: Optional[float] = None):
        """
        :param float initial_retry_delay: Time in seconds before the initial retry is made for a failing batch.
        :param int max_batch_size: Maximum number of entries that can be processed at a time.
        :param int max_bytes: Maximum number of bytes that can be waiting on a queue, requires string content.
        :param float max_coalescing_delay: Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        :param int max_entries: Maximum number of entries that can be waiting on the queue.
        :param float max_retry_delay: Maximum time in seconds between retries, caps exponential backoff.
        :param float max_retry_time: Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        if initial_retry_delay is not None:
            pulumi.set(__self__, "initial_retry_delay", initial_retry_delay)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_coalescing_delay is not None:
            pulumi.set(__self__, "max_coalescing_delay", max_coalescing_delay)
        if max_entries is not None:
            pulumi.set(__self__, "max_entries", max_entries)
        if max_retry_delay is not None:
            pulumi.set(__self__, "max_retry_delay", max_retry_delay)
        if max_retry_time is not None:
            pulumi.set(__self__, "max_retry_time", max_retry_time)

    @property
    @pulumi.getter(name="initialRetryDelay")
    def initial_retry_delay(self) -> Optional[float]:
        """
        Time in seconds before the initial retry is made for a failing batch.
        """
        return pulumi.get(self, "initial_retry_delay")

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[int]:
        """
        Maximum number of entries that can be processed at a time.
        """
        return pulumi.get(self, "max_batch_size")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[int]:
        """
        Maximum number of bytes that can be waiting on a queue, requires string content.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxCoalescingDelay")
    def max_coalescing_delay(self) -> Optional[float]:
        """
        Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        """
        return pulumi.get(self, "max_coalescing_delay")

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> Optional[int]:
        """
        Maximum number of entries that can be waiting on the queue.
        """
        return pulumi.get(self, "max_entries")

    @property
    @pulumi.getter(name="maxRetryDelay")
    def max_retry_delay(self) -> Optional[float]:
        """
        Maximum time in seconds between retries, caps exponential backoff.
        """
        return pulumi.get(self, "max_retry_delay")

    @property
    @pulumi.getter(name="maxRetryTime")
    def max_retry_time(self) -> Optional[float]:
        """
        Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        return pulumi.get(self, "max_retry_time")


@pulumi.output_type
class GatewayPluginStatsdConsumer(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginStatsdConsumerGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginStatsdRoute(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayPluginStatsdService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayRouteDestination(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[int] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayRouteService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayRouteSource(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 port: Optional[int] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayServiceClientCertificate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewaySniCertificate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayTargetUpstream(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayUpstreamClientCertificate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GatewayUpstreamHealthchecks(dict):
    def __init__(__self__, *,
                 active: Optional['outputs.GatewayUpstreamHealthchecksActive'] = None,
                 passive: Optional['outputs.GatewayUpstreamHealthchecksPassive'] = None,
                 threshold: Optional[float] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def active(self) -> Optional['outputs.GatewayUpstreamHealthchecksActive']:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def passive(self) -> Optional['outputs.GatewayUpstreamHealthchecksPassive']:
        return pulumi.get(self, "passive")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GatewayUpstreamHealthchecksActive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPath":
            suggest = "http_path"
        elif key == "httpsSni":
            suggest = "https_sni"
        elif key == "httpsVerifyCertificate":
            suggest = "https_verify_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayUpstreamHealthchecksActive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayUpstreamHealthchecksActive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayUpstreamHealthchecksActive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 concurrency: Optional[int] = None,
                 headers: Optional[Mapping[str, str]] = None,
                 healthy: Optional['outputs.GatewayUpstreamHealthchecksActiveHealthy'] = None,
                 http_path: Optional[str] = None,
                 https_sni: Optional[str] = None,
                 https_verify_certificate: Optional[bool] = None,
                 timeout: Optional[float] = None,
                 type: Optional[str] = None,
                 unhealthy: Optional['outputs.GatewayUpstreamHealthchecksActiveUnhealthy'] = None):
        """
        :param str type: must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if https_sni is not None:
            pulumi.set(__self__, "https_sni", https_sni)
        if https_verify_certificate is not None:
            pulumi.set(__self__, "https_verify_certificate", https_verify_certificate)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[int]:
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def healthy(self) -> Optional['outputs.GatewayUpstreamHealthchecksActiveHealthy']:
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[str]:
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter(name="httpsSni")
    def https_sni(self) -> Optional[str]:
        return pulumi.get(self, "https_sni")

    @property
    @pulumi.getter(name="httpsVerifyCertificate")
    def https_verify_certificate(self) -> Optional[bool]:
        return pulumi.get(self, "https_verify_certificate")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[float]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unhealthy(self) -> Optional['outputs.GatewayUpstreamHealthchecksActiveUnhealthy']:
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class GatewayUpstreamHealthchecksActiveHealthy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatuses":
            suggest = "http_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayUpstreamHealthchecksActiveHealthy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayUpstreamHealthchecksActiveHealthy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayUpstreamHealthchecksActiveHealthy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_statuses: Optional[Sequence[int]] = None,
                 interval: Optional[float] = None,
                 successes: Optional[int] = None):
        if http_statuses is not None:
            pulumi.set(__self__, "http_statuses", http_statuses)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if successes is not None:
            pulumi.set(__self__, "successes", successes)

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def successes(self) -> Optional[int]:
        return pulumi.get(self, "successes")


@pulumi.output_type
class GatewayUpstreamHealthchecksActiveUnhealthy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFailures":
            suggest = "http_failures"
        elif key == "httpStatuses":
            suggest = "http_statuses"
        elif key == "tcpFailures":
            suggest = "tcp_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayUpstreamHealthchecksActiveUnhealthy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayUpstreamHealthchecksActiveUnhealthy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayUpstreamHealthchecksActiveUnhealthy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_failures: Optional[int] = None,
                 http_statuses: Optional[Sequence[int]] = None,
                 interval: Optional[float] = None,
                 tcp_failures: Optional[int] = None,
                 timeouts: Optional[int] = None):
        if http_failures is not None:
            pulumi.set(__self__, "http_failures", http_failures)
        if http_statuses is not None:
            pulumi.set(__self__, "http_statuses", http_statuses)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_failures is not None:
            pulumi.set(__self__, "tcp_failures", tcp_failures)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="httpFailures")
    def http_failures(self) -> Optional[int]:
        return pulumi.get(self, "http_failures")

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def interval(self) -> Optional[float]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="tcpFailures")
    def tcp_failures(self) -> Optional[int]:
        return pulumi.get(self, "tcp_failures")

    @property
    @pulumi.getter
    def timeouts(self) -> Optional[int]:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GatewayUpstreamHealthchecksPassive(dict):
    def __init__(__self__, *,
                 healthy: Optional['outputs.GatewayUpstreamHealthchecksPassiveHealthy'] = None,
                 type: Optional[str] = None,
                 unhealthy: Optional['outputs.GatewayUpstreamHealthchecksPassiveUnhealthy'] = None):
        """
        :param str type: must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter
    def healthy(self) -> Optional['outputs.GatewayUpstreamHealthchecksPassiveHealthy']:
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unhealthy(self) -> Optional['outputs.GatewayUpstreamHealthchecksPassiveUnhealthy']:
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class GatewayUpstreamHealthchecksPassiveHealthy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatuses":
            suggest = "http_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayUpstreamHealthchecksPassiveHealthy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayUpstreamHealthchecksPassiveHealthy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayUpstreamHealthchecksPassiveHealthy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_statuses: Optional[Sequence[int]] = None,
                 successes: Optional[int] = None):
        if http_statuses is not None:
            pulumi.set(__self__, "http_statuses", http_statuses)
        if successes is not None:
            pulumi.set(__self__, "successes", successes)

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def successes(self) -> Optional[int]:
        return pulumi.get(self, "successes")


@pulumi.output_type
class GatewayUpstreamHealthchecksPassiveUnhealthy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFailures":
            suggest = "http_failures"
        elif key == "httpStatuses":
            suggest = "http_statuses"
        elif key == "tcpFailures":
            suggest = "tcp_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayUpstreamHealthchecksPassiveUnhealthy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayUpstreamHealthchecksPassiveUnhealthy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayUpstreamHealthchecksPassiveUnhealthy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_failures: Optional[int] = None,
                 http_statuses: Optional[Sequence[int]] = None,
                 tcp_failures: Optional[int] = None,
                 timeouts: Optional[int] = None):
        if http_failures is not None:
            pulumi.set(__self__, "http_failures", http_failures)
        if http_statuses is not None:
            pulumi.set(__self__, "http_statuses", http_statuses)
        if tcp_failures is not None:
            pulumi.set(__self__, "tcp_failures", tcp_failures)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="httpFailures")
    def http_failures(self) -> Optional[int]:
        return pulumi.get(self, "http_failures")

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter(name="tcpFailures")
    def tcp_failures(self) -> Optional[int]:
        return pulumi.get(self, "tcp_failures")

    @property
    @pulumi.getter
    def timeouts(self) -> Optional[int]:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class PortalAppearanceCustomFonts(dict):
    def __init__(__self__, *,
                 base: Optional[str] = None,
                 code: Optional[str] = None,
                 headings: Optional[str] = None):
        """
        :param str base: The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        :param str code: The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        :param str headings: The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if headings is not None:
            pulumi.set(__self__, "headings", headings)

    @property
    @pulumi.getter
    def base(self) -> Optional[str]:
        """
        The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def headings(self) -> Optional[str]:
        """
        The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "headings")


@pulumi.output_type
class PortalAppearanceCustomTheme(dict):
    def __init__(__self__, *,
                 colors: Optional['outputs.PortalAppearanceCustomThemeColors'] = None):
        """
        :param 'PortalAppearanceCustomThemeColorsArgs' colors: Not Null
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)

    @property
    @pulumi.getter
    def colors(self) -> Optional['outputs.PortalAppearanceCustomThemeColors']:
        """
        Not Null
        """
        return pulumi.get(self, "colors")


@pulumi.output_type
class PortalAppearanceCustomThemeColors(dict):
    def __init__(__self__, *,
                 button: Optional['outputs.PortalAppearanceCustomThemeColorsButton'] = None,
                 section: Optional['outputs.PortalAppearanceCustomThemeColorsSection'] = None,
                 text: Optional['outputs.PortalAppearanceCustomThemeColorsText'] = None):
        """
        :param 'PortalAppearanceCustomThemeColorsButtonArgs' button: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionArgs' section: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextArgs' text: Not Null
        """
        if button is not None:
            pulumi.set(__self__, "button", button)
        if section is not None:
            pulumi.set(__self__, "section", section)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def button(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsButton']:
        """
        Not Null
        """
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def section(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSection']:
        """
        Not Null
        """
        return pulumi.get(self, "section")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsText']:
        """
        Not Null
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsButton(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryFill":
            suggest = "primary_fill"
        elif key == "primaryText":
            suggest = "primary_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalAppearanceCustomThemeColorsButton. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalAppearanceCustomThemeColorsButton.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalAppearanceCustomThemeColorsButton.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_fill: Optional['outputs.PortalAppearanceCustomThemeColorsButtonPrimaryFill'] = None,
                 primary_text: Optional['outputs.PortalAppearanceCustomThemeColorsButtonPrimaryText'] = None):
        """
        :param 'PortalAppearanceCustomThemeColorsButtonPrimaryFillArgs' primary_fill: Not Null
        :param 'PortalAppearanceCustomThemeColorsButtonPrimaryTextArgs' primary_text: Not Null
        """
        if primary_fill is not None:
            pulumi.set(__self__, "primary_fill", primary_fill)
        if primary_text is not None:
            pulumi.set(__self__, "primary_text", primary_text)

    @property
    @pulumi.getter(name="primaryFill")
    def primary_fill(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsButtonPrimaryFill']:
        """
        Not Null
        """
        return pulumi.get(self, "primary_fill")

    @property
    @pulumi.getter(name="primaryText")
    def primary_text(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsButtonPrimaryText']:
        """
        Not Null
        """
        return pulumi.get(self, "primary_text")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsButtonPrimaryFill(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsButtonPrimaryText(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSection(dict):
    def __init__(__self__, *,
                 accent: Optional['outputs.PortalAppearanceCustomThemeColorsSectionAccent'] = None,
                 body: Optional['outputs.PortalAppearanceCustomThemeColorsSectionBody'] = None,
                 footer: Optional['outputs.PortalAppearanceCustomThemeColorsSectionFooter'] = None,
                 header: Optional['outputs.PortalAppearanceCustomThemeColorsSectionHeader'] = None,
                 hero: Optional['outputs.PortalAppearanceCustomThemeColorsSectionHero'] = None,
                 stroke: Optional['outputs.PortalAppearanceCustomThemeColorsSectionStroke'] = None,
                 tertiary: Optional['outputs.PortalAppearanceCustomThemeColorsSectionTertiary'] = None):
        """
        :param 'PortalAppearanceCustomThemeColorsSectionAccentArgs' accent: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionBodyArgs' body: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionFooterArgs' footer: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionHeaderArgs' header: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionHeroArgs' hero: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionStrokeArgs' stroke: Not Null
        :param 'PortalAppearanceCustomThemeColorsSectionTertiaryArgs' tertiary: Not Null
        """
        if accent is not None:
            pulumi.set(__self__, "accent", accent)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if footer is not None:
            pulumi.set(__self__, "footer", footer)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if hero is not None:
            pulumi.set(__self__, "hero", hero)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if tertiary is not None:
            pulumi.set(__self__, "tertiary", tertiary)

    @property
    @pulumi.getter
    def accent(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionAccent']:
        """
        Not Null
        """
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionBody']:
        """
        Not Null
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def footer(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionFooter']:
        """
        Not Null
        """
        return pulumi.get(self, "footer")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionHeader']:
        """
        Not Null
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def hero(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionHero']:
        """
        Not Null
        """
        return pulumi.get(self, "hero")

    @property
    @pulumi.getter
    def stroke(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionStroke']:
        """
        Not Null
        """
        return pulumi.get(self, "stroke")

    @property
    @pulumi.getter
    def tertiary(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsSectionTertiary']:
        """
        Not Null
        """
        return pulumi.get(self, "tertiary")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionAccent(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionBody(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionFooter(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionHeader(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionHero(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionStroke(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsSectionTertiary(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsText(dict):
    def __init__(__self__, *,
                 accent: Optional['outputs.PortalAppearanceCustomThemeColorsTextAccent'] = None,
                 footer: Optional['outputs.PortalAppearanceCustomThemeColorsTextFooter'] = None,
                 header: Optional['outputs.PortalAppearanceCustomThemeColorsTextHeader'] = None,
                 headings: Optional['outputs.PortalAppearanceCustomThemeColorsTextHeadings'] = None,
                 hero: Optional['outputs.PortalAppearanceCustomThemeColorsTextHero'] = None,
                 link: Optional['outputs.PortalAppearanceCustomThemeColorsTextLink'] = None,
                 primary: Optional['outputs.PortalAppearanceCustomThemeColorsTextPrimary'] = None,
                 secondary: Optional['outputs.PortalAppearanceCustomThemeColorsTextSecondary'] = None):
        """
        :param 'PortalAppearanceCustomThemeColorsTextAccentArgs' accent: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextFooterArgs' footer: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextHeaderArgs' header: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextHeadingsArgs' headings: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextHeroArgs' hero: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextLinkArgs' link: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextPrimaryArgs' primary: Not Null
        :param 'PortalAppearanceCustomThemeColorsTextSecondaryArgs' secondary: Not Null
        """
        if accent is not None:
            pulumi.set(__self__, "accent", accent)
        if footer is not None:
            pulumi.set(__self__, "footer", footer)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if headings is not None:
            pulumi.set(__self__, "headings", headings)
        if hero is not None:
            pulumi.set(__self__, "hero", hero)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def accent(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextAccent']:
        """
        Not Null
        """
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter
    def footer(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextFooter']:
        """
        Not Null
        """
        return pulumi.get(self, "footer")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextHeader']:
        """
        Not Null
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def headings(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextHeadings']:
        """
        Not Null
        """
        return pulumi.get(self, "headings")

    @property
    @pulumi.getter
    def hero(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextHero']:
        """
        Not Null
        """
        return pulumi.get(self, "hero")

    @property
    @pulumi.getter
    def link(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextLink']:
        """
        Not Null
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def primary(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextPrimary']:
        """
        Not Null
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.PortalAppearanceCustomThemeColorsTextSecondary']:
        """
        Not Null
        """
        return pulumi.get(self, "secondary")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextAccent(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextFooter(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextHeader(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextHeadings(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextHero(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextLink(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextPrimary(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceCustomThemeColorsTextSecondary(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Not Null
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PortalAppearanceImages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogCover":
            suggest = "catalog_cover"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalAppearanceImages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalAppearanceImages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalAppearanceImages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_cover: Optional['outputs.PortalAppearanceImagesCatalogCover'] = None,
                 favicon: Optional['outputs.PortalAppearanceImagesFavicon'] = None,
                 logo: Optional['outputs.PortalAppearanceImagesLogo'] = None):
        """
        :param 'PortalAppearanceImagesCatalogCoverArgs' catalog_cover: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data*URLs.
        :param 'PortalAppearanceImagesFaviconArgs' favicon: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
        :param 'PortalAppearanceImagesLogoArgs' logo: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
        """
        if catalog_cover is not None:
            pulumi.set(__self__, "catalog_cover", catalog_cover)
        if favicon is not None:
            pulumi.set(__self__, "favicon", favicon)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @property
    @pulumi.getter(name="catalogCover")
    def catalog_cover(self) -> Optional['outputs.PortalAppearanceImagesCatalogCover']:
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data*URLs.
        """
        return pulumi.get(self, "catalog_cover")

    @property
    @pulumi.getter
    def favicon(self) -> Optional['outputs.PortalAppearanceImagesFavicon']:
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
        """
        return pulumi.get(self, "favicon")

    @property
    @pulumi.getter
    def logo(self) -> Optional['outputs.PortalAppearanceImagesLogo']:
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
        """
        return pulumi.get(self, "logo")


@pulumi.output_type
class PortalAppearanceImagesCatalogCover(dict):
    def __init__(__self__, *,
                 data: Optional[str] = None,
                 filename: Optional[str] = None):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        if data is not None:
            pulumi.set(__self__, "data", data)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class PortalAppearanceImagesFavicon(dict):
    def __init__(__self__, *,
                 data: Optional[str] = None,
                 filename: Optional[str] = None):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        if data is not None:
            pulumi.set(__self__, "data", data)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class PortalAppearanceImagesLogo(dict):
    def __init__(__self__, *,
                 data: Optional[str] = None,
                 filename: Optional[str] = None):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        if data is not None:
            pulumi.set(__self__, "data", data)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\\n\\n. Not Null
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class PortalAppearanceText(dict):
    def __init__(__self__, *,
                 catalog: Optional['outputs.PortalAppearanceTextCatalog'] = None):
        """
        :param 'PortalAppearanceTextCatalogArgs' catalog: Not Null
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)

    @property
    @pulumi.getter
    def catalog(self) -> Optional['outputs.PortalAppearanceTextCatalog']:
        """
        Not Null
        """
        return pulumi.get(self, "catalog")


@pulumi.output_type
class PortalAppearanceTextCatalog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryHeader":
            suggest = "primary_header"
        elif key == "welcomeMessage":
            suggest = "welcome_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalAppearanceTextCatalog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalAppearanceTextCatalog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalAppearanceTextCatalog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_header: Optional[str] = None,
                 welcome_message: Optional[str] = None):
        """
        :param str primary_header: Not Null
        :param str welcome_message: Not Null
        """
        if primary_header is not None:
            pulumi.set(__self__, "primary_header", primary_header)
        if welcome_message is not None:
            pulumi.set(__self__, "welcome_message", welcome_message)

    @property
    @pulumi.getter(name="primaryHeader")
    def primary_header(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "primary_header")

    @property
    @pulumi.getter(name="welcomeMessage")
    def welcome_message(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "welcome_message")


@pulumi.output_type
class PortalAuthOidcClaimMappings(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 groups: Optional[str] = None,
                 name: Optional[str] = None):
        if email is not None:
            pulumi.set(__self__, "email", email)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def groups(self) -> Optional[str]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class PortalAuthOidcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimMappings":
            suggest = "claim_mappings"
        elif key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalAuthOidcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalAuthOidcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalAuthOidcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_mappings: Optional['outputs.PortalAuthOidcConfigClaimMappings'] = None,
                 client_id: Optional[str] = None,
                 issuer: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param 'PortalAuthOidcConfigClaimMappingsArgs' claim_mappings: Mappings from a portal developer atribute to an Identity Provider claim.
        """
        if claim_mappings is not None:
            pulumi.set(__self__, "claim_mappings", claim_mappings)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="claimMappings")
    def claim_mappings(self) -> Optional['outputs.PortalAuthOidcConfigClaimMappings']:
        """
        Mappings from a portal developer atribute to an Identity Provider claim.
        """
        return pulumi.get(self, "claim_mappings")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")


@pulumi.output_type
class PortalAuthOidcConfigClaimMappings(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 groups: Optional[str] = None,
                 name: Optional[str] = None):
        if email is not None:
            pulumi.set(__self__, "email", email)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def groups(self) -> Optional[str]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class PortalProductVersionAuthStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredentials":
            suggest = "client_credentials"
        elif key == "keyAuth":
            suggest = "key_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalProductVersionAuthStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalProductVersionAuthStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalProductVersionAuthStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credentials: Optional['outputs.PortalProductVersionAuthStrategyClientCredentials'] = None,
                 key_auth: Optional['outputs.PortalProductVersionAuthStrategyKeyAuth'] = None):
        """
        :param 'PortalProductVersionAuthStrategyClientCredentialsArgs' client_credentials: Client Credential Auth strategy that the application uses.
        :param 'PortalProductVersionAuthStrategyKeyAuthArgs' key_auth: KeyAuth Auth strategy that the application uses.
        """
        if client_credentials is not None:
            pulumi.set(__self__, "client_credentials", client_credentials)
        if key_auth is not None:
            pulumi.set(__self__, "key_auth", key_auth)

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional['outputs.PortalProductVersionAuthStrategyClientCredentials']:
        """
        Client Credential Auth strategy that the application uses.
        """
        return pulumi.get(self, "client_credentials")

    @property
    @pulumi.getter(name="keyAuth")
    def key_auth(self) -> Optional['outputs.PortalProductVersionAuthStrategyKeyAuth']:
        """
        KeyAuth Auth strategy that the application uses.
        """
        return pulumi.get(self, "key_auth")


@pulumi.output_type
class PortalProductVersionAuthStrategyClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethods":
            suggest = "auth_methods"
        elif key == "credentialType":
            suggest = "credential_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalProductVersionAuthStrategyClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalProductVersionAuthStrategyClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalProductVersionAuthStrategyClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_methods: Optional[Sequence[str]] = None,
                 credential_type: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str credential_type: must be one of ["client*credentials", "self*managed*client*credentials"]
        :param str id: The Application Auth Strategy ID.
        """
        if auth_methods is not None:
            pulumi.set(__self__, "auth_methods", auth_methods)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        must be one of ["client*credentials", "self*managed*client*credentials"]
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Application Auth Strategy ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class PortalProductVersionAuthStrategyKeyAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialType":
            suggest = "credential_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalProductVersionAuthStrategyKeyAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalProductVersionAuthStrategyKeyAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalProductVersionAuthStrategyKeyAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_type: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str credential_type: must be one of ["key_auth"]
        :param str id: The Application Auth Strategy ID.
        """
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        must be one of ["key_auth"]
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Application Auth Strategy ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ServerlessCloudGatewayControlPlane(dict):
    def __init__(__self__, *,
                 id: str,
                 prefix: str,
                 region: str):
        """
        :param str id: ID of the serverless cloud gateway CP. Requires replacement if changed.
        :param str prefix: The prefix of the serverless cloud gateway CP. Requires replacement if changed.
        :param str region: The control plane region. Requires replacement if changed. ; must be one of ["us", "eu", "au"]
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the serverless cloud gateway CP. Requires replacement if changed.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The prefix of the serverless cloud gateway CP. Requires replacement if changed.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The control plane region. Requires replacement if changed. ; must be one of ["us", "eu", "au"]
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetApiProductDocumentMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetApiProductPortalResult(dict):
    def __init__(__self__, *,
                 portal_id: str,
                 portal_name: str):
        pulumi.set(__self__, "portal_id", portal_id)
        pulumi.set(__self__, "portal_name", portal_name)

    @property
    @pulumi.getter(name="portalId")
    def portal_id(self) -> str:
        return pulumi.get(self, "portal_id")

    @property
    @pulumi.getter(name="portalName")
    def portal_name(self) -> str:
        return pulumi.get(self, "portal_name")


@pulumi.output_type
class GetApiProductVersionGatewayServiceResult(dict):
    def __init__(__self__, *,
                 control_plane_id: str,
                 id: str,
                 runtime_group_id: str):
        """
        :param str control_plane_id: The identifier of the control plane that the gateway service resides in
        :param str id: The identifier of a gateway service associated with the version of the API product.
        :param str runtime_group_id: This field is deprecated, please use `control_plane_id` instead. The identifier of the control plane that the gateway service resides in
        """
        pulumi.set(__self__, "control_plane_id", control_plane_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "runtime_group_id", runtime_group_id)

    @property
    @pulumi.getter(name="controlPlaneId")
    def control_plane_id(self) -> str:
        """
        The identifier of the control plane that the gateway service resides in
        """
        return pulumi.get(self, "control_plane_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The identifier of a gateway service associated with the version of the API product.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="runtimeGroupId")
    def runtime_group_id(self) -> str:
        """
        This field is deprecated, please use `control_plane_id` instead. The identifier of the control plane that the gateway service resides in
        """
        return pulumi.get(self, "runtime_group_id")


@pulumi.output_type
class GetApiProductVersionPortalResult(dict):
    def __init__(__self__, *,
                 application_registration_enabled: bool,
                 auth_strategies: Sequence['outputs.GetApiProductVersionPortalAuthStrategyResult'],
                 auto_approve_registration: bool,
                 deprecated: bool,
                 portal_id: str,
                 portal_name: str,
                 portal_product_version_id: str,
                 publish_status: str):
        """
        :param str publish_status: must be one of ["published", "unpublished"]
        """
        pulumi.set(__self__, "application_registration_enabled", application_registration_enabled)
        pulumi.set(__self__, "auth_strategies", auth_strategies)
        pulumi.set(__self__, "auto_approve_registration", auto_approve_registration)
        pulumi.set(__self__, "deprecated", deprecated)
        pulumi.set(__self__, "portal_id", portal_id)
        pulumi.set(__self__, "portal_name", portal_name)
        pulumi.set(__self__, "portal_product_version_id", portal_product_version_id)
        pulumi.set(__self__, "publish_status", publish_status)

    @property
    @pulumi.getter(name="applicationRegistrationEnabled")
    def application_registration_enabled(self) -> bool:
        return pulumi.get(self, "application_registration_enabled")

    @property
    @pulumi.getter(name="authStrategies")
    def auth_strategies(self) -> Sequence['outputs.GetApiProductVersionPortalAuthStrategyResult']:
        return pulumi.get(self, "auth_strategies")

    @property
    @pulumi.getter(name="autoApproveRegistration")
    def auto_approve_registration(self) -> bool:
        return pulumi.get(self, "auto_approve_registration")

    @property
    @pulumi.getter
    def deprecated(self) -> bool:
        return pulumi.get(self, "deprecated")

    @property
    @pulumi.getter(name="portalId")
    def portal_id(self) -> str:
        return pulumi.get(self, "portal_id")

    @property
    @pulumi.getter(name="portalName")
    def portal_name(self) -> str:
        return pulumi.get(self, "portal_name")

    @property
    @pulumi.getter(name="portalProductVersionId")
    def portal_product_version_id(self) -> str:
        return pulumi.get(self, "portal_product_version_id")

    @property
    @pulumi.getter(name="publishStatus")
    def publish_status(self) -> str:
        """
        must be one of ["published", "unpublished"]
        """
        return pulumi.get(self, "publish_status")


@pulumi.output_type
class GetApiProductVersionPortalAuthStrategyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApplicationAuthStrategyKeyAuthResult(dict):
    def __init__(__self__, *,
                 active: bool,
                 configs: 'outputs.GetApplicationAuthStrategyKeyAuthConfigsResult',
                 created_at: str,
                 dcr_provider: 'outputs.GetApplicationAuthStrategyKeyAuthDcrProviderResult',
                 display_name: str,
                 id: str,
                 name: str,
                 strategy_type: str,
                 updated_at: str):
        """
        :param bool active: At least one published product version is using this auth strategy.
        :param 'GetApplicationAuthStrategyKeyAuthConfigsArgs' configs: JSON-B object containing the configuration for the Key Auth strategy
        :param str created_at: An ISO-8601 timestamp representation of entity creation date.
        :param str display_name: The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str name: The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        :param str strategy_type: must be one of ["key_auth"]
        :param str updated_at: An ISO-8601 timestamp representation of entity update date.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "dcr_provider", dcr_provider)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        At least one published product version is using this auth strategy.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def configs(self) -> 'outputs.GetApplicationAuthStrategyKeyAuthConfigsResult':
        """
        JSON-B object containing the configuration for the Key Auth strategy
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dcrProvider")
    def dcr_provider(self) -> 'outputs.GetApplicationAuthStrategyKeyAuthDcrProviderResult':
        return pulumi.get(self, "dcr_provider")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> str:
        """
        must be one of ["key_auth"]
        """
        return pulumi.get(self, "strategy_type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetApplicationAuthStrategyKeyAuthConfigsResult(dict):
    def __init__(__self__, *,
                 key_auth: 'outputs.GetApplicationAuthStrategyKeyAuthConfigsKeyAuthResult'):
        """
        :param 'GetApplicationAuthStrategyKeyAuthConfigsKeyAuthArgs' key_auth: The most basic mode to configure an Application Auth Strategy for an API Product Version. 
               Using this mode will allow developers to generate API keys that will authenticate their application requests. 
               Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
        """
        pulumi.set(__self__, "key_auth", key_auth)

    @property
    @pulumi.getter(name="keyAuth")
    def key_auth(self) -> 'outputs.GetApplicationAuthStrategyKeyAuthConfigsKeyAuthResult':
        """
        The most basic mode to configure an Application Auth Strategy for an API Product Version. 
        Using this mode will allow developers to generate API keys that will authenticate their application requests. 
        Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
        """
        return pulumi.get(self, "key_auth")


@pulumi.output_type
class GetApplicationAuthStrategyKeyAuthConfigsKeyAuthResult(dict):
    def __init__(__self__, *,
                 key_names: Sequence[str]):
        """
        :param Sequence[str] key_names: The names of the headers containing the API key. You can specify multiple header names.
        """
        pulumi.set(__self__, "key_names", key_names)

    @property
    @pulumi.getter(name="keyNames")
    def key_names(self) -> Sequence[str]:
        """
        The names of the headers containing the API key. You can specify multiple header names.
        """
        return pulumi.get(self, "key_names")


@pulumi.output_type
class GetApplicationAuthStrategyKeyAuthDcrProviderResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 name: str,
                 provider_type: str):
        """
        :param str display_name: The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str provider_type: The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> str:
        """
        The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetApplicationAuthStrategyOpenidConnectResult(dict):
    def __init__(__self__, *,
                 active: bool,
                 configs: 'outputs.GetApplicationAuthStrategyOpenidConnectConfigsResult',
                 created_at: str,
                 dcr_provider: 'outputs.GetApplicationAuthStrategyOpenidConnectDcrProviderResult',
                 display_name: str,
                 id: str,
                 name: str,
                 strategy_type: str,
                 updated_at: str):
        """
        :param bool active: At least one published product version is using this auth strategy.
        :param 'GetApplicationAuthStrategyOpenidConnectConfigsArgs' configs: JSON-B object containing the configuration for the OIDC strategy
        :param str created_at: An ISO-8601 timestamp representation of entity creation date.
        :param str display_name: The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str name: The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        :param str strategy_type: must be one of ["openid_connect"]
        :param str updated_at: An ISO-8601 timestamp representation of entity update date.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "dcr_provider", dcr_provider)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        At least one published product version is using this auth strategy.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def configs(self) -> 'outputs.GetApplicationAuthStrategyOpenidConnectConfigsResult':
        """
        JSON-B object containing the configuration for the OIDC strategy
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dcrProvider")
    def dcr_provider(self) -> 'outputs.GetApplicationAuthStrategyOpenidConnectDcrProviderResult':
        return pulumi.get(self, "dcr_provider")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> str:
        """
        must be one of ["openid_connect"]
        """
        return pulumi.get(self, "strategy_type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetApplicationAuthStrategyOpenidConnectConfigsResult(dict):
    def __init__(__self__, *,
                 openid_connect: 'outputs.GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnectResult'):
        """
        :param 'GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnectArgs' openid_connect: A more advanced mode to configure an API Product Version’s Application Auth Strategy. 
               Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests. 
               Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy. 
               An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
        """
        pulumi.set(__self__, "openid_connect", openid_connect)

    @property
    @pulumi.getter(name="openidConnect")
    def openid_connect(self) -> 'outputs.GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnectResult':
        """
        A more advanced mode to configure an API Product Version’s Application Auth Strategy. 
        Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests. 
        Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy. 
        An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
        """
        return pulumi.get(self, "openid_connect")


@pulumi.output_type
class GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnectResult(dict):
    def __init__(__self__, *,
                 additional_properties: str,
                 auth_methods: Sequence[str],
                 credential_claims: Sequence[str],
                 issuer: str,
                 scopes: Sequence[str]):
        """
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "additional_properties", additional_properties)
        pulumi.set(__self__, "auth_methods", auth_methods)
        pulumi.set(__self__, "credential_claims", credential_claims)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> str:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Sequence[str]:
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="credentialClaims")
    def credential_claims(self) -> Sequence[str]:
        return pulumi.get(self, "credential_claims")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetApplicationAuthStrategyOpenidConnectDcrProviderResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 name: str,
                 provider_type: str):
        """
        :param str display_name: The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        :param str id: Contains a unique identifier used for this resource.
        :param str provider_type: The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> str:
        """
        The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
        """
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupResult(dict):
    def __init__(__self__, *,
                 autoscale: 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleResult',
                 cloud_gateway_network_id: str,
                 created_at: str,
                 egress_ip_addresses: Sequence[str],
                 id: str,
                 private_ip_addresses: Sequence[str],
                 provider: str,
                 region: str,
                 state: str,
                 updated_at: str):
        """
        :param str created_at: An RFC-3339 timestamp representation of data-plane group creation date.
        :param Sequence[str] egress_ip_addresses: List of egress IP addresses for the network that this data-plane group runs on.
        :param str id: ID of the data-plane group that represents a deployment target for a set of data-planes.
        :param Sequence[str] private_ip_addresses: List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
        :param str provider: Name of cloud provider. must be one of ["aws"]
        :param str region: Region ID for cloud provider region.
        :param str state: State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
        :param str updated_at: An RFC-3339 timestamp representation of data-plane group update date.
        """
        pulumi.set(__self__, "autoscale", autoscale)
        pulumi.set(__self__, "cloud_gateway_network_id", cloud_gateway_network_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "egress_ip_addresses", egress_ip_addresses)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def autoscale(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleResult':
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudGatewayNetworkId")
    def cloud_gateway_network_id(self) -> str:
        return pulumi.get(self, "cloud_gateway_network_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        An RFC-3339 timestamp representation of data-plane group creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="egressIpAddresses")
    def egress_ip_addresses(self) -> Sequence[str]:
        """
        List of egress IP addresses for the network that this data-plane group runs on.
        """
        return pulumi.get(self, "egress_ip_addresses")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the data-plane group that represents a deployment target for a set of data-planes.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[str]:
        """
        List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Name of cloud provider. must be one of ["aws"]
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region ID for cloud provider region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        An RFC-3339 timestamp representation of data-plane group update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupAutoscaleResult(dict):
    def __init__(__self__, *,
                 configuration_data_plane_group_autoscale_autopilot: 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult',
                 configuration_data_plane_group_autoscale_static: 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult'):
        """
        :param 'GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotArgs' configuration_data_plane_group_autoscale_autopilot: Object that describes the autopilot autoscaling strategy.
        :param 'GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticArgs' configuration_data_plane_group_autoscale_static: Object that describes the static autoscaling strategy.
        """
        pulumi.set(__self__, "configuration_data_plane_group_autoscale_autopilot", configuration_data_plane_group_autoscale_autopilot)
        pulumi.set(__self__, "configuration_data_plane_group_autoscale_static", configuration_data_plane_group_autoscale_static)

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleAutopilot")
    def configuration_data_plane_group_autoscale_autopilot(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult':
        """
        Object that describes the autopilot autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_autopilot")

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleStatic")
    def configuration_data_plane_group_autoscale_static(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult':
        """
        Object that describes the static autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_static")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult(dict):
    def __init__(__self__, *,
                 base_rps: int,
                 kind: str,
                 max_rps: int):
        """
        :param int base_rps: Base number of requests per second that the deployment target should support.
        :param str kind: must be one of ["autopilot"]
        :param int max_rps: Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        pulumi.set(__self__, "base_rps", base_rps)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "max_rps", max_rps)

    @property
    @pulumi.getter(name="baseRps")
    def base_rps(self) -> int:
        """
        Base number of requests per second that the deployment target should support.
        """
        return pulumi.get(self, "base_rps")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        must be one of ["autopilot"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="maxRps")
    def max_rps(self) -> int:
        """
        Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        return pulumi.get(self, "max_rps")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult(dict):
    def __init__(__self__, *,
                 instance_type: str,
                 kind: str,
                 requested_instances: int):
        """
        :param str instance_type: Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        :param str kind: must be one of ["static"]
        :param int requested_instances: Number of data-planes the deployment target will contain.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "requested_instances", requested_instances)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        must be one of ["static"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="requestedInstances")
    def requested_instances(self) -> int:
        """
        Number of data-planes the deployment target will contain.
        """
        return pulumi.get(self, "requested_instances")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupConfigResult(dict):
    def __init__(__self__, *,
                 autoscale: 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleResult',
                 cloud_gateway_network_id: str,
                 provider: str,
                 region: str):
        """
        :param str provider: Name of cloud provider. must be one of ["aws"]
        :param str region: Region ID for cloud provider region.
        """
        pulumi.set(__self__, "autoscale", autoscale)
        pulumi.set(__self__, "cloud_gateway_network_id", cloud_gateway_network_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def autoscale(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleResult':
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="cloudGatewayNetworkId")
    def cloud_gateway_network_id(self) -> str:
        return pulumi.get(self, "cloud_gateway_network_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Name of cloud provider. must be one of ["aws"]
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region ID for cloud provider region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleResult(dict):
    def __init__(__self__, *,
                 configuration_data_plane_group_autoscale_autopilot: 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult',
                 configuration_data_plane_group_autoscale_static: 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult'):
        """
        :param 'GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotArgs' configuration_data_plane_group_autoscale_autopilot: Object that describes the autopilot autoscaling strategy.
        :param 'GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticArgs' configuration_data_plane_group_autoscale_static: Object that describes the static autoscaling strategy.
        """
        pulumi.set(__self__, "configuration_data_plane_group_autoscale_autopilot", configuration_data_plane_group_autoscale_autopilot)
        pulumi.set(__self__, "configuration_data_plane_group_autoscale_static", configuration_data_plane_group_autoscale_static)

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleAutopilot")
    def configuration_data_plane_group_autoscale_autopilot(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult':
        """
        Object that describes the autopilot autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_autopilot")

    @property
    @pulumi.getter(name="configurationDataPlaneGroupAutoscaleStatic")
    def configuration_data_plane_group_autoscale_static(self) -> 'outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult':
        """
        Object that describes the static autoscaling strategy.
        """
        return pulumi.get(self, "configuration_data_plane_group_autoscale_static")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilotResult(dict):
    def __init__(__self__, *,
                 base_rps: int,
                 kind: str,
                 max_rps: int):
        """
        :param int base_rps: Base number of requests per second that the deployment target should support.
        :param str kind: must be one of ["autopilot"]
        :param int max_rps: Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        pulumi.set(__self__, "base_rps", base_rps)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "max_rps", max_rps)

    @property
    @pulumi.getter(name="baseRps")
    def base_rps(self) -> int:
        """
        Base number of requests per second that the deployment target should support.
        """
        return pulumi.get(self, "base_rps")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        must be one of ["autopilot"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="maxRps")
    def max_rps(self) -> int:
        """
        Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
        """
        return pulumi.get(self, "max_rps")


@pulumi.output_type
class GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStaticResult(dict):
    def __init__(__self__, *,
                 instance_type: str,
                 kind: str,
                 requested_instances: int):
        """
        :param str instance_type: Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        :param str kind: must be one of ["static"]
        :param int requested_instances: Number of data-planes the deployment target will contain.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "requested_instances", requested_instances)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        must be one of ["static"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="requestedInstances")
    def requested_instances(self) -> int:
        """
        Number of data-planes the deployment target will contain.
        """
        return pulumi.get(self, "requested_instances")


@pulumi.output_type
class GetCloudGatewayCustomDomainStateMetadataResult(dict):
    def __init__(__self__, *,
                 reason: str,
                 reported_status: str):
        """
        :param str reason: Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
        :param str reported_status: Reported status of the custom domain from backing infrastructure.
        """
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "reported_status", reported_status)

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter(name="reportedStatus")
    def reported_status(self) -> str:
        """
        Reported status of the custom domain from backing infrastructure.
        """
        return pulumi.get(self, "reported_status")


@pulumi.output_type
class GetCloudGatewayNetworkFirewallResult(dict):
    def __init__(__self__, *,
                 allowed_cidr_blocks: Sequence[str],
                 denied_cidr_blocks: Sequence[str]):
        """
        :param Sequence[str] allowed_cidr_blocks: List of allowed CIDR blocks to access a network.
        :param Sequence[str] denied_cidr_blocks: List of denied CIDR blocks to access a network.
        """
        pulumi.set(__self__, "allowed_cidr_blocks", allowed_cidr_blocks)
        pulumi.set(__self__, "denied_cidr_blocks", denied_cidr_blocks)

    @property
    @pulumi.getter(name="allowedCidrBlocks")
    def allowed_cidr_blocks(self) -> Sequence[str]:
        """
        List of allowed CIDR blocks to access a network.
        """
        return pulumi.get(self, "allowed_cidr_blocks")

    @property
    @pulumi.getter(name="deniedCidrBlocks")
    def denied_cidr_blocks(self) -> Sequence[str]:
        """
        List of denied CIDR blocks to access a network.
        """
        return pulumi.get(self, "denied_cidr_blocks")


@pulumi.output_type
class GetCloudGatewayNetworkProviderMetadataResult(dict):
    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 vpc_id: str):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetCloudGatewayProviderAccountListDataResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 provider: str,
                 provider_account_id: str,
                 updated_at: str):
        """
        :param str created_at: An RFC-3339 timestamp representation of provider account creation date.
        :param str provider: Name of cloud provider. must be one of ["aws"]
        :param str provider_account_id: ID of the cloud provider account.
        :param str updated_at: An RFC-3339 timestamp representation of provider account update date.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "provider_account_id", provider_account_id)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        An RFC-3339 timestamp representation of provider account creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Name of cloud provider. must be one of ["aws"]
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="providerAccountId")
    def provider_account_id(self) -> str:
        """
        ID of the cloud provider account.
        """
        return pulumi.get(self, "provider_account_id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        An RFC-3339 timestamp representation of provider account update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetCloudGatewayProviderAccountListMetaResult(dict):
    def __init__(__self__, *,
                 page: 'outputs.GetCloudGatewayProviderAccountListMetaPageResult'):
        """
        :param 'GetCloudGatewayProviderAccountListMetaPageArgs' page: Contains pagination query parameters and the total number of objects returned.
        """
        pulumi.set(__self__, "page", page)

    @property
    @pulumi.getter
    def page(self) -> 'outputs.GetCloudGatewayProviderAccountListMetaPageResult':
        """
        Contains pagination query parameters and the total number of objects returned.
        """
        return pulumi.get(self, "page")


@pulumi.output_type
class GetCloudGatewayProviderAccountListMetaPageResult(dict):
    def __init__(__self__, *,
                 number: float,
                 size: float,
                 total: float):
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def number(self) -> float:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def total(self) -> float:
        return pulumi.get(self, "total")


@pulumi.output_type
class GetCloudGatewayTransitGatewayDnsConfigResult(dict):
    def __init__(__self__, *,
                 domain_proxy_lists: Sequence[str],
                 remote_dns_server_ip_addresses: Sequence[str]):
        """
        :param Sequence[str] domain_proxy_lists: Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
               for a transit gateway.
        :param Sequence[str] remote_dns_server_ip_addresses: Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway.
        """
        pulumi.set(__self__, "domain_proxy_lists", domain_proxy_lists)
        pulumi.set(__self__, "remote_dns_server_ip_addresses", remote_dns_server_ip_addresses)

    @property
    @pulumi.getter(name="domainProxyLists")
    def domain_proxy_lists(self) -> Sequence[str]:
        """
        Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
        for a transit gateway.
        """
        return pulumi.get(self, "domain_proxy_lists")

    @property
    @pulumi.getter(name="remoteDnsServerIpAddresses")
    def remote_dns_server_ip_addresses(self) -> Sequence[str]:
        """
        Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway.
        """
        return pulumi.get(self, "remote_dns_server_ip_addresses")


@pulumi.output_type
class GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigResult(dict):
    def __init__(__self__, *,
                 aws_transit_gateway_attachment_config: 'outputs.GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfigResult'):
        pulumi.set(__self__, "aws_transit_gateway_attachment_config", aws_transit_gateway_attachment_config)

    @property
    @pulumi.getter(name="awsTransitGatewayAttachmentConfig")
    def aws_transit_gateway_attachment_config(self) -> 'outputs.GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfigResult':
        return pulumi.get(self, "aws_transit_gateway_attachment_config")


@pulumi.output_type
class GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfigResult(dict):
    def __init__(__self__, *,
                 kind: str,
                 ram_share_arn: str,
                 transit_gateway_id: str):
        """
        :param str kind: must be one of ["aws-transit-gateway-attachment"]
        :param str ram_share_arn: Resource Share ARN to verify request to create transit gateway attachment.
        :param str transit_gateway_id: AWS Transit Gateway ID to create attachment to.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "ram_share_arn", ram_share_arn)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        must be one of ["aws-transit-gateway-attachment"]
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="ramShareArn")
    def ram_share_arn(self) -> str:
        """
        Resource Share ARN to verify request to create transit gateway attachment.
        """
        return pulumi.get(self, "ram_share_arn")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> str:
        """
        AWS Transit Gateway ID to create attachment to.
        """
        return pulumi.get(self, "transit_gateway_id")


@pulumi.output_type
class GetGatewayAclConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayBasicAuthConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayControlPlaneConfigResult(dict):
    def __init__(__self__, *,
                 control_plane_endpoint: str,
                 telemetry_endpoint: str):
        """
        :param str control_plane_endpoint: Control Plane Endpoint.
        :param str telemetry_endpoint: Telemetry Endpoint.
        """
        pulumi.set(__self__, "control_plane_endpoint", control_plane_endpoint)
        pulumi.set(__self__, "telemetry_endpoint", telemetry_endpoint)

    @property
    @pulumi.getter(name="controlPlaneEndpoint")
    def control_plane_endpoint(self) -> str:
        """
        Control Plane Endpoint.
        """
        return pulumi.get(self, "control_plane_endpoint")

    @property
    @pulumi.getter(name="telemetryEndpoint")
    def telemetry_endpoint(self) -> str:
        """
        Telemetry Endpoint.
        """
        return pulumi.get(self, "telemetry_endpoint")


@pulumi.output_type
class GetGatewayHmacAuthConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayJwtConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayKeyAuthConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayKeyPemResult(dict):
    def __init__(__self__, *,
                 private_key: str,
                 public_key: str):
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetGatewayKeySetResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAclConfigResult(dict):
    def __init__(__self__, *,
                 allows: Sequence[str],
                 denies: Sequence[str],
                 hide_groups_header: bool,
                 include_consumer_groups: bool):
        """
        :param Sequence[str] allows: Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        :param Sequence[str] denies: Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        :param bool hide_groups_header: If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
        """
        pulumi.set(__self__, "allows", allows)
        pulumi.set(__self__, "denies", denies)
        pulumi.set(__self__, "hide_groups_header", hide_groups_header)
        pulumi.set(__self__, "include_consumer_groups", include_consumer_groups)

    @property
    @pulumi.getter
    def allows(self) -> Sequence[str]:
        """
        Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Sequence[str]:
        """
        Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "denies")

    @property
    @pulumi.getter(name="hideGroupsHeader")
    def hide_groups_header(self) -> bool:
        """
        If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
        """
        return pulumi.get(self, "hide_groups_header")

    @property
    @pulumi.getter(name="includeConsumerGroups")
    def include_consumer_groups(self) -> bool:
        return pulumi.get(self, "include_consumer_groups")


@pulumi.output_type
class GetGatewayPluginAclConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAclConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAclRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAclServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConfigResult(dict):
    def __init__(__self__, *,
                 prompts: 'outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsResult'):
        pulumi.set(__self__, "prompts", prompts)

    @property
    @pulumi.getter
    def prompts(self) -> 'outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsResult':
        return pulumi.get(self, "prompts")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConfigPromptsResult(dict):
    def __init__(__self__, *,
                 appends: Sequence['outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsAppendResult'],
                 prepends: Sequence['outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsPrependResult']):
        """
        :param Sequence['GetGatewayPluginAiPromptDecoratorConfigPromptsAppendArgs'] appends: Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
        :param Sequence['GetGatewayPluginAiPromptDecoratorConfigPromptsPrependArgs'] prepends: Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
        """
        pulumi.set(__self__, "appends", appends)
        pulumi.set(__self__, "prepends", prepends)

    @property
    @pulumi.getter
    def appends(self) -> Sequence['outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsAppendResult']:
        """
        Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
        """
        return pulumi.get(self, "appends")

    @property
    @pulumi.getter
    def prepends(self) -> Sequence['outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsPrependResult']:
        """
        Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
        """
        return pulumi.get(self, "prepends")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConfigPromptsAppendResult(dict):
    def __init__(__self__, *,
                 content: str,
                 role: str):
        """
        :param str role: must be one of ["system", "assistant", "user"]
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        must be one of ["system", "assistant", "user"]
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConfigPromptsPrependResult(dict):
    def __init__(__self__, *,
                 content: str,
                 role: str):
        """
        :param str role: must be one of ["system", "assistant", "user"]
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        must be one of ["system", "assistant", "user"]
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptDecoratorServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptGuardConfigResult(dict):
    def __init__(__self__, *,
                 allow_all_conversation_history: bool,
                 allow_patterns: Sequence[str],
                 deny_patterns: Sequence[str]):
        """
        :param bool allow_all_conversation_history: If true, will ignore all previous chat prompts from the conversation history.
        :param Sequence[str] allow_patterns: Array of valid regex patterns, or valid questions from the 'user' role in chat.
        :param Sequence[str] deny_patterns: Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
        """
        pulumi.set(__self__, "allow_all_conversation_history", allow_all_conversation_history)
        pulumi.set(__self__, "allow_patterns", allow_patterns)
        pulumi.set(__self__, "deny_patterns", deny_patterns)

    @property
    @pulumi.getter(name="allowAllConversationHistory")
    def allow_all_conversation_history(self) -> bool:
        """
        If true, will ignore all previous chat prompts from the conversation history.
        """
        return pulumi.get(self, "allow_all_conversation_history")

    @property
    @pulumi.getter(name="allowPatterns")
    def allow_patterns(self) -> Sequence[str]:
        """
        Array of valid regex patterns, or valid questions from the 'user' role in chat.
        """
        return pulumi.get(self, "allow_patterns")

    @property
    @pulumi.getter(name="denyPatterns")
    def deny_patterns(self) -> Sequence[str]:
        """
        Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
        """
        return pulumi.get(self, "deny_patterns")


@pulumi.output_type
class GetGatewayPluginAiPromptGuardConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptGuardConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptGuardRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptGuardServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateConfigResult(dict):
    def __init__(__self__, *,
                 allow_untemplated_requests: bool,
                 log_original_request: bool,
                 templates: Sequence['outputs.GetGatewayPluginAiPromptTemplateConfigTemplateResult']):
        """
        :param bool allow_untemplated_requests: Set true to allow requests that don't call or match any template.
        :param bool log_original_request: Set true to add the original request to the Kong log plugin(s) output.
        :param Sequence['GetGatewayPluginAiPromptTemplateConfigTemplateArgs'] templates: Array of templates available to the request context.
        """
        pulumi.set(__self__, "allow_untemplated_requests", allow_untemplated_requests)
        pulumi.set(__self__, "log_original_request", log_original_request)
        pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter(name="allowUntemplatedRequests")
    def allow_untemplated_requests(self) -> bool:
        """
        Set true to allow requests that don't call or match any template.
        """
        return pulumi.get(self, "allow_untemplated_requests")

    @property
    @pulumi.getter(name="logOriginalRequest")
    def log_original_request(self) -> bool:
        """
        Set true to add the original request to the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_original_request")

    @property
    @pulumi.getter
    def templates(self) -> Sequence['outputs.GetGatewayPluginAiPromptTemplateConfigTemplateResult']:
        """
        Array of templates available to the request context.
        """
        return pulumi.get(self, "templates")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateConfigTemplateResult(dict):
    def __init__(__self__, *,
                 name: str,
                 template: str):
        """
        :param str name: Unique name for the template, can be called with `{template://NAME}`
        :param str template: Template string for this request, supports mustache-style `{{"{{"}}placeholders{{"}}"}}`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique name for the template, can be called with `{template://NAME}`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Template string for this request, supports mustache-style `{{"{{"}}placeholders{{"}}"}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiPromptTemplateServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiProxyConfigResult(dict):
    def __init__(__self__, *,
                 auth: 'outputs.GetGatewayPluginAiProxyConfigAuthResult',
                 logging: 'outputs.GetGatewayPluginAiProxyConfigLoggingResult',
                 model: 'outputs.GetGatewayPluginAiProxyConfigModelResult',
                 response_streaming: str,
                 route_type: str):
        """
        :param str response_streaming: Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
        :param str route_type: The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "response_streaming", response_streaming)
        pulumi.set(__self__, "route_type", route_type)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.GetGatewayPluginAiProxyConfigAuthResult':
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def logging(self) -> 'outputs.GetGatewayPluginAiProxyConfigLoggingResult':
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def model(self) -> 'outputs.GetGatewayPluginAiProxyConfigModelResult':
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="responseStreaming")
    def response_streaming(self) -> str:
        """
        Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
        """
        return pulumi.get(self, "response_streaming")

    @property
    @pulumi.getter(name="routeType")
    def route_type(self) -> str:
        """
        The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
        """
        return pulumi.get(self, "route_type")


@pulumi.output_type
class GetGatewayPluginAiProxyConfigAuthResult(dict):
    def __init__(__self__, *,
                 azure_client_id: str,
                 azure_client_secret: str,
                 azure_tenant_id: str,
                 azure_use_managed_identity: bool,
                 header_name: str,
                 header_value: str,
                 param_location: str,
                 param_name: str,
                 param_value: str):
        """
        :param str azure_client_id: If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
        :param str azure_client_secret: If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
        :param str azure_tenant_id: If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
        :param bool azure_use_managed_identity: Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
        :param str header_name: If AI model requires authentication via Authorization or API key header, specify its name here.
        :param str header_value: Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
        :param str param_location: Specify whether the 'param_name' and 'param_value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
        :param str param_name: If AI model requires authentication via query parameter, specify its name here.
        :param str param_value: Specify the full parameter value for 'param_name'.
        """
        pulumi.set(__self__, "azure_client_id", azure_client_id)
        pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        pulumi.set(__self__, "azure_use_managed_identity", azure_use_managed_identity)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)
        pulumi.set(__self__, "param_location", param_location)
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "param_value", param_value)

    @property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> str:
        """
        If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
        """
        return pulumi.get(self, "azure_client_id")

    @property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> str:
        """
        If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
        """
        return pulumi.get(self, "azure_client_secret")

    @property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> str:
        """
        If azure_use_managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
        """
        return pulumi.get(self, "azure_tenant_id")

    @property
    @pulumi.getter(name="azureUseManagedIdentity")
    def azure_use_managed_identity(self) -> bool:
        """
        Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
        """
        return pulumi.get(self, "azure_use_managed_identity")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        If AI model requires authentication via Authorization or API key header, specify its name here.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
        """
        return pulumi.get(self, "header_value")

    @property
    @pulumi.getter(name="paramLocation")
    def param_location(self) -> str:
        """
        Specify whether the 'param_name' and 'param_value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
        """
        return pulumi.get(self, "param_location")

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> str:
        """
        If AI model requires authentication via query parameter, specify its name here.
        """
        return pulumi.get(self, "param_name")

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> str:
        """
        Specify the full parameter value for 'param_name'.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetGatewayPluginAiProxyConfigLoggingResult(dict):
    def __init__(__self__, *,
                 log_payloads: bool,
                 log_statistics: bool):
        """
        :param bool log_payloads: If enabled, will log the request and response body into the Kong log plugin(s) output.
        :param bool log_statistics: If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
        """
        pulumi.set(__self__, "log_payloads", log_payloads)
        pulumi.set(__self__, "log_statistics", log_statistics)

    @property
    @pulumi.getter(name="logPayloads")
    def log_payloads(self) -> bool:
        """
        If enabled, will log the request and response body into the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_payloads")

    @property
    @pulumi.getter(name="logStatistics")
    def log_statistics(self) -> bool:
        """
        If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
        """
        return pulumi.get(self, "log_statistics")


@pulumi.output_type
class GetGatewayPluginAiProxyConfigModelResult(dict):
    def __init__(__self__, *,
                 name: str,
                 options: 'outputs.GetGatewayPluginAiProxyConfigModelOptionsResult',
                 provider: str):
        """
        :param str name: Model name to execute.
        :param 'GetGatewayPluginAiProxyConfigModelOptionsArgs' options: Key/value settings for the model
        :param str provider: AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Model name to execute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> 'outputs.GetGatewayPluginAiProxyConfigModelOptionsResult':
        """
        Key/value settings for the model
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class GetGatewayPluginAiProxyConfigModelOptionsResult(dict):
    def __init__(__self__, *,
                 anthropic_version: str,
                 azure_api_version: str,
                 azure_deployment_id: str,
                 azure_instance: str,
                 llama2_format: str,
                 max_tokens: int,
                 mistral_format: str,
                 temperature: float,
                 top_k: int,
                 top_p: float,
                 upstream_path: str,
                 upstream_url: str):
        """
        :param str anthropic_version: Defines the schema/API version, if using Anthropic provider.
        :param str azure_api_version: 'api-version' for Azure OpenAI instances.
        :param str azure_deployment_id: Deployment ID for Azure OpenAI instances.
        :param str azure_instance: Instance name for Azure OpenAI hosted models.
        :param str llama2_format: If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
        :param int max_tokens: Defines the max_tokens, if using chat or completion models.
        :param str mistral_format: If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
        :param float temperature: Defines the matching temperature, if using chat or completion models.
        :param int top_k: Defines the top-k most likely tokens, if supported.
        :param float top_p: Defines the top-p probability mass, if supported.
        :param str upstream_path: Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
        :param str upstream_url: Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
        """
        pulumi.set(__self__, "anthropic_version", anthropic_version)
        pulumi.set(__self__, "azure_api_version", azure_api_version)
        pulumi.set(__self__, "azure_deployment_id", azure_deployment_id)
        pulumi.set(__self__, "azure_instance", azure_instance)
        pulumi.set(__self__, "llama2_format", llama2_format)
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "mistral_format", mistral_format)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)
        pulumi.set(__self__, "upstream_path", upstream_path)
        pulumi.set(__self__, "upstream_url", upstream_url)

    @property
    @pulumi.getter(name="anthropicVersion")
    def anthropic_version(self) -> str:
        """
        Defines the schema/API version, if using Anthropic provider.
        """
        return pulumi.get(self, "anthropic_version")

    @property
    @pulumi.getter(name="azureApiVersion")
    def azure_api_version(self) -> str:
        """
        'api-version' for Azure OpenAI instances.
        """
        return pulumi.get(self, "azure_api_version")

    @property
    @pulumi.getter(name="azureDeploymentId")
    def azure_deployment_id(self) -> str:
        """
        Deployment ID for Azure OpenAI instances.
        """
        return pulumi.get(self, "azure_deployment_id")

    @property
    @pulumi.getter(name="azureInstance")
    def azure_instance(self) -> str:
        """
        Instance name for Azure OpenAI hosted models.
        """
        return pulumi.get(self, "azure_instance")

    @property
    @pulumi.getter(name="llama2Format")
    def llama2_format(self) -> str:
        """
        If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
        """
        return pulumi.get(self, "llama2_format")

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> int:
        """
        Defines the max_tokens, if using chat or completion models.
        """
        return pulumi.get(self, "max_tokens")

    @property
    @pulumi.getter(name="mistralFormat")
    def mistral_format(self) -> str:
        """
        If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
        """
        return pulumi.get(self, "mistral_format")

    @property
    @pulumi.getter
    def temperature(self) -> float:
        """
        Defines the matching temperature, if using chat or completion models.
        """
        return pulumi.get(self, "temperature")

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> int:
        """
        Defines the top-k most likely tokens, if supported.
        """
        return pulumi.get(self, "top_k")

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> float:
        """
        Defines the top-p probability mass, if supported.
        """
        return pulumi.get(self, "top_p")

    @property
    @pulumi.getter(name="upstreamPath")
    def upstream_path(self) -> str:
        """
        Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
        """
        return pulumi.get(self, "upstream_path")

    @property
    @pulumi.getter(name="upstreamUrl")
    def upstream_url(self) -> str:
        """
        Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
        """
        return pulumi.get(self, "upstream_url")


@pulumi.output_type
class GetGatewayPluginAiProxyConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiProxyConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiProxyRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAiProxyServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAwsLambdaConfigResult(dict):
    def __init__(__self__, *,
                 aws_assume_role_arn: str,
                 aws_imds_protocol_version: str,
                 aws_key: str,
                 aws_region: str,
                 aws_role_session_name: str,
                 aws_secret: str,
                 awsgateway_compatible: bool,
                 base64_encode_body: bool,
                 disable_https: bool,
                 forward_request_body: bool,
                 forward_request_headers: bool,
                 forward_request_method: bool,
                 forward_request_uri: bool,
                 function_name: str,
                 host: str,
                 invocation_type: str,
                 is_proxy_integration: bool,
                 keepalive: float,
                 log_type: str,
                 port: int,
                 proxy_url: str,
                 qualifier: str,
                 skip_large_bodies: bool,
                 timeout: float,
                 unhandled_status: int):
        """
        :param str aws_assume_role_arn: The target AWS IAM role ARN used to invoke the Lambda function.
        :param str aws_imds_protocol_version: Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
        :param str aws_key: The AWS key credential to be used when invoking the function.
        :param str aws_region: A string representing a host name, such as example.com.
        :param str aws_role_session_name: The identifier of the assumed role session.
        :param str aws_secret: The AWS secret credential to be used when invoking the function.
        :param bool awsgateway_compatible: An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
        :param bool base64_encode_body: An optional value that Base64-encodes the request body.
        :param bool forward_request_body: An optional value that defines whether the request body is sent in the request_body field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate request_body_args field of the request.
        :param bool forward_request_headers: An optional value that defines whether the original HTTP request headers are sent as a map in the request_headers field of the JSON-encoded request.
        :param bool forward_request_method: An optional value that defines whether the original HTTP request method verb is sent in the request_method field of the JSON-encoded request.
        :param bool forward_request_uri: An optional value that defines whether the original HTTP request URI is sent in the request_uri field of the JSON-encoded request.
        :param str function_name: The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
        :param str host: A string representing a host name, such as example.com.
        :param str invocation_type: The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
        :param bool is_proxy_integration: An optional value that defines whether the response format to receive from the Lambda to this format.
        :param float keepalive: An optional value in milliseconds that defines how long an idle connection lives before being closed.
        :param str log_type: The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param str proxy_url: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str qualifier: The qualifier to use when invoking the function.
        :param bool skip_large_bodies: An optional value that defines whether Kong should send large bodies that are buffered to disk
        :param float timeout: An optional timeout in milliseconds when invoking the function.
        :param int unhandled_status: The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
        """
        pulumi.set(__self__, "aws_assume_role_arn", aws_assume_role_arn)
        pulumi.set(__self__, "aws_imds_protocol_version", aws_imds_protocol_version)
        pulumi.set(__self__, "aws_key", aws_key)
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "aws_role_session_name", aws_role_session_name)
        pulumi.set(__self__, "aws_secret", aws_secret)
        pulumi.set(__self__, "awsgateway_compatible", awsgateway_compatible)
        pulumi.set(__self__, "base64_encode_body", base64_encode_body)
        pulumi.set(__self__, "disable_https", disable_https)
        pulumi.set(__self__, "forward_request_body", forward_request_body)
        pulumi.set(__self__, "forward_request_headers", forward_request_headers)
        pulumi.set(__self__, "forward_request_method", forward_request_method)
        pulumi.set(__self__, "forward_request_uri", forward_request_uri)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "invocation_type", invocation_type)
        pulumi.set(__self__, "is_proxy_integration", is_proxy_integration)
        pulumi.set(__self__, "keepalive", keepalive)
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "proxy_url", proxy_url)
        pulumi.set(__self__, "qualifier", qualifier)
        pulumi.set(__self__, "skip_large_bodies", skip_large_bodies)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhandled_status", unhandled_status)

    @property
    @pulumi.getter(name="awsAssumeRoleArn")
    def aws_assume_role_arn(self) -> str:
        """
        The target AWS IAM role ARN used to invoke the Lambda function.
        """
        return pulumi.get(self, "aws_assume_role_arn")

    @property
    @pulumi.getter(name="awsImdsProtocolVersion")
    def aws_imds_protocol_version(self) -> str:
        """
        Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
        """
        return pulumi.get(self, "aws_imds_protocol_version")

    @property
    @pulumi.getter(name="awsKey")
    def aws_key(self) -> str:
        """
        The AWS key credential to be used when invoking the function.
        """
        return pulumi.get(self, "aws_key")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsRoleSessionName")
    def aws_role_session_name(self) -> str:
        """
        The identifier of the assumed role session.
        """
        return pulumi.get(self, "aws_role_session_name")

    @property
    @pulumi.getter(name="awsSecret")
    def aws_secret(self) -> str:
        """
        The AWS secret credential to be used when invoking the function.
        """
        return pulumi.get(self, "aws_secret")

    @property
    @pulumi.getter(name="awsgatewayCompatible")
    def awsgateway_compatible(self) -> bool:
        """
        An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
        """
        return pulumi.get(self, "awsgateway_compatible")

    @property
    @pulumi.getter(name="base64EncodeBody")
    def base64_encode_body(self) -> bool:
        """
        An optional value that Base64-encodes the request body.
        """
        return pulumi.get(self, "base64_encode_body")

    @property
    @pulumi.getter(name="disableHttps")
    def disable_https(self) -> bool:
        return pulumi.get(self, "disable_https")

    @property
    @pulumi.getter(name="forwardRequestBody")
    def forward_request_body(self) -> bool:
        """
        An optional value that defines whether the request body is sent in the request_body field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate request_body_args field of the request.
        """
        return pulumi.get(self, "forward_request_body")

    @property
    @pulumi.getter(name="forwardRequestHeaders")
    def forward_request_headers(self) -> bool:
        """
        An optional value that defines whether the original HTTP request headers are sent as a map in the request_headers field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_headers")

    @property
    @pulumi.getter(name="forwardRequestMethod")
    def forward_request_method(self) -> bool:
        """
        An optional value that defines whether the original HTTP request method verb is sent in the request_method field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_method")

    @property
    @pulumi.getter(name="forwardRequestUri")
    def forward_request_uri(self) -> bool:
        """
        An optional value that defines whether the original HTTP request URI is sent in the request_uri field of the JSON-encoded request.
        """
        return pulumi.get(self, "forward_request_uri")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> str:
        """
        The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
        """
        return pulumi.get(self, "invocation_type")

    @property
    @pulumi.getter(name="isProxyIntegration")
    def is_proxy_integration(self) -> bool:
        """
        An optional value that defines whether the response format to receive from the Lambda to this format.
        """
        return pulumi.get(self, "is_proxy_integration")

    @property
    @pulumi.getter
    def keepalive(self) -> float:
        """
        An optional value in milliseconds that defines how long an idle connection lives before being closed.
        """
        return pulumi.get(self, "keepalive")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> str:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter
    def qualifier(self) -> str:
        """
        The qualifier to use when invoking the function.
        """
        return pulumi.get(self, "qualifier")

    @property
    @pulumi.getter(name="skipLargeBodies")
    def skip_large_bodies(self) -> bool:
        """
        An optional value that defines whether Kong should send large bodies that are buffered to disk
        """
        return pulumi.get(self, "skip_large_bodies")

    @property
    @pulumi.getter
    def timeout(self) -> float:
        """
        An optional timeout in milliseconds when invoking the function.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhandledStatus")
    def unhandled_status(self) -> int:
        """
        The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
        """
        return pulumi.get(self, "unhandled_status")


@pulumi.output_type
class GetGatewayPluginAwsLambdaConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAwsLambdaConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAwsLambdaRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginAwsLambdaServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginBasicAuthConfigResult(dict):
    def __init__(__self__, *,
                 anonymous: str,
                 hide_credentials: bool,
                 realm: str):
        """
        :param str anonymous: An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `custom_id`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
        :param str realm: When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "hide_credentials", hide_credentials)
        pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `custom_id`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> bool:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class GetGatewayPluginBasicAuthConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginBasicAuthConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginBasicAuthRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginBasicAuthServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorrelationIdConfigResult(dict):
    def __init__(__self__, *,
                 echo_downstream: bool,
                 generator: str,
                 header_name: str):
        """
        :param bool echo_downstream: Whether to echo the header back to downstream (the client).
        :param str generator: The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
        :param str header_name: The HTTP header name to use for the correlation ID.
        """
        pulumi.set(__self__, "echo_downstream", echo_downstream)
        pulumi.set(__self__, "generator", generator)
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="echoDownstream")
    def echo_downstream(self) -> bool:
        """
        Whether to echo the header back to downstream (the client).
        """
        return pulumi.get(self, "echo_downstream")

    @property
    @pulumi.getter
    def generator(self) -> str:
        """
        The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
        """
        return pulumi.get(self, "generator")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The HTTP header name to use for the correlation ID.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetGatewayPluginCorrelationIdConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorrelationIdConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorrelationIdRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorrelationIdServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorsConfigResult(dict):
    def __init__(__self__, *,
                 credentials: bool,
                 exposed_headers: Sequence[str],
                 headers: Sequence[str],
                 max_age: float,
                 methods: Sequence[str],
                 origins: Sequence[str],
                 preflight_continue: bool,
                 private_network: bool):
        """
        :param bool credentials: Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
        :param Sequence[str] exposed_headers: Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
        :param Sequence[str] headers: Value for the `Access-Control-Allow-Headers` header.
        :param float max_age: Indicates how long the results of the preflight request can be cached, in `seconds`.
        :param Sequence[str] methods: 'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
        :param Sequence[str] origins: List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
        :param bool preflight_continue: A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
        :param bool private_network: Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "exposed_headers", exposed_headers)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "origins", origins)
        pulumi.set(__self__, "preflight_continue", preflight_continue)
        pulumi.set(__self__, "private_network", private_network)

    @property
    @pulumi.getter
    def credentials(self) -> bool:
        """
        Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Sequence[str]:
        """
        Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
        """
        return pulumi.get(self, "exposed_headers")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        """
        Value for the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> float:
        """
        Indicates how long the results of the preflight request can be cached, in `seconds`.
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def origins(self) -> Sequence[str]:
        """
        List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter(name="preflightContinue")
    def preflight_continue(self) -> bool:
        """
        A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
        """
        return pulumi.get(self, "preflight_continue")

    @property
    @pulumi.getter(name="privateNetwork")
    def private_network(self) -> bool:
        """
        Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
        """
        return pulumi.get(self, "private_network")


@pulumi.output_type
class GetGatewayPluginCorsConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorsConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorsRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginCorsServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginExitTransformerConfigResult(dict):
    def __init__(__self__, *,
                 functions: Sequence[str],
                 handle_unexpected: bool,
                 handle_unknown: bool):
        """
        :param bool handle_unexpected: Determines whether to handle unexpected errors by transforming their responses.
        :param bool handle_unknown: Determines whether to handle unknown status codes by transforming their responses.
        """
        pulumi.set(__self__, "functions", functions)
        pulumi.set(__self__, "handle_unexpected", handle_unexpected)
        pulumi.set(__self__, "handle_unknown", handle_unknown)

    @property
    @pulumi.getter
    def functions(self) -> Sequence[str]:
        return pulumi.get(self, "functions")

    @property
    @pulumi.getter(name="handleUnexpected")
    def handle_unexpected(self) -> bool:
        """
        Determines whether to handle unexpected errors by transforming their responses.
        """
        return pulumi.get(self, "handle_unexpected")

    @property
    @pulumi.getter(name="handleUnknown")
    def handle_unknown(self) -> bool:
        """
        Determines whether to handle unknown status codes by transforming their responses.
        """
        return pulumi.get(self, "handle_unknown")


@pulumi.output_type
class GetGatewayPluginExitTransformerConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginExitTransformerConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginExitTransformerRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginExitTransformerServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginFileLogConfigResult(dict):
    def __init__(__self__, *,
                 custom_fields_by_lua: Mapping[str, str],
                 path: str,
                 reopen: bool):
        """
        :param Mapping[str, str] custom_fields_by_lua: Lua code as a key-value map
        :param str path: The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
        :param bool reopen: Determines whether the log file is closed and reopened on every request.
        """
        pulumi.set(__self__, "custom_fields_by_lua", custom_fields_by_lua)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "reopen", reopen)

    @property
    @pulumi.getter(name="customFieldsByLua")
    def custom_fields_by_lua(self) -> Mapping[str, str]:
        """
        Lua code as a key-value map
        """
        return pulumi.get(self, "custom_fields_by_lua")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def reopen(self) -> bool:
        """
        Determines whether the log file is closed and reopened on every request.
        """
        return pulumi.get(self, "reopen")


@pulumi.output_type
class GetGatewayPluginFileLogConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginFileLogConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginFileLogRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginFileLogServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginIpRestrictionConfigResult(dict):
    def __init__(__self__, *,
                 allows: Sequence[str],
                 denies: Sequence[str],
                 message: str,
                 status: float):
        """
        :param Sequence[str] allows: List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
        :param Sequence[str] denies: List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
        :param str message: The message to send as a response body to rejected requests.
        :param float status: The HTTP status of the requests that will be rejected by the plugin.
        """
        pulumi.set(__self__, "allows", allows)
        pulumi.set(__self__, "denies", denies)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def allows(self) -> Sequence[str]:
        """
        List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Sequence[str]:
        """
        List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
        """
        return pulumi.get(self, "denies")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message to send as a response body to rejected requests.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def status(self) -> float:
        """
        The HTTP status of the requests that will be rejected by the plugin.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayPluginIpRestrictionConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginIpRestrictionConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginIpRestrictionRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginIpRestrictionServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJqConfigResult(dict):
    def __init__(__self__, *,
                 request_if_media_types: Sequence[str],
                 request_jq_program: str,
                 request_jq_program_options: 'outputs.GetGatewayPluginJqConfigRequestJqProgramOptionsResult',
                 response_if_media_types: Sequence[str],
                 response_if_status_codes: Sequence[int],
                 response_jq_program: str,
                 response_jq_program_options: 'outputs.GetGatewayPluginJqConfigResponseJqProgramOptionsResult'):
        pulumi.set(__self__, "request_if_media_types", request_if_media_types)
        pulumi.set(__self__, "request_jq_program", request_jq_program)
        pulumi.set(__self__, "request_jq_program_options", request_jq_program_options)
        pulumi.set(__self__, "response_if_media_types", response_if_media_types)
        pulumi.set(__self__, "response_if_status_codes", response_if_status_codes)
        pulumi.set(__self__, "response_jq_program", response_jq_program)
        pulumi.set(__self__, "response_jq_program_options", response_jq_program_options)

    @property
    @pulumi.getter(name="requestIfMediaTypes")
    def request_if_media_types(self) -> Sequence[str]:
        return pulumi.get(self, "request_if_media_types")

    @property
    @pulumi.getter(name="requestJqProgram")
    def request_jq_program(self) -> str:
        return pulumi.get(self, "request_jq_program")

    @property
    @pulumi.getter(name="requestJqProgramOptions")
    def request_jq_program_options(self) -> 'outputs.GetGatewayPluginJqConfigRequestJqProgramOptionsResult':
        return pulumi.get(self, "request_jq_program_options")

    @property
    @pulumi.getter(name="responseIfMediaTypes")
    def response_if_media_types(self) -> Sequence[str]:
        return pulumi.get(self, "response_if_media_types")

    @property
    @pulumi.getter(name="responseIfStatusCodes")
    def response_if_status_codes(self) -> Sequence[int]:
        return pulumi.get(self, "response_if_status_codes")

    @property
    @pulumi.getter(name="responseJqProgram")
    def response_jq_program(self) -> str:
        return pulumi.get(self, "response_jq_program")

    @property
    @pulumi.getter(name="responseJqProgramOptions")
    def response_jq_program_options(self) -> 'outputs.GetGatewayPluginJqConfigResponseJqProgramOptionsResult':
        return pulumi.get(self, "response_jq_program_options")


@pulumi.output_type
class GetGatewayPluginJqConfigRequestJqProgramOptionsResult(dict):
    def __init__(__self__, *,
                 ascii_output: bool,
                 compact_output: bool,
                 join_output: bool,
                 raw_output: bool,
                 sort_keys: bool):
        pulumi.set(__self__, "ascii_output", ascii_output)
        pulumi.set(__self__, "compact_output", compact_output)
        pulumi.set(__self__, "join_output", join_output)
        pulumi.set(__self__, "raw_output", raw_output)
        pulumi.set(__self__, "sort_keys", sort_keys)

    @property
    @pulumi.getter(name="asciiOutput")
    def ascii_output(self) -> bool:
        return pulumi.get(self, "ascii_output")

    @property
    @pulumi.getter(name="compactOutput")
    def compact_output(self) -> bool:
        return pulumi.get(self, "compact_output")

    @property
    @pulumi.getter(name="joinOutput")
    def join_output(self) -> bool:
        return pulumi.get(self, "join_output")

    @property
    @pulumi.getter(name="rawOutput")
    def raw_output(self) -> bool:
        return pulumi.get(self, "raw_output")

    @property
    @pulumi.getter(name="sortKeys")
    def sort_keys(self) -> bool:
        return pulumi.get(self, "sort_keys")


@pulumi.output_type
class GetGatewayPluginJqConfigResponseJqProgramOptionsResult(dict):
    def __init__(__self__, *,
                 ascii_output: bool,
                 compact_output: bool,
                 join_output: bool,
                 raw_output: bool,
                 sort_keys: bool):
        pulumi.set(__self__, "ascii_output", ascii_output)
        pulumi.set(__self__, "compact_output", compact_output)
        pulumi.set(__self__, "join_output", join_output)
        pulumi.set(__self__, "raw_output", raw_output)
        pulumi.set(__self__, "sort_keys", sort_keys)

    @property
    @pulumi.getter(name="asciiOutput")
    def ascii_output(self) -> bool:
        return pulumi.get(self, "ascii_output")

    @property
    @pulumi.getter(name="compactOutput")
    def compact_output(self) -> bool:
        return pulumi.get(self, "compact_output")

    @property
    @pulumi.getter(name="joinOutput")
    def join_output(self) -> bool:
        return pulumi.get(self, "join_output")

    @property
    @pulumi.getter(name="rawOutput")
    def raw_output(self) -> bool:
        return pulumi.get(self, "raw_output")

    @property
    @pulumi.getter(name="sortKeys")
    def sort_keys(self) -> bool:
        return pulumi.get(self, "sort_keys")


@pulumi.output_type
class GetGatewayPluginJqConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJqConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJqRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJqServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtConfigResult(dict):
    def __init__(__self__, *,
                 anonymous: str,
                 claims_to_verifies: Sequence[str],
                 cookie_names: Sequence[str],
                 header_names: Sequence[str],
                 key_claim_name: str,
                 maximum_expiration: float,
                 run_on_preflight: bool,
                 secret_is_base64: bool,
                 uri_param_names: Sequence[str]):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        :param Sequence[str] claims_to_verifies: A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
        :param Sequence[str] cookie_names: A list of cookie names that Kong will inspect to retrieve JWTs.
        :param Sequence[str] header_names: A list of HTTP header names that Kong will inspect to retrieve JWTs.
        :param str key_claim_name: The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
        :param float maximum_expiration: A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximum_expiration seconds in the future.
        :param bool run_on_preflight: A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
        :param bool secret_is_base64: If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
        :param Sequence[str] uri_param_names: A list of querystring parameters that Kong will inspect to retrieve JWTs.
        """
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "claims_to_verifies", claims_to_verifies)
        pulumi.set(__self__, "cookie_names", cookie_names)
        pulumi.set(__self__, "header_names", header_names)
        pulumi.set(__self__, "key_claim_name", key_claim_name)
        pulumi.set(__self__, "maximum_expiration", maximum_expiration)
        pulumi.set(__self__, "run_on_preflight", run_on_preflight)
        pulumi.set(__self__, "secret_is_base64", secret_is_base64)
        pulumi.set(__self__, "uri_param_names", uri_param_names)

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="claimsToVerifies")
    def claims_to_verifies(self) -> Sequence[str]:
        """
        A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
        """
        return pulumi.get(self, "claims_to_verifies")

    @property
    @pulumi.getter(name="cookieNames")
    def cookie_names(self) -> Sequence[str]:
        """
        A list of cookie names that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "cookie_names")

    @property
    @pulumi.getter(name="headerNames")
    def header_names(self) -> Sequence[str]:
        """
        A list of HTTP header names that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "header_names")

    @property
    @pulumi.getter(name="keyClaimName")
    def key_claim_name(self) -> str:
        """
        The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
        """
        return pulumi.get(self, "key_claim_name")

    @property
    @pulumi.getter(name="maximumExpiration")
    def maximum_expiration(self) -> float:
        """
        A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximum_expiration seconds in the future.
        """
        return pulumi.get(self, "maximum_expiration")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> bool:
        """
        A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
        """
        return pulumi.get(self, "run_on_preflight")

    @property
    @pulumi.getter(name="secretIsBase64")
    def secret_is_base64(self) -> bool:
        """
        If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
        """
        return pulumi.get(self, "secret_is_base64")

    @property
    @pulumi.getter(name="uriParamNames")
    def uri_param_names(self) -> Sequence[str]:
        """
        A list of querystring parameters that Kong will inspect to retrieve JWTs.
        """
        return pulumi.get(self, "uri_param_names")


@pulumi.output_type
class GetGatewayPluginJwtConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtSignerConfigResult(dict):
    def __init__(__self__, *,
                 access_token_consumer_bies: Sequence[str],
                 access_token_consumer_claims: Sequence[str],
                 access_token_introspection_authorization: str,
                 access_token_introspection_body_args: str,
                 access_token_introspection_consumer_bies: Sequence[str],
                 access_token_introspection_consumer_claims: Sequence[str],
                 access_token_introspection_endpoint: str,
                 access_token_introspection_hint: str,
                 access_token_introspection_jwt_claims: Sequence[str],
                 access_token_introspection_leeway: float,
                 access_token_introspection_scopes_claims: Sequence[str],
                 access_token_introspection_scopes_requireds: Sequence[str],
                 access_token_introspection_timeout: float,
                 access_token_issuer: str,
                 access_token_jwks_uri: str,
                 access_token_jwks_uri_client_certificate: str,
                 access_token_jwks_uri_client_password: str,
                 access_token_jwks_uri_client_username: str,
                 access_token_jwks_uri_rotate_period: float,
                 access_token_keyset: str,
                 access_token_keyset_client_certificate: str,
                 access_token_keyset_client_password: str,
                 access_token_keyset_client_username: str,
                 access_token_keyset_rotate_period: float,
                 access_token_leeway: float,
                 access_token_optional: bool,
                 access_token_request_header: str,
                 access_token_scopes_claims: Sequence[str],
                 access_token_scopes_requireds: Sequence[str],
                 access_token_signing_algorithm: str,
                 access_token_upstream_header: str,
                 access_token_upstream_leeway: float,
                 add_access_token_claims: Mapping[str, str],
                 add_channel_token_claims: Mapping[str, str],
                 add_claims: Mapping[str, str],
                 cache_access_token_introspection: bool,
                 cache_channel_token_introspection: bool,
                 channel_token_consumer_bies: Sequence[str],
                 channel_token_consumer_claims: Sequence[str],
                 channel_token_introspection_authorization: str,
                 channel_token_introspection_body_args: str,
                 channel_token_introspection_consumer_bies: Sequence[str],
                 channel_token_introspection_consumer_claims: Sequence[str],
                 channel_token_introspection_endpoint: str,
                 channel_token_introspection_hint: str,
                 channel_token_introspection_jwt_claims: Sequence[str],
                 channel_token_introspection_leeway: float,
                 channel_token_introspection_scopes_claims: Sequence[str],
                 channel_token_introspection_scopes_requireds: Sequence[str],
                 channel_token_introspection_timeout: float,
                 channel_token_issuer: str,
                 channel_token_jwks_uri: str,
                 channel_token_jwks_uri_client_certificate: str,
                 channel_token_jwks_uri_client_password: str,
                 channel_token_jwks_uri_client_username: str,
                 channel_token_jwks_uri_rotate_period: float,
                 channel_token_keyset: str,
                 channel_token_keyset_client_certificate: str,
                 channel_token_keyset_client_password: str,
                 channel_token_keyset_client_username: str,
                 channel_token_keyset_rotate_period: float,
                 channel_token_leeway: float,
                 channel_token_optional: bool,
                 channel_token_request_header: str,
                 channel_token_scopes_claims: Sequence[str],
                 channel_token_scopes_requireds: Sequence[str],
                 channel_token_signing_algorithm: str,
                 channel_token_upstream_header: str,
                 channel_token_upstream_leeway: float,
                 enable_access_token_introspection: bool,
                 enable_channel_token_introspection: bool,
                 enable_hs_signatures: bool,
                 enable_instrumentation: bool,
                 original_access_token_upstream_header: str,
                 original_channel_token_upstream_header: str,
                 realm: str,
                 remove_access_token_claims: Sequence[str],
                 remove_channel_token_claims: Sequence[str],
                 set_access_token_claims: Mapping[str, str],
                 set_channel_token_claims: Mapping[str, str],
                 set_claims: Mapping[str, str],
                 trust_access_token_introspection: bool,
                 trust_channel_token_introspection: bool,
                 verify_access_token_expiry: bool,
                 verify_access_token_introspection_expiry: bool,
                 verify_access_token_introspection_scopes: bool,
                 verify_access_token_scopes: bool,
                 verify_access_token_signature: bool,
                 verify_channel_token_expiry: bool,
                 verify_channel_token_introspection_expiry: bool,
                 verify_channel_token_introspection_scopes: bool,
                 verify_channel_token_scopes: bool,
                 verify_channel_token_signature: bool):
        """
        :param Sequence[str] access_token_consumer_bies: When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `custom_id`.
        :param Sequence[str] access_token_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
        :param str access_token_introspection_authorization: If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
        :param str access_token_introspection_body_args: This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
        :param Sequence[str] access_token_introspection_consumer_bies: When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
        :param Sequence[str] access_token_introspection_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
        :param str access_token_introspection_endpoint: When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
        :param str access_token_introspection_hint: If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
        :param Sequence[str] access_token_introspection_jwt_claims: If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
        :param float access_token_introspection_leeway: Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
        :param Sequence[str] access_token_introspection_scopes_claims: Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realm_access", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
        :param Sequence[str] access_token_introspection_scopes_requireds: Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
        :param float access_token_introspection_timeout: Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
        :param str access_token_issuer: The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `original_iss` claim of the newly signed access token.
        :param str access_token_jwks_uri: Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
        :param str access_token_jwks_uri_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        :param str access_token_jwks_uri_client_password: The client password that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_username`
        :param str access_token_jwks_uri_client_username: The client username that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_password`
        :param float access_token_jwks_uri_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `access_token_jwks_uri`. The default value 0 means no auto-rotation.
        :param str access_token_keyset: The name of the keyset containing signing keys.
        :param str access_token_keyset_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_keyset` is an https uri that requires mTLS Auth.
        :param str access_token_keyset_client_password: The client password that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_username`
        :param str access_token_keyset_client_username: The client username that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_password`
        :param float access_token_keyset_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `access_token_keyset`. The default value 0 means no auto-rotation.
        :param float access_token_leeway: Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
        :param bool access_token_optional: If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
        :param str access_token_request_header: This parameter tells the name of the header where to look for the access token.
        :param Sequence[str] access_token_scopes_claims: Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
        :param Sequence[str] access_token_scopes_requireds: Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
        :param str access_token_signing_algorithm: When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        :param str access_token_upstream_header: Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
        :param float access_token_upstream_leeway: If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
        :param Mapping[str, str] add_access_token_claims: Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] add_channel_token_claims: Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] add_claims: Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param bool cache_access_token_introspection: Whether to cache access token introspection results.
        :param bool cache_channel_token_introspection: Whether to cache channel token introspection results.
        :param Sequence[str] channel_token_consumer_bies: When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `custom_id`.
        :param Sequence[str] channel_token_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `custom_id`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
        :param str channel_token_introspection_authorization: When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
        :param str channel_token_introspection_body_args: If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
        :param Sequence[str] channel_token_introspection_consumer_bies: When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `custom_id`.
        :param Sequence[str] channel_token_introspection_consumer_claims: When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
        :param str channel_token_introspection_endpoint: When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
        :param str channel_token_introspection_hint: If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
        :param Sequence[str] channel_token_introspection_jwt_claims: If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
        :param float channel_token_introspection_leeway: You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
        :param Sequence[str] channel_token_introspection_scopes_claims: Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
        :param Sequence[str] channel_token_introspection_scopes_requireds: Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
        :param float channel_token_introspection_timeout: Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
        :param str channel_token_issuer: The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `original_iss` claim of the newly signed channel token.
        :param str channel_token_jwks_uri: If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
        :param str channel_token_jwks_uri_client_certificate: The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        :param str channel_token_jwks_uri_client_password: The client password that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_username`
        :param str channel_token_jwks_uri_client_username: The client username that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_password`
        :param float channel_token_jwks_uri_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `channel_token_jwks_uri`. The default value 0 means no auto-rotation.
        :param str channel_token_keyset: The name of the keyset containing signing keys.
        :param str channel_token_keyset_client_certificate: The client certificate that will be used to authenticate Kong if `channel_token_keyset` is an https uri that requires mTLS Auth.
        :param str channel_token_keyset_client_password: The client password that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_username`
        :param str channel_token_keyset_client_username: The client username that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_password`
        :param float channel_token_keyset_rotate_period: Specify the period (in seconds) to auto-rotate the jwks for `channel_token_keyset`. The default value 0 means no auto-rotation.
        :param float channel_token_leeway: Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
        :param bool channel_token_optional: If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
        :param str channel_token_request_header: This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
        :param Sequence[str] channel_token_scopes_claims: Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
        :param Sequence[str] channel_token_scopes_requireds: Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
        :param str channel_token_signing_algorithm: When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        :param str channel_token_upstream_header: This plugin removes the `config.channel_token_request_header` from the request after reading its value.
        :param float channel_token_upstream_leeway: If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
        :param bool enable_access_token_introspection: If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
        :param bool enable_channel_token_introspection: If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
        :param bool enable_hs_signatures: Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
        :param bool enable_instrumentation: Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
        :param str original_access_token_upstream_header: The HTTP header name used to store the original access token.
        :param str original_channel_token_upstream_header: The HTTP header name used to store the original channel token.
        :param str realm: When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
        :param Sequence[str] remove_access_token_claims: remove claims. It should be an array, and each element is a claim key string.
        :param Sequence[str] remove_channel_token_claims: remove claims. It should be an array, and each element is a claim key string.
        :param Mapping[str, str] set_access_token_claims: Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] set_channel_token_claims: Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param Mapping[str, str] set_claims: Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        :param bool trust_access_token_introspection: Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
        :param bool trust_channel_token_introspection: Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel_token_introspection_jwt_claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
        :param bool verify_access_token_expiry: Quickly turn access token expiry verification off and on as needed.
        :param bool verify_access_token_introspection_expiry: Quickly turn access token introspection expiry verification off and on as needed.
        :param bool verify_access_token_introspection_scopes: Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
        :param bool verify_access_token_scopes: Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
        :param bool verify_access_token_signature: Quickly turn access token signature verification off and on as needed.
        :param bool verify_channel_token_introspection_expiry: Quickly turn on/off the channel token introspection expiry verification.
        :param bool verify_channel_token_introspection_scopes: Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
        :param bool verify_channel_token_scopes: Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
        :param bool verify_channel_token_signature: Quickly turn on/off the channel token signature verification.
        """
        pulumi.set(__self__, "access_token_consumer_bies", access_token_consumer_bies)
        pulumi.set(__self__, "access_token_consumer_claims", access_token_consumer_claims)
        pulumi.set(__self__, "access_token_introspection_authorization", access_token_introspection_authorization)
        pulumi.set(__self__, "access_token_introspection_body_args", access_token_introspection_body_args)
        pulumi.set(__self__, "access_token_introspection_consumer_bies", access_token_introspection_consumer_bies)
        pulumi.set(__self__, "access_token_introspection_consumer_claims", access_token_introspection_consumer_claims)
        pulumi.set(__self__, "access_token_introspection_endpoint", access_token_introspection_endpoint)
        pulumi.set(__self__, "access_token_introspection_hint", access_token_introspection_hint)
        pulumi.set(__self__, "access_token_introspection_jwt_claims", access_token_introspection_jwt_claims)
        pulumi.set(__self__, "access_token_introspection_leeway", access_token_introspection_leeway)
        pulumi.set(__self__, "access_token_introspection_scopes_claims", access_token_introspection_scopes_claims)
        pulumi.set(__self__, "access_token_introspection_scopes_requireds", access_token_introspection_scopes_requireds)
        pulumi.set(__self__, "access_token_introspection_timeout", access_token_introspection_timeout)
        pulumi.set(__self__, "access_token_issuer", access_token_issuer)
        pulumi.set(__self__, "access_token_jwks_uri", access_token_jwks_uri)
        pulumi.set(__self__, "access_token_jwks_uri_client_certificate", access_token_jwks_uri_client_certificate)
        pulumi.set(__self__, "access_token_jwks_uri_client_password", access_token_jwks_uri_client_password)
        pulumi.set(__self__, "access_token_jwks_uri_client_username", access_token_jwks_uri_client_username)
        pulumi.set(__self__, "access_token_jwks_uri_rotate_period", access_token_jwks_uri_rotate_period)
        pulumi.set(__self__, "access_token_keyset", access_token_keyset)
        pulumi.set(__self__, "access_token_keyset_client_certificate", access_token_keyset_client_certificate)
        pulumi.set(__self__, "access_token_keyset_client_password", access_token_keyset_client_password)
        pulumi.set(__self__, "access_token_keyset_client_username", access_token_keyset_client_username)
        pulumi.set(__self__, "access_token_keyset_rotate_period", access_token_keyset_rotate_period)
        pulumi.set(__self__, "access_token_leeway", access_token_leeway)
        pulumi.set(__self__, "access_token_optional", access_token_optional)
        pulumi.set(__self__, "access_token_request_header", access_token_request_header)
        pulumi.set(__self__, "access_token_scopes_claims", access_token_scopes_claims)
        pulumi.set(__self__, "access_token_scopes_requireds", access_token_scopes_requireds)
        pulumi.set(__self__, "access_token_signing_algorithm", access_token_signing_algorithm)
        pulumi.set(__self__, "access_token_upstream_header", access_token_upstream_header)
        pulumi.set(__self__, "access_token_upstream_leeway", access_token_upstream_leeway)
        pulumi.set(__self__, "add_access_token_claims", add_access_token_claims)
        pulumi.set(__self__, "add_channel_token_claims", add_channel_token_claims)
        pulumi.set(__self__, "add_claims", add_claims)
        pulumi.set(__self__, "cache_access_token_introspection", cache_access_token_introspection)
        pulumi.set(__self__, "cache_channel_token_introspection", cache_channel_token_introspection)
        pulumi.set(__self__, "channel_token_consumer_bies", channel_token_consumer_bies)
        pulumi.set(__self__, "channel_token_consumer_claims", channel_token_consumer_claims)
        pulumi.set(__self__, "channel_token_introspection_authorization", channel_token_introspection_authorization)
        pulumi.set(__self__, "channel_token_introspection_body_args", channel_token_introspection_body_args)
        pulumi.set(__self__, "channel_token_introspection_consumer_bies", channel_token_introspection_consumer_bies)
        pulumi.set(__self__, "channel_token_introspection_consumer_claims", channel_token_introspection_consumer_claims)
        pulumi.set(__self__, "channel_token_introspection_endpoint", channel_token_introspection_endpoint)
        pulumi.set(__self__, "channel_token_introspection_hint", channel_token_introspection_hint)
        pulumi.set(__self__, "channel_token_introspection_jwt_claims", channel_token_introspection_jwt_claims)
        pulumi.set(__self__, "channel_token_introspection_leeway", channel_token_introspection_leeway)
        pulumi.set(__self__, "channel_token_introspection_scopes_claims", channel_token_introspection_scopes_claims)
        pulumi.set(__self__, "channel_token_introspection_scopes_requireds", channel_token_introspection_scopes_requireds)
        pulumi.set(__self__, "channel_token_introspection_timeout", channel_token_introspection_timeout)
        pulumi.set(__self__, "channel_token_issuer", channel_token_issuer)
        pulumi.set(__self__, "channel_token_jwks_uri", channel_token_jwks_uri)
        pulumi.set(__self__, "channel_token_jwks_uri_client_certificate", channel_token_jwks_uri_client_certificate)
        pulumi.set(__self__, "channel_token_jwks_uri_client_password", channel_token_jwks_uri_client_password)
        pulumi.set(__self__, "channel_token_jwks_uri_client_username", channel_token_jwks_uri_client_username)
        pulumi.set(__self__, "channel_token_jwks_uri_rotate_period", channel_token_jwks_uri_rotate_period)
        pulumi.set(__self__, "channel_token_keyset", channel_token_keyset)
        pulumi.set(__self__, "channel_token_keyset_client_certificate", channel_token_keyset_client_certificate)
        pulumi.set(__self__, "channel_token_keyset_client_password", channel_token_keyset_client_password)
        pulumi.set(__self__, "channel_token_keyset_client_username", channel_token_keyset_client_username)
        pulumi.set(__self__, "channel_token_keyset_rotate_period", channel_token_keyset_rotate_period)
        pulumi.set(__self__, "channel_token_leeway", channel_token_leeway)
        pulumi.set(__self__, "channel_token_optional", channel_token_optional)
        pulumi.set(__self__, "channel_token_request_header", channel_token_request_header)
        pulumi.set(__self__, "channel_token_scopes_claims", channel_token_scopes_claims)
        pulumi.set(__self__, "channel_token_scopes_requireds", channel_token_scopes_requireds)
        pulumi.set(__self__, "channel_token_signing_algorithm", channel_token_signing_algorithm)
        pulumi.set(__self__, "channel_token_upstream_header", channel_token_upstream_header)
        pulumi.set(__self__, "channel_token_upstream_leeway", channel_token_upstream_leeway)
        pulumi.set(__self__, "enable_access_token_introspection", enable_access_token_introspection)
        pulumi.set(__self__, "enable_channel_token_introspection", enable_channel_token_introspection)
        pulumi.set(__self__, "enable_hs_signatures", enable_hs_signatures)
        pulumi.set(__self__, "enable_instrumentation", enable_instrumentation)
        pulumi.set(__self__, "original_access_token_upstream_header", original_access_token_upstream_header)
        pulumi.set(__self__, "original_channel_token_upstream_header", original_channel_token_upstream_header)
        pulumi.set(__self__, "realm", realm)
        pulumi.set(__self__, "remove_access_token_claims", remove_access_token_claims)
        pulumi.set(__self__, "remove_channel_token_claims", remove_channel_token_claims)
        pulumi.set(__self__, "set_access_token_claims", set_access_token_claims)
        pulumi.set(__self__, "set_channel_token_claims", set_channel_token_claims)
        pulumi.set(__self__, "set_claims", set_claims)
        pulumi.set(__self__, "trust_access_token_introspection", trust_access_token_introspection)
        pulumi.set(__self__, "trust_channel_token_introspection", trust_channel_token_introspection)
        pulumi.set(__self__, "verify_access_token_expiry", verify_access_token_expiry)
        pulumi.set(__self__, "verify_access_token_introspection_expiry", verify_access_token_introspection_expiry)
        pulumi.set(__self__, "verify_access_token_introspection_scopes", verify_access_token_introspection_scopes)
        pulumi.set(__self__, "verify_access_token_scopes", verify_access_token_scopes)
        pulumi.set(__self__, "verify_access_token_signature", verify_access_token_signature)
        pulumi.set(__self__, "verify_channel_token_expiry", verify_channel_token_expiry)
        pulumi.set(__self__, "verify_channel_token_introspection_expiry", verify_channel_token_introspection_expiry)
        pulumi.set(__self__, "verify_channel_token_introspection_scopes", verify_channel_token_introspection_scopes)
        pulumi.set(__self__, "verify_channel_token_scopes", verify_channel_token_scopes)
        pulumi.set(__self__, "verify_channel_token_signature", verify_channel_token_signature)

    @property
    @pulumi.getter(name="accessTokenConsumerBies")
    def access_token_consumer_bies(self) -> Sequence[str]:
        """
        When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `custom_id`.
        """
        return pulumi.get(self, "access_token_consumer_bies")

    @property
    @pulumi.getter(name="accessTokenConsumerClaims")
    def access_token_consumer_claims(self) -> Sequence[str]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
        """
        return pulumi.get(self, "access_token_consumer_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionAuthorization")
    def access_token_introspection_authorization(self) -> str:
        """
        If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
        """
        return pulumi.get(self, "access_token_introspection_authorization")

    @property
    @pulumi.getter(name="accessTokenIntrospectionBodyArgs")
    def access_token_introspection_body_args(self) -> str:
        """
        This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
        """
        return pulumi.get(self, "access_token_introspection_body_args")

    @property
    @pulumi.getter(name="accessTokenIntrospectionConsumerBies")
    def access_token_introspection_consumer_bies(self) -> Sequence[str]:
        """
        When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
        """
        return pulumi.get(self, "access_token_introspection_consumer_bies")

    @property
    @pulumi.getter(name="accessTokenIntrospectionConsumerClaims")
    def access_token_introspection_consumer_claims(self) -> Sequence[str]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
        """
        return pulumi.get(self, "access_token_introspection_consumer_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionEndpoint")
    def access_token_introspection_endpoint(self) -> str:
        """
        When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
        """
        return pulumi.get(self, "access_token_introspection_endpoint")

    @property
    @pulumi.getter(name="accessTokenIntrospectionHint")
    def access_token_introspection_hint(self) -> str:
        """
        If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
        """
        return pulumi.get(self, "access_token_introspection_hint")

    @property
    @pulumi.getter(name="accessTokenIntrospectionJwtClaims")
    def access_token_introspection_jwt_claims(self) -> Sequence[str]:
        """
        If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
        """
        return pulumi.get(self, "access_token_introspection_jwt_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionLeeway")
    def access_token_introspection_leeway(self) -> float:
        """
        Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
        """
        return pulumi.get(self, "access_token_introspection_leeway")

    @property
    @pulumi.getter(name="accessTokenIntrospectionScopesClaims")
    def access_token_introspection_scopes_claims(self) -> Sequence[str]:
        """
        Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realm_access", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
        """
        return pulumi.get(self, "access_token_introspection_scopes_claims")

    @property
    @pulumi.getter(name="accessTokenIntrospectionScopesRequireds")
    def access_token_introspection_scopes_requireds(self) -> Sequence[str]:
        """
        Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
        """
        return pulumi.get(self, "access_token_introspection_scopes_requireds")

    @property
    @pulumi.getter(name="accessTokenIntrospectionTimeout")
    def access_token_introspection_timeout(self) -> float:
        """
        Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
        """
        return pulumi.get(self, "access_token_introspection_timeout")

    @property
    @pulumi.getter(name="accessTokenIssuer")
    def access_token_issuer(self) -> str:
        """
        The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `original_iss` claim of the newly signed access token.
        """
        return pulumi.get(self, "access_token_issuer")

    @property
    @pulumi.getter(name="accessTokenJwksUri")
    def access_token_jwks_uri(self) -> str:
        """
        Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
        """
        return pulumi.get(self, "access_token_jwks_uri")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientCertificate")
    def access_token_jwks_uri_client_certificate(self) -> str:
        """
        The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "access_token_jwks_uri_client_certificate")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientPassword")
    def access_token_jwks_uri_client_password(self) -> str:
        """
        The client password that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_username`
        """
        return pulumi.get(self, "access_token_jwks_uri_client_password")

    @property
    @pulumi.getter(name="accessTokenJwksUriClientUsername")
    def access_token_jwks_uri_client_username(self) -> str:
        """
        The client username that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_password`
        """
        return pulumi.get(self, "access_token_jwks_uri_client_username")

    @property
    @pulumi.getter(name="accessTokenJwksUriRotatePeriod")
    def access_token_jwks_uri_rotate_period(self) -> float:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `access_token_jwks_uri`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "access_token_jwks_uri_rotate_period")

    @property
    @pulumi.getter(name="accessTokenKeyset")
    def access_token_keyset(self) -> str:
        """
        The name of the keyset containing signing keys.
        """
        return pulumi.get(self, "access_token_keyset")

    @property
    @pulumi.getter(name="accessTokenKeysetClientCertificate")
    def access_token_keyset_client_certificate(self) -> str:
        """
        The client certificate that will be used to authenticate Kong if `access_token_keyset` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "access_token_keyset_client_certificate")

    @property
    @pulumi.getter(name="accessTokenKeysetClientPassword")
    def access_token_keyset_client_password(self) -> str:
        """
        The client password that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_username`
        """
        return pulumi.get(self, "access_token_keyset_client_password")

    @property
    @pulumi.getter(name="accessTokenKeysetClientUsername")
    def access_token_keyset_client_username(self) -> str:
        """
        The client username that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_password`
        """
        return pulumi.get(self, "access_token_keyset_client_username")

    @property
    @pulumi.getter(name="accessTokenKeysetRotatePeriod")
    def access_token_keyset_rotate_period(self) -> float:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `access_token_keyset`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "access_token_keyset_rotate_period")

    @property
    @pulumi.getter(name="accessTokenLeeway")
    def access_token_leeway(self) -> float:
        """
        Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
        """
        return pulumi.get(self, "access_token_leeway")

    @property
    @pulumi.getter(name="accessTokenOptional")
    def access_token_optional(self) -> bool:
        """
        If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
        """
        return pulumi.get(self, "access_token_optional")

    @property
    @pulumi.getter(name="accessTokenRequestHeader")
    def access_token_request_header(self) -> str:
        """
        This parameter tells the name of the header where to look for the access token.
        """
        return pulumi.get(self, "access_token_request_header")

    @property
    @pulumi.getter(name="accessTokenScopesClaims")
    def access_token_scopes_claims(self) -> Sequence[str]:
        """
        Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
        """
        return pulumi.get(self, "access_token_scopes_claims")

    @property
    @pulumi.getter(name="accessTokenScopesRequireds")
    def access_token_scopes_requireds(self) -> Sequence[str]:
        """
        Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
        """
        return pulumi.get(self, "access_token_scopes_requireds")

    @property
    @pulumi.getter(name="accessTokenSigningAlgorithm")
    def access_token_signing_algorithm(self) -> str:
        """
        When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        """
        return pulumi.get(self, "access_token_signing_algorithm")

    @property
    @pulumi.getter(name="accessTokenUpstreamHeader")
    def access_token_upstream_header(self) -> str:
        """
        Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
        """
        return pulumi.get(self, "access_token_upstream_header")

    @property
    @pulumi.getter(name="accessTokenUpstreamLeeway")
    def access_token_upstream_leeway(self) -> float:
        """
        If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
        """
        return pulumi.get(self, "access_token_upstream_leeway")

    @property
    @pulumi.getter(name="addAccessTokenClaims")
    def add_access_token_claims(self) -> Mapping[str, str]:
        """
        Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_access_token_claims")

    @property
    @pulumi.getter(name="addChannelTokenClaims")
    def add_channel_token_claims(self) -> Mapping[str, str]:
        """
        Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_channel_token_claims")

    @property
    @pulumi.getter(name="addClaims")
    def add_claims(self) -> Mapping[str, str]:
        """
        Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "add_claims")

    @property
    @pulumi.getter(name="cacheAccessTokenIntrospection")
    def cache_access_token_introspection(self) -> bool:
        """
        Whether to cache access token introspection results.
        """
        return pulumi.get(self, "cache_access_token_introspection")

    @property
    @pulumi.getter(name="cacheChannelTokenIntrospection")
    def cache_channel_token_introspection(self) -> bool:
        """
        Whether to cache channel token introspection results.
        """
        return pulumi.get(self, "cache_channel_token_introspection")

    @property
    @pulumi.getter(name="channelTokenConsumerBies")
    def channel_token_consumer_bies(self) -> Sequence[str]:
        """
        When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `custom_id`.
        """
        return pulumi.get(self, "channel_token_consumer_bies")

    @property
    @pulumi.getter(name="channelTokenConsumerClaims")
    def channel_token_consumer_claims(self) -> Sequence[str]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `custom_id`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
        """
        return pulumi.get(self, "channel_token_consumer_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionAuthorization")
    def channel_token_introspection_authorization(self) -> str:
        """
        When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
        """
        return pulumi.get(self, "channel_token_introspection_authorization")

    @property
    @pulumi.getter(name="channelTokenIntrospectionBodyArgs")
    def channel_token_introspection_body_args(self) -> str:
        """
        If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
        """
        return pulumi.get(self, "channel_token_introspection_body_args")

    @property
    @pulumi.getter(name="channelTokenIntrospectionConsumerBies")
    def channel_token_introspection_consumer_bies(self) -> Sequence[str]:
        """
        When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `custom_id`.
        """
        return pulumi.get(self, "channel_token_introspection_consumer_bies")

    @property
    @pulumi.getter(name="channelTokenIntrospectionConsumerClaims")
    def channel_token_introspection_consumer_claims(self) -> Sequence[str]:
        """
        When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
        """
        return pulumi.get(self, "channel_token_introspection_consumer_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionEndpoint")
    def channel_token_introspection_endpoint(self) -> str:
        """
        When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
        """
        return pulumi.get(self, "channel_token_introspection_endpoint")

    @property
    @pulumi.getter(name="channelTokenIntrospectionHint")
    def channel_token_introspection_hint(self) -> str:
        """
        If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
        """
        return pulumi.get(self, "channel_token_introspection_hint")

    @property
    @pulumi.getter(name="channelTokenIntrospectionJwtClaims")
    def channel_token_introspection_jwt_claims(self) -> Sequence[str]:
        """
        If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
        """
        return pulumi.get(self, "channel_token_introspection_jwt_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionLeeway")
    def channel_token_introspection_leeway(self) -> float:
        """
        You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
        """
        return pulumi.get(self, "channel_token_introspection_leeway")

    @property
    @pulumi.getter(name="channelTokenIntrospectionScopesClaims")
    def channel_token_introspection_scopes_claims(self) -> Sequence[str]:
        """
        Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
        """
        return pulumi.get(self, "channel_token_introspection_scopes_claims")

    @property
    @pulumi.getter(name="channelTokenIntrospectionScopesRequireds")
    def channel_token_introspection_scopes_requireds(self) -> Sequence[str]:
        """
        Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
        """
        return pulumi.get(self, "channel_token_introspection_scopes_requireds")

    @property
    @pulumi.getter(name="channelTokenIntrospectionTimeout")
    def channel_token_introspection_timeout(self) -> float:
        """
        Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
        """
        return pulumi.get(self, "channel_token_introspection_timeout")

    @property
    @pulumi.getter(name="channelTokenIssuer")
    def channel_token_issuer(self) -> str:
        """
        The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `original_iss` claim of the newly signed channel token.
        """
        return pulumi.get(self, "channel_token_issuer")

    @property
    @pulumi.getter(name="channelTokenJwksUri")
    def channel_token_jwks_uri(self) -> str:
        """
        If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
        """
        return pulumi.get(self, "channel_token_jwks_uri")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientCertificate")
    def channel_token_jwks_uri_client_certificate(self) -> str:
        """
        The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_certificate")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientPassword")
    def channel_token_jwks_uri_client_password(self) -> str:
        """
        The client password that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_username`
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_password")

    @property
    @pulumi.getter(name="channelTokenJwksUriClientUsername")
    def channel_token_jwks_uri_client_username(self) -> str:
        """
        The client username that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_password`
        """
        return pulumi.get(self, "channel_token_jwks_uri_client_username")

    @property
    @pulumi.getter(name="channelTokenJwksUriRotatePeriod")
    def channel_token_jwks_uri_rotate_period(self) -> float:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `channel_token_jwks_uri`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "channel_token_jwks_uri_rotate_period")

    @property
    @pulumi.getter(name="channelTokenKeyset")
    def channel_token_keyset(self) -> str:
        """
        The name of the keyset containing signing keys.
        """
        return pulumi.get(self, "channel_token_keyset")

    @property
    @pulumi.getter(name="channelTokenKeysetClientCertificate")
    def channel_token_keyset_client_certificate(self) -> str:
        """
        The client certificate that will be used to authenticate Kong if `channel_token_keyset` is an https uri that requires mTLS Auth.
        """
        return pulumi.get(self, "channel_token_keyset_client_certificate")

    @property
    @pulumi.getter(name="channelTokenKeysetClientPassword")
    def channel_token_keyset_client_password(self) -> str:
        """
        The client password that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_username`
        """
        return pulumi.get(self, "channel_token_keyset_client_password")

    @property
    @pulumi.getter(name="channelTokenKeysetClientUsername")
    def channel_token_keyset_client_username(self) -> str:
        """
        The client username that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_password`
        """
        return pulumi.get(self, "channel_token_keyset_client_username")

    @property
    @pulumi.getter(name="channelTokenKeysetRotatePeriod")
    def channel_token_keyset_rotate_period(self) -> float:
        """
        Specify the period (in seconds) to auto-rotate the jwks for `channel_token_keyset`. The default value 0 means no auto-rotation.
        """
        return pulumi.get(self, "channel_token_keyset_rotate_period")

    @property
    @pulumi.getter(name="channelTokenLeeway")
    def channel_token_leeway(self) -> float:
        """
        Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
        """
        return pulumi.get(self, "channel_token_leeway")

    @property
    @pulumi.getter(name="channelTokenOptional")
    def channel_token_optional(self) -> bool:
        """
        If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
        """
        return pulumi.get(self, "channel_token_optional")

    @property
    @pulumi.getter(name="channelTokenRequestHeader")
    def channel_token_request_header(self) -> str:
        """
        This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
        """
        return pulumi.get(self, "channel_token_request_header")

    @property
    @pulumi.getter(name="channelTokenScopesClaims")
    def channel_token_scopes_claims(self) -> Sequence[str]:
        """
        Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
        """
        return pulumi.get(self, "channel_token_scopes_claims")

    @property
    @pulumi.getter(name="channelTokenScopesRequireds")
    def channel_token_scopes_requireds(self) -> Sequence[str]:
        """
        Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
        """
        return pulumi.get(self, "channel_token_scopes_requireds")

    @property
    @pulumi.getter(name="channelTokenSigningAlgorithm")
    def channel_token_signing_algorithm(self) -> str:
        """
        When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
        """
        return pulumi.get(self, "channel_token_signing_algorithm")

    @property
    @pulumi.getter(name="channelTokenUpstreamHeader")
    def channel_token_upstream_header(self) -> str:
        """
        This plugin removes the `config.channel_token_request_header` from the request after reading its value.
        """
        return pulumi.get(self, "channel_token_upstream_header")

    @property
    @pulumi.getter(name="channelTokenUpstreamLeeway")
    def channel_token_upstream_leeway(self) -> float:
        """
        If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
        """
        return pulumi.get(self, "channel_token_upstream_leeway")

    @property
    @pulumi.getter(name="enableAccessTokenIntrospection")
    def enable_access_token_introspection(self) -> bool:
        """
        If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
        """
        return pulumi.get(self, "enable_access_token_introspection")

    @property
    @pulumi.getter(name="enableChannelTokenIntrospection")
    def enable_channel_token_introspection(self) -> bool:
        """
        If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
        """
        return pulumi.get(self, "enable_channel_token_introspection")

    @property
    @pulumi.getter(name="enableHsSignatures")
    def enable_hs_signatures(self) -> bool:
        """
        Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
        """
        return pulumi.get(self, "enable_hs_signatures")

    @property
    @pulumi.getter(name="enableInstrumentation")
    def enable_instrumentation(self) -> bool:
        """
        Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
        """
        return pulumi.get(self, "enable_instrumentation")

    @property
    @pulumi.getter(name="originalAccessTokenUpstreamHeader")
    def original_access_token_upstream_header(self) -> str:
        """
        The HTTP header name used to store the original access token.
        """
        return pulumi.get(self, "original_access_token_upstream_header")

    @property
    @pulumi.getter(name="originalChannelTokenUpstreamHeader")
    def original_channel_token_upstream_header(self) -> str:
        """
        The HTTP header name used to store the original channel token.
        """
        return pulumi.get(self, "original_channel_token_upstream_header")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="removeAccessTokenClaims")
    def remove_access_token_claims(self) -> Sequence[str]:
        """
        remove claims. It should be an array, and each element is a claim key string.
        """
        return pulumi.get(self, "remove_access_token_claims")

    @property
    @pulumi.getter(name="removeChannelTokenClaims")
    def remove_channel_token_claims(self) -> Sequence[str]:
        """
        remove claims. It should be an array, and each element is a claim key string.
        """
        return pulumi.get(self, "remove_channel_token_claims")

    @property
    @pulumi.getter(name="setAccessTokenClaims")
    def set_access_token_claims(self) -> Mapping[str, str]:
        """
        Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_access_token_claims")

    @property
    @pulumi.getter(name="setChannelTokenClaims")
    def set_channel_token_claims(self) -> Mapping[str, str]:
        """
        Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_channel_token_claims")

    @property
    @pulumi.getter(name="setClaims")
    def set_claims(self) -> Mapping[str, str]:
        """
        Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
        """
        return pulumi.get(self, "set_claims")

    @property
    @pulumi.getter(name="trustAccessTokenIntrospection")
    def trust_access_token_introspection(self) -> bool:
        """
        Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
        """
        return pulumi.get(self, "trust_access_token_introspection")

    @property
    @pulumi.getter(name="trustChannelTokenIntrospection")
    def trust_channel_token_introspection(self) -> bool:
        """
        Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel_token_introspection_jwt_claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
        """
        return pulumi.get(self, "trust_channel_token_introspection")

    @property
    @pulumi.getter(name="verifyAccessTokenExpiry")
    def verify_access_token_expiry(self) -> bool:
        """
        Quickly turn access token expiry verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_expiry")

    @property
    @pulumi.getter(name="verifyAccessTokenIntrospectionExpiry")
    def verify_access_token_introspection_expiry(self) -> bool:
        """
        Quickly turn access token introspection expiry verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_introspection_expiry")

    @property
    @pulumi.getter(name="verifyAccessTokenIntrospectionScopes")
    def verify_access_token_introspection_scopes(self) -> bool:
        """
        Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
        """
        return pulumi.get(self, "verify_access_token_introspection_scopes")

    @property
    @pulumi.getter(name="verifyAccessTokenScopes")
    def verify_access_token_scopes(self) -> bool:
        """
        Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
        """
        return pulumi.get(self, "verify_access_token_scopes")

    @property
    @pulumi.getter(name="verifyAccessTokenSignature")
    def verify_access_token_signature(self) -> bool:
        """
        Quickly turn access token signature verification off and on as needed.
        """
        return pulumi.get(self, "verify_access_token_signature")

    @property
    @pulumi.getter(name="verifyChannelTokenExpiry")
    def verify_channel_token_expiry(self) -> bool:
        return pulumi.get(self, "verify_channel_token_expiry")

    @property
    @pulumi.getter(name="verifyChannelTokenIntrospectionExpiry")
    def verify_channel_token_introspection_expiry(self) -> bool:
        """
        Quickly turn on/off the channel token introspection expiry verification.
        """
        return pulumi.get(self, "verify_channel_token_introspection_expiry")

    @property
    @pulumi.getter(name="verifyChannelTokenIntrospectionScopes")
    def verify_channel_token_introspection_scopes(self) -> bool:
        """
        Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
        """
        return pulumi.get(self, "verify_channel_token_introspection_scopes")

    @property
    @pulumi.getter(name="verifyChannelTokenScopes")
    def verify_channel_token_scopes(self) -> bool:
        """
        Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
        """
        return pulumi.get(self, "verify_channel_token_scopes")

    @property
    @pulumi.getter(name="verifyChannelTokenSignature")
    def verify_channel_token_signature(self) -> bool:
        """
        Quickly turn on/off the channel token signature verification.
        """
        return pulumi.get(self, "verify_channel_token_signature")


@pulumi.output_type
class GetGatewayPluginJwtSignerConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtSignerConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtSignerRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginJwtSignerServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginKeyAuthConfigResult(dict):
    def __init__(__self__, *,
                 anonymous: str,
                 hide_credentials: bool,
                 key_in_body: bool,
                 key_in_header: bool,
                 key_in_query: bool,
                 key_names: Sequence[str],
                 realm: str,
                 run_on_preflight: bool):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
        :param bool key_in_body: If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
        :param bool key_in_header: If enabled (default), the plugin reads the request header and tries to find the key in it.
        :param bool key_in_query: If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
        :param Sequence[str] key_names: Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
        :param str realm: When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        :param bool run_on_preflight: A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
        """
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "hide_credentials", hide_credentials)
        pulumi.set(__self__, "key_in_body", key_in_body)
        pulumi.set(__self__, "key_in_header", key_in_header)
        pulumi.set(__self__, "key_in_query", key_in_query)
        pulumi.set(__self__, "key_names", key_names)
        pulumi.set(__self__, "realm", realm)
        pulumi.set(__self__, "run_on_preflight", run_on_preflight)

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> bool:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="keyInBody")
    def key_in_body(self) -> bool:
        """
        If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
        """
        return pulumi.get(self, "key_in_body")

    @property
    @pulumi.getter(name="keyInHeader")
    def key_in_header(self) -> bool:
        """
        If enabled (default), the plugin reads the request header and tries to find the key in it.
        """
        return pulumi.get(self, "key_in_header")

    @property
    @pulumi.getter(name="keyInQuery")
    def key_in_query(self) -> bool:
        """
        If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
        """
        return pulumi.get(self, "key_in_query")

    @property
    @pulumi.getter(name="keyNames")
    def key_names(self) -> Sequence[str]:
        """
        Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
        """
        return pulumi.get(self, "key_names")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> bool:
        """
        A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
        """
        return pulumi.get(self, "run_on_preflight")


@pulumi.output_type
class GetGatewayPluginKeyAuthConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginKeyAuthConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginKeyAuthRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginKeyAuthServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOauth2ConfigResult(dict):
    def __init__(__self__, *,
                 accept_http_if_already_terminated: bool,
                 anonymous: str,
                 auth_header_name: str,
                 enable_authorization_code: bool,
                 enable_client_credentials: bool,
                 enable_implicit_grant: bool,
                 enable_password_grant: bool,
                 global_credentials: bool,
                 hide_credentials: bool,
                 mandatory_scope: bool,
                 persistent_refresh_token: bool,
                 pkce: str,
                 provision_key: str,
                 refresh_token_ttl: float,
                 reuse_refresh_token: bool,
                 scopes: Sequence[str],
                 token_expiration: float):
        """
        :param bool accept_http_if_already_terminated: Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        :param str auth_header_name: The name of the header that is supposed to carry the access token.
        :param bool enable_authorization_code: An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
        :param bool enable_client_credentials: An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
        :param bool enable_implicit_grant: An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
        :param bool enable_password_grant: An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
        :param bool global_credentials: An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
        :param bool hide_credentials: An optional boolean value telling the plugin to show or hide the credential from the upstream service.
        :param bool mandatory_scope: An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
        :param str pkce: Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
        :param str provision_key: The unique key the plugin has generated when it has been added to the Service.
        :param float refresh_token_ttl: Time-to-live value for data
        :param bool reuse_refresh_token: An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
        :param Sequence[str] scopes: Describes an array of scope names that will be available to the end user. If `mandatory_scope` is set to `true`, then `scopes` are required.
        :param float token_expiration: An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
        """
        pulumi.set(__self__, "accept_http_if_already_terminated", accept_http_if_already_terminated)
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "auth_header_name", auth_header_name)
        pulumi.set(__self__, "enable_authorization_code", enable_authorization_code)
        pulumi.set(__self__, "enable_client_credentials", enable_client_credentials)
        pulumi.set(__self__, "enable_implicit_grant", enable_implicit_grant)
        pulumi.set(__self__, "enable_password_grant", enable_password_grant)
        pulumi.set(__self__, "global_credentials", global_credentials)
        pulumi.set(__self__, "hide_credentials", hide_credentials)
        pulumi.set(__self__, "mandatory_scope", mandatory_scope)
        pulumi.set(__self__, "persistent_refresh_token", persistent_refresh_token)
        pulumi.set(__self__, "pkce", pkce)
        pulumi.set(__self__, "provision_key", provision_key)
        pulumi.set(__self__, "refresh_token_ttl", refresh_token_ttl)
        pulumi.set(__self__, "reuse_refresh_token", reuse_refresh_token)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token_expiration", token_expiration)

    @property
    @pulumi.getter(name="acceptHttpIfAlreadyTerminated")
    def accept_http_if_already_terminated(self) -> bool:
        """
        Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
        """
        return pulumi.get(self, "accept_http_if_already_terminated")

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="authHeaderName")
    def auth_header_name(self) -> str:
        """
        The name of the header that is supposed to carry the access token.
        """
        return pulumi.get(self, "auth_header_name")

    @property
    @pulumi.getter(name="enableAuthorizationCode")
    def enable_authorization_code(self) -> bool:
        """
        An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
        """
        return pulumi.get(self, "enable_authorization_code")

    @property
    @pulumi.getter(name="enableClientCredentials")
    def enable_client_credentials(self) -> bool:
        """
        An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
        """
        return pulumi.get(self, "enable_client_credentials")

    @property
    @pulumi.getter(name="enableImplicitGrant")
    def enable_implicit_grant(self) -> bool:
        """
        An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
        """
        return pulumi.get(self, "enable_implicit_grant")

    @property
    @pulumi.getter(name="enablePasswordGrant")
    def enable_password_grant(self) -> bool:
        """
        An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
        """
        return pulumi.get(self, "enable_password_grant")

    @property
    @pulumi.getter(name="globalCredentials")
    def global_credentials(self) -> bool:
        """
        An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
        """
        return pulumi.get(self, "global_credentials")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> bool:
        """
        An optional boolean value telling the plugin to show or hide the credential from the upstream service.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="mandatoryScope")
    def mandatory_scope(self) -> bool:
        """
        An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
        """
        return pulumi.get(self, "mandatory_scope")

    @property
    @pulumi.getter(name="persistentRefreshToken")
    def persistent_refresh_token(self) -> bool:
        return pulumi.get(self, "persistent_refresh_token")

    @property
    @pulumi.getter
    def pkce(self) -> str:
        """
        Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
        """
        return pulumi.get(self, "pkce")

    @property
    @pulumi.getter(name="provisionKey")
    def provision_key(self) -> str:
        """
        The unique key the plugin has generated when it has been added to the Service.
        """
        return pulumi.get(self, "provision_key")

    @property
    @pulumi.getter(name="refreshTokenTtl")
    def refresh_token_ttl(self) -> float:
        """
        Time-to-live value for data
        """
        return pulumi.get(self, "refresh_token_ttl")

    @property
    @pulumi.getter(name="reuseRefreshToken")
    def reuse_refresh_token(self) -> bool:
        """
        An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
        """
        return pulumi.get(self, "reuse_refresh_token")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Describes an array of scope names that will be available to the end user. If `mandatory_scope` is set to `true`, then `scopes` are required.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="tokenExpiration")
    def token_expiration(self) -> float:
        """
        An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
        """
        return pulumi.get(self, "token_expiration")


@pulumi.output_type
class GetGatewayPluginOauth2ConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOauth2ConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOauth2RouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOauth2ServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpenidConnectConfigResult(dict):
    def __init__(__self__, *,
                 anonymous: str,
                 audience_claims: Sequence[str],
                 audience_requireds: Sequence[str],
                 audiences: Sequence[str],
                 auth_methods: Sequence[str],
                 authenticated_groups_claims: Sequence[str],
                 authorization_cookie_domain: str,
                 authorization_cookie_http_only: bool,
                 authorization_cookie_name: str,
                 authorization_cookie_path: str,
                 authorization_cookie_same_site: str,
                 authorization_cookie_secure: bool,
                 authorization_endpoint: str,
                 authorization_query_args_clients: Sequence[str],
                 authorization_query_args_names: Sequence[str],
                 authorization_query_args_values: Sequence[str],
                 authorization_rolling_timeout: float,
                 bearer_token_cookie_name: str,
                 bearer_token_param_types: Sequence[str],
                 by_username_ignore_case: bool,
                 cache_introspection: bool,
                 cache_token_exchange: bool,
                 cache_tokens: bool,
                 cache_tokens_salt: str,
                 cache_ttl: float,
                 cache_ttl_max: float,
                 cache_ttl_min: float,
                 cache_ttl_neg: float,
                 cache_ttl_resurrect: float,
                 cache_user_info: bool,
                 client_algs: Sequence[str],
                 client_arg: str,
                 client_auths: Sequence[str],
                 client_credentials_param_types: Sequence[str],
                 client_ids: Sequence[str],
                 client_jwks: Sequence['outputs.GetGatewayPluginOpenidConnectConfigClientJwkResult'],
                 client_secrets: Sequence[str],
                 consumer_bies: Sequence[str],
                 consumer_claims: Sequence[str],
                 consumer_optional: bool,
                 credential_claims: Sequence[str],
                 disable_sessions: Sequence[str],
                 discovery_headers_names: Sequence[str],
                 discovery_headers_values: Sequence[str],
                 display_errors: bool,
                 domains: Sequence[str],
                 downstream_access_token_header: str,
                 downstream_access_token_jwk_header: str,
                 downstream_headers_claims: Sequence[str],
                 downstream_headers_names: Sequence[str],
                 downstream_id_token_header: str,
                 downstream_id_token_jwk_header: str,
                 downstream_introspection_header: str,
                 downstream_introspection_jwt_header: str,
                 downstream_refresh_token_header: str,
                 downstream_session_id_header: str,
                 downstream_user_info_header: str,
                 downstream_user_info_jwt_header: str,
                 dpop_proof_lifetime: float,
                 dpop_use_nonce: bool,
                 enable_hs_signatures: bool,
                 end_session_endpoint: str,
                 expose_error_code: bool,
                 extra_jwks_uris: Sequence[str],
                 forbidden_destroy_session: bool,
                 forbidden_error_message: str,
                 forbidden_redirect_uris: Sequence[str],
                 groups_claims: Sequence[str],
                 groups_requireds: Sequence[str],
                 hide_credentials: bool,
                 http_proxy: str,
                 http_proxy_authorization: str,
                 http_version: float,
                 https_proxy: str,
                 https_proxy_authorization: str,
                 id_token_param_name: str,
                 id_token_param_types: Sequence[str],
                 ignore_signatures: Sequence[str],
                 introspect_jwt_tokens: bool,
                 introspection_accept: str,
                 introspection_check_active: bool,
                 introspection_endpoint: str,
                 introspection_endpoint_auth_method: str,
                 introspection_headers_clients: Sequence[str],
                 introspection_headers_names: Sequence[str],
                 introspection_headers_values: Sequence[str],
                 introspection_hint: str,
                 introspection_post_args_clients: Sequence[str],
                 introspection_post_args_names: Sequence[str],
                 introspection_post_args_values: Sequence[str],
                 introspection_token_param_name: str,
                 issuer: str,
                 issuers_alloweds: Sequence[str],
                 jwt_session_claim: str,
                 jwt_session_cookie: str,
                 keepalive: bool,
                 leeway: float,
                 login_action: str,
                 login_methods: Sequence[str],
                 login_redirect_mode: str,
                 login_redirect_uris: Sequence[str],
                 login_tokens: Sequence[str],
                 logout_methods: Sequence[str],
                 logout_post_arg: str,
                 logout_query_arg: str,
                 logout_redirect_uris: Sequence[str],
                 logout_revoke: bool,
                 logout_revoke_access_token: bool,
                 logout_revoke_refresh_token: bool,
                 logout_uri_suffix: str,
                 max_age: float,
                 mtls_introspection_endpoint: str,
                 mtls_revocation_endpoint: str,
                 mtls_token_endpoint: str,
                 no_proxy: str,
                 password_param_types: Sequence[str],
                 preserve_query_args: bool,
                 proof_of_possession_auth_methods_validation: bool,
                 proof_of_possession_dpop: str,
                 proof_of_possession_mtls: str,
                 pushed_authorization_request_endpoint: str,
                 pushed_authorization_request_endpoint_auth_method: str,
                 redirect_uris: Sequence[str],
                 rediscovery_lifetime: float,
                 refresh_token_param_name: str,
                 refresh_token_param_types: Sequence[str],
                 refresh_tokens: bool,
                 require_proof_key_for_code_exchange: bool,
                 require_pushed_authorization_requests: bool,
                 require_signed_request_object: bool,
                 resolve_distributed_claims: bool,
                 response_mode: str,
                 response_types: Sequence[str],
                 reverify: bool,
                 revocation_endpoint: str,
                 revocation_endpoint_auth_method: str,
                 revocation_token_param_name: str,
                 roles_claims: Sequence[str],
                 roles_requireds: Sequence[str],
                 run_on_preflight: bool,
                 scopes: Sequence[str],
                 scopes_claims: Sequence[str],
                 scopes_requireds: Sequence[str],
                 search_user_info: bool,
                 session_absolute_timeout: float,
                 session_audience: str,
                 session_cookie_domain: str,
                 session_cookie_http_only: bool,
                 session_cookie_name: str,
                 session_cookie_path: str,
                 session_cookie_same_site: str,
                 session_cookie_secure: bool,
                 session_enforce_same_subject: bool,
                 session_hash_storage_key: bool,
                 session_hash_subject: bool,
                 session_idling_timeout: float,
                 session_memcached_host: str,
                 session_memcached_port: int,
                 session_memcached_prefix: str,
                 session_memcached_socket: str,
                 session_redis_cluster_max_redirections: int,
                 session_redis_cluster_nodes: Sequence['outputs.GetGatewayPluginOpenidConnectConfigSessionRedisClusterNodeResult'],
                 session_redis_connect_timeout: int,
                 session_redis_host: str,
                 session_redis_password: str,
                 session_redis_port: int,
                 session_redis_prefix: str,
                 session_redis_read_timeout: int,
                 session_redis_send_timeout: int,
                 session_redis_server_name: str,
                 session_redis_socket: str,
                 session_redis_ssl: bool,
                 session_redis_ssl_verify: bool,
                 session_redis_username: str,
                 session_remember: bool,
                 session_remember_absolute_timeout: float,
                 session_remember_cookie_name: str,
                 session_remember_rolling_timeout: float,
                 session_request_headers: Sequence[str],
                 session_response_headers: Sequence[str],
                 session_rolling_timeout: float,
                 session_secret: str,
                 session_storage: str,
                 session_store_metadata: bool,
                 ssl_verify: bool,
                 timeout: float,
                 tls_client_auth_cert_id: str,
                 tls_client_auth_ssl_verify: bool,
                 token_cache_key_include_scope: bool,
                 token_endpoint: str,
                 token_endpoint_auth_method: str,
                 token_exchange_endpoint: str,
                 token_headers_clients: Sequence[str],
                 token_headers_grants: Sequence[str],
                 token_headers_names: Sequence[str],
                 token_headers_prefix: str,
                 token_headers_replays: Sequence[str],
                 token_headers_values: Sequence[str],
                 token_post_args_clients: Sequence[str],
                 token_post_args_names: Sequence[str],
                 token_post_args_values: Sequence[str],
                 unauthorized_destroy_session: bool,
                 unauthorized_error_message: str,
                 unauthorized_redirect_uris: Sequence[str],
                 unexpected_redirect_uris: Sequence[str],
                 upstream_access_token_header: str,
                 upstream_access_token_jwk_header: str,
                 upstream_headers_claims: Sequence[str],
                 upstream_headers_names: Sequence[str],
                 upstream_id_token_header: str,
                 upstream_id_token_jwk_header: str,
                 upstream_introspection_header: str,
                 upstream_introspection_jwt_header: str,
                 upstream_refresh_token_header: str,
                 upstream_session_id_header: str,
                 upstream_user_info_header: str,
                 upstream_user_info_jwt_header: str,
                 userinfo_accept: str,
                 userinfo_endpoint: str,
                 userinfo_headers_clients: Sequence[str],
                 userinfo_headers_names: Sequence[str],
                 userinfo_headers_values: Sequence[str],
                 userinfo_query_args_clients: Sequence[str],
                 userinfo_query_args_names: Sequence[str],
                 userinfo_query_args_values: Sequence[str],
                 using_pseudo_issuer: bool,
                 verify_claims: bool,
                 verify_nonce: bool,
                 verify_parameters: bool,
                 verify_signature: bool):
        """
        :param str anonymous: An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
        :param Sequence[str] audience_claims: The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] audience_requireds: The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param Sequence[str] audiences: The audience passed to the authorization endpoint.
        :param Sequence[str] auth_methods: Types of credentials/grants to enable.
        :param Sequence[str] authenticated_groups_claims: The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param str authorization_cookie_domain: The authorization cookie Domain flag.
        :param bool authorization_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str authorization_cookie_name: The authorization cookie name.
        :param str authorization_cookie_path: The authorization cookie Path flag.
        :param str authorization_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool authorization_cookie_secure: Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param str authorization_endpoint: The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
        :param Sequence[str] authorization_query_args_clients: Extra query arguments passed from the client to the authorization endpoint.
        :param Sequence[str] authorization_query_args_names: Extra query argument names passed to the authorization endpoint.
        :param Sequence[str] authorization_query_args_values: Extra query argument values passed to the authorization endpoint.
        :param float authorization_rolling_timeout: Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        :param str bearer_token_cookie_name: The name of the cookie in which the bearer token is passed.
        :param Sequence[str] bearer_token_param_types: Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
        :param bool by_username_ignore_case: If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
        :param bool cache_introspection: Cache the introspection endpoint requests.
        :param bool cache_token_exchange: Cache the token exchange endpoint requests.
        :param bool cache_tokens: Cache the token endpoint requests.
        :param str cache_tokens_salt: Salt used for generating the cache key that is used for caching the token endpoint requests.
        :param float cache_ttl: The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
        :param float cache_ttl_max: The maximum cache ttl in seconds (enforced).
        :param float cache_ttl_min: The minimum cache ttl in seconds (enforced).
        :param float cache_ttl_neg: The negative cache ttl in seconds.
        :param float cache_ttl_resurrect: The resurrection ttl in seconds.
        :param bool cache_user_info: Cache the user info requests.
        :param Sequence[str] client_algs: The algorithm to use for client_secret_jwt (only HS***) or private_key_jwt authentication.
        :param str client_arg: The client to use for this request (the selection is made with a request parameter with the same name).
        :param Sequence[str] client_auths: The default OpenID Connect client authentication method is 'client_secret_basic' (using 'Authorization: Basic' header), 'client_secret_post' (credentials in body), 'client_secret_jwt' (signed client assertion in body), 'private_key_jwt' (private key-signed assertion), 'tls_client_auth' (client certificate), 'self_signed_tls_client_auth' (self-signed client certificate), and 'none' (no authentication).
        :param Sequence[str] client_credentials_param_types: Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
        :param Sequence[str] client_ids: The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
        :param Sequence['GetGatewayPluginOpenidConnectConfigClientJwkArgs'] client_jwks: The JWK used for the private_key_jwt authentication.
        :param Sequence[str] client_secrets: The client secret.
        :param Sequence[str] consumer_bies: Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
        :param Sequence[str] consumer_claims: The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param bool consumer_optional: Do not terminate the request if consumer mapping fails.
        :param Sequence[str] credential_claims: The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] disable_sessions: Disable issuing the session cookie with the specified grants.
        :param Sequence[str] discovery_headers_names: Extra header names passed to the discovery endpoint.
        :param Sequence[str] discovery_headers_values: Extra header values passed to the discovery endpoint.
        :param bool display_errors: Display errors on failure responses.
        :param Sequence[str] domains: The allowed values for the `hd` claim.
        :param str downstream_access_token_header: The downstream access token header.
        :param str downstream_access_token_jwk_header: The downstream access token JWK header.
        :param Sequence[str] downstream_headers_claims: The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] downstream_headers_names: The downstream header names for the claim values.
        :param str downstream_id_token_header: The downstream id token header.
        :param str downstream_id_token_jwk_header: The downstream id token JWK header.
        :param str downstream_introspection_header: The downstream introspection header.
        :param str downstream_introspection_jwt_header: The downstream introspection JWT header.
        :param str downstream_refresh_token_header: The downstream refresh token header.
        :param str downstream_session_id_header: The downstream session id header.
        :param str downstream_user_info_header: The downstream user info header.
        :param str downstream_user_info_jwt_header: The downstream user info JWT header (in case the user info returns a JWT response).
        :param float dpop_proof_lifetime: Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
        :param bool dpop_use_nonce: Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
        :param bool enable_hs_signatures: Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
        :param str end_session_endpoint: The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
        :param bool expose_error_code: Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
        :param Sequence[str] extra_jwks_uris: JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
        :param bool forbidden_destroy_session: Destroy any active session for the forbidden requests.
        :param str forbidden_error_message: The error message for the forbidden requests (when not using the redirection).
        :param Sequence[str] forbidden_redirect_uris: Where to redirect the client on forbidden requests.
        :param Sequence[str] groups_claims: The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] groups_requireds: The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool hide_credentials: Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
        :param str http_proxy: The HTTP proxy.
        :param str http_proxy_authorization: The HTTP proxy authorization.
        :param float http_version: The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
        :param str https_proxy: The HTTPS proxy.
        :param str https_proxy_authorization: The HTTPS proxy authorization.
        :param str id_token_param_name: The name of the parameter used to pass the id token.
        :param Sequence[str] id_token_param_types: Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param Sequence[str] ignore_signatures: Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
        :param bool introspect_jwt_tokens: Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
        :param str introspection_accept: The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
        :param bool introspection_check_active: Check that the introspection response has an `active` claim with a value of `true`.
        :param str introspection_endpoint: The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
        :param str introspection_endpoint_auth_method: The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param Sequence[str] introspection_headers_clients: Extra headers passed from the client to the introspection endpoint.
        :param Sequence[str] introspection_headers_names: Extra header names passed to the introspection endpoint.
        :param Sequence[str] introspection_headers_values: Extra header values passed to the introspection endpoint.
        :param str introspection_hint: Introspection hint parameter value passed to the introspection endpoint.
        :param Sequence[str] introspection_post_args_clients: Extra post arguments passed from the client to the introspection endpoint.
        :param Sequence[str] introspection_post_args_names: Extra post argument names passed to the introspection endpoint.
        :param Sequence[str] introspection_post_args_values: Extra post argument values passed to the introspection endpoint.
        :param str introspection_token_param_name: Designate token's parameter name for introspection.
        :param str issuer: The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
        :param Sequence[str] issuers_alloweds: The issuers allowed to be present in the tokens (`iss` claim).
        :param str jwt_session_claim: The claim to match against the JWT session cookie.
        :param str jwt_session_cookie: The name of the JWT session cookie.
        :param bool keepalive: Use keepalive with the HTTP client.
        :param float leeway: Defines leeway time (in seconds) for `auth_time`, `exp`, `iat`, and `nbf` claims
        :param str login_action: What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
        :param Sequence[str] login_methods: Enable login functionality with specified grants.
        :param str login_redirect_mode: Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
        :param Sequence[str] login_redirect_uris: Where to redirect the client when `login_action` is set to `redirect`.
        :param Sequence[str] login_tokens: What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
        :param Sequence[str] logout_methods: The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
        :param str logout_post_arg: The request body argument that activates the logout.
        :param str logout_query_arg: The request query argument that activates the logout.
        :param Sequence[str] logout_redirect_uris: Where to redirect the client after the logout.
        :param bool logout_revoke: Revoke tokens as part of the logout.
               
               For more granular token revocation, you can also adjust the `logout_revoke_access_token` and `logout_revoke_refresh_token` parameters.
        :param bool logout_revoke_access_token: Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
        :param bool logout_revoke_refresh_token: Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
        :param str logout_uri_suffix: The request URI suffix that activates the logout.
        :param float max_age: The maximum age (in seconds) compared to the `auth_time` claim.
        :param str mtls_introspection_endpoint: Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str mtls_revocation_endpoint: Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str mtls_token_endpoint: Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        :param str no_proxy: Do not use proxy with these hosts.
        :param Sequence[str] password_param_types: Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param bool preserve_query_args: With this parameter, you can preserve request query arguments even when doing authorization code flow.
        :param bool proof_of_possession_auth_methods_validation: If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
        :param str proof_of_possession_dpop: Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
        :param str proof_of_possession_mtls: Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
        :param str pushed_authorization_request_endpoint: The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
        :param str pushed_authorization_request_endpoint_auth_method: The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param Sequence[str] redirect_uris: The redirect URI passed to the authorization and token endpoints.
        :param float rediscovery_lifetime: Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
        :param str refresh_token_param_name: The name of the parameter used to pass the refresh token.
        :param Sequence[str] refresh_token_param_types: Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        :param bool refresh_tokens: Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
        :param bool require_proof_key_for_code_exchange: Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
        :param bool require_pushed_authorization_requests: Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
        :param bool require_signed_request_object: Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `require_signed_request_object`, and enabled automatically (in case the `require_signed_request_object` is missing, the feature will not be enabled).
        :param bool resolve_distributed_claims: Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
        :param str response_mode: Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `form_post`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `form_post` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "form_post", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
        :param Sequence[str] response_types: The response type passed to the authorization endpoint.
        :param bool reverify: Specifies whether to always verify tokens stored in the session.
        :param str revocation_endpoint: The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
        :param str revocation_endpoint_auth_method: The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param str revocation_token_param_name: Designate token's parameter name for revocation.
        :param Sequence[str] roles_claims: The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] roles_requireds: The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool run_on_preflight: Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
        :param Sequence[str] scopes: The scopes passed to the authorization and token endpoints.
        :param Sequence[str] scopes_claims: The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] scopes_requireds: The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        :param bool search_user_info: Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
        :param float session_absolute_timeout: Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        :param str session_audience: The session audience, which is the intended target application. For example `"my-application"`.
        :param str session_cookie_domain: The session cookie Domain flag.
        :param bool session_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str session_cookie_name: The session cookie name.
        :param str session_cookie_path: The session cookie Path flag.
        :param str session_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool session_cookie_secure: Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param bool session_enforce_same_subject: When set to `true`, audiences are forced to share the same subject.
        :param bool session_hash_storage_key: When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        :param bool session_hash_subject: When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        :param float session_idling_timeout: Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
        :param str session_memcached_host: The memcached host.
        :param int session_memcached_port: The memcached port.
        :param str session_memcached_prefix: The memcached session key prefix.
        :param str session_memcached_socket: The memcached unix socket path.
        :param int session_redis_cluster_max_redirections: The Redis cluster maximum redirects.
        :param Sequence['GetGatewayPluginOpenidConnectConfigSessionRedisClusterNodeArgs'] session_redis_cluster_nodes: The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        :param int session_redis_connect_timeout: Session redis connection timeout in milliseconds.
        :param str session_redis_host: The Redis host.
        :param str session_redis_password: Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
        :param int session_redis_port: The Redis port.
        :param str session_redis_prefix: The Redis session key prefix.
        :param int session_redis_read_timeout: Session redis read timeout in milliseconds.
        :param int session_redis_send_timeout: Session redis send timeout in milliseconds.
        :param str session_redis_server_name: The SNI used for connecting the Redis server.
        :param str session_redis_socket: The Redis unix socket path.
        :param bool session_redis_ssl: Use SSL/TLS for Redis connection.
        :param bool session_redis_ssl_verify: Verify identity provider server certificate.
        :param str session_redis_username: Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        :param bool session_remember: Enables or disables persistent sessions.
        :param float session_remember_absolute_timeout: Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        :param str session_remember_cookie_name: Persistent session cookie name. Use with the `remember` configuration parameter.
        :param float session_remember_rolling_timeout: Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
        :param Sequence[str] session_request_headers: Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
        :param Sequence[str] session_response_headers: Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
        :param float session_rolling_timeout: Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        :param str session_secret: The session secret.
        :param str session_storage: The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        :param bool session_store_metadata: Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
        :param bool ssl_verify: Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `lua_ssl_trusted_certificate`.
        :param float timeout: Network IO timeout in milliseconds.
        :param str tls_client_auth_cert_id: ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
        :param bool tls_client_auth_ssl_verify: Verify identity provider server certificate during mTLS client authentication.
        :param bool token_cache_key_include_scope: Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
        :param str token_endpoint: The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
        :param str token_endpoint_auth_method: The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        :param str token_exchange_endpoint: The token exchange endpoint.
        :param Sequence[str] token_headers_clients: Extra headers passed from the client to the token endpoint.
        :param Sequence[str] token_headers_grants: Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
        :param Sequence[str] token_headers_names: Extra header names passed to the token endpoint.
        :param str token_headers_prefix: Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
        :param Sequence[str] token_headers_replays: The names of token endpoint response headers to forward to the downstream client.
        :param Sequence[str] token_headers_values: Extra header values passed to the token endpoint.
        :param Sequence[str] token_post_args_clients: Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
        :param Sequence[str] token_post_args_names: Extra post argument names passed to the token endpoint.
        :param Sequence[str] token_post_args_values: Extra post argument values passed to the token endpoint.
        :param bool unauthorized_destroy_session: Destroy any active session for the unauthorized requests.
        :param str unauthorized_error_message: The error message for the unauthorized requests (when not using the redirection).
        :param Sequence[str] unauthorized_redirect_uris: Where to redirect the client on unauthorized requests.
        :param Sequence[str] unexpected_redirect_uris: Where to redirect the client when unexpected errors happen with the requests.
        :param str upstream_access_token_header: The upstream access token header.
        :param str upstream_access_token_jwk_header: The upstream access token JWK header.
        :param Sequence[str] upstream_headers_claims: The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        :param Sequence[str] upstream_headers_names: The upstream header names for the claim values.
        :param str upstream_id_token_header: The upstream id token header.
        :param str upstream_id_token_jwk_header: The upstream id token JWK header.
        :param str upstream_introspection_header: The upstream introspection header.
        :param str upstream_introspection_jwt_header: The upstream introspection JWT header.
        :param str upstream_refresh_token_header: The upstream refresh token header.
        :param str upstream_session_id_header: The upstream session id header.
        :param str upstream_user_info_header: The upstream user info header.
        :param str upstream_user_info_jwt_header: The upstream user info JWT header (in case the user info returns a JWT response).
        :param str userinfo_accept: The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
        :param str userinfo_endpoint: The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
        :param Sequence[str] userinfo_headers_clients: Extra headers passed from the client to the user info endpoint.
        :param Sequence[str] userinfo_headers_names: Extra header names passed to the user info endpoint.
        :param Sequence[str] userinfo_headers_values: Extra header values passed to the user info endpoint.
        :param Sequence[str] userinfo_query_args_clients: Extra query arguments passed from the client to the user info endpoint.
        :param Sequence[str] userinfo_query_args_names: Extra query argument names passed to the user info endpoint.
        :param Sequence[str] userinfo_query_args_values: Extra query argument values passed to the user info endpoint.
        :param bool using_pseudo_issuer: If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
        :param bool verify_claims: Verify tokens for standard claims.
        :param bool verify_nonce: Verify nonce on authorization code flow.
        :param bool verify_parameters: Verify plugin configuration against discovery.
        :param bool verify_signature: Verify signature of tokens.
        """
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "audience_claims", audience_claims)
        pulumi.set(__self__, "audience_requireds", audience_requireds)
        pulumi.set(__self__, "audiences", audiences)
        pulumi.set(__self__, "auth_methods", auth_methods)
        pulumi.set(__self__, "authenticated_groups_claims", authenticated_groups_claims)
        pulumi.set(__self__, "authorization_cookie_domain", authorization_cookie_domain)
        pulumi.set(__self__, "authorization_cookie_http_only", authorization_cookie_http_only)
        pulumi.set(__self__, "authorization_cookie_name", authorization_cookie_name)
        pulumi.set(__self__, "authorization_cookie_path", authorization_cookie_path)
        pulumi.set(__self__, "authorization_cookie_same_site", authorization_cookie_same_site)
        pulumi.set(__self__, "authorization_cookie_secure", authorization_cookie_secure)
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "authorization_query_args_clients", authorization_query_args_clients)
        pulumi.set(__self__, "authorization_query_args_names", authorization_query_args_names)
        pulumi.set(__self__, "authorization_query_args_values", authorization_query_args_values)
        pulumi.set(__self__, "authorization_rolling_timeout", authorization_rolling_timeout)
        pulumi.set(__self__, "bearer_token_cookie_name", bearer_token_cookie_name)
        pulumi.set(__self__, "bearer_token_param_types", bearer_token_param_types)
        pulumi.set(__self__, "by_username_ignore_case", by_username_ignore_case)
        pulumi.set(__self__, "cache_introspection", cache_introspection)
        pulumi.set(__self__, "cache_token_exchange", cache_token_exchange)
        pulumi.set(__self__, "cache_tokens", cache_tokens)
        pulumi.set(__self__, "cache_tokens_salt", cache_tokens_salt)
        pulumi.set(__self__, "cache_ttl", cache_ttl)
        pulumi.set(__self__, "cache_ttl_max", cache_ttl_max)
        pulumi.set(__self__, "cache_ttl_min", cache_ttl_min)
        pulumi.set(__self__, "cache_ttl_neg", cache_ttl_neg)
        pulumi.set(__self__, "cache_ttl_resurrect", cache_ttl_resurrect)
        pulumi.set(__self__, "cache_user_info", cache_user_info)
        pulumi.set(__self__, "client_algs", client_algs)
        pulumi.set(__self__, "client_arg", client_arg)
        pulumi.set(__self__, "client_auths", client_auths)
        pulumi.set(__self__, "client_credentials_param_types", client_credentials_param_types)
        pulumi.set(__self__, "client_ids", client_ids)
        pulumi.set(__self__, "client_jwks", client_jwks)
        pulumi.set(__self__, "client_secrets", client_secrets)
        pulumi.set(__self__, "consumer_bies", consumer_bies)
        pulumi.set(__self__, "consumer_claims", consumer_claims)
        pulumi.set(__self__, "consumer_optional", consumer_optional)
        pulumi.set(__self__, "credential_claims", credential_claims)
        pulumi.set(__self__, "disable_sessions", disable_sessions)
        pulumi.set(__self__, "discovery_headers_names", discovery_headers_names)
        pulumi.set(__self__, "discovery_headers_values", discovery_headers_values)
        pulumi.set(__self__, "display_errors", display_errors)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "downstream_access_token_header", downstream_access_token_header)
        pulumi.set(__self__, "downstream_access_token_jwk_header", downstream_access_token_jwk_header)
        pulumi.set(__self__, "downstream_headers_claims", downstream_headers_claims)
        pulumi.set(__self__, "downstream_headers_names", downstream_headers_names)
        pulumi.set(__self__, "downstream_id_token_header", downstream_id_token_header)
        pulumi.set(__self__, "downstream_id_token_jwk_header", downstream_id_token_jwk_header)
        pulumi.set(__self__, "downstream_introspection_header", downstream_introspection_header)
        pulumi.set(__self__, "downstream_introspection_jwt_header", downstream_introspection_jwt_header)
        pulumi.set(__self__, "downstream_refresh_token_header", downstream_refresh_token_header)
        pulumi.set(__self__, "downstream_session_id_header", downstream_session_id_header)
        pulumi.set(__self__, "downstream_user_info_header", downstream_user_info_header)
        pulumi.set(__self__, "downstream_user_info_jwt_header", downstream_user_info_jwt_header)
        pulumi.set(__self__, "dpop_proof_lifetime", dpop_proof_lifetime)
        pulumi.set(__self__, "dpop_use_nonce", dpop_use_nonce)
        pulumi.set(__self__, "enable_hs_signatures", enable_hs_signatures)
        pulumi.set(__self__, "end_session_endpoint", end_session_endpoint)
        pulumi.set(__self__, "expose_error_code", expose_error_code)
        pulumi.set(__self__, "extra_jwks_uris", extra_jwks_uris)
        pulumi.set(__self__, "forbidden_destroy_session", forbidden_destroy_session)
        pulumi.set(__self__, "forbidden_error_message", forbidden_error_message)
        pulumi.set(__self__, "forbidden_redirect_uris", forbidden_redirect_uris)
        pulumi.set(__self__, "groups_claims", groups_claims)
        pulumi.set(__self__, "groups_requireds", groups_requireds)
        pulumi.set(__self__, "hide_credentials", hide_credentials)
        pulumi.set(__self__, "http_proxy", http_proxy)
        pulumi.set(__self__, "http_proxy_authorization", http_proxy_authorization)
        pulumi.set(__self__, "http_version", http_version)
        pulumi.set(__self__, "https_proxy", https_proxy)
        pulumi.set(__self__, "https_proxy_authorization", https_proxy_authorization)
        pulumi.set(__self__, "id_token_param_name", id_token_param_name)
        pulumi.set(__self__, "id_token_param_types", id_token_param_types)
        pulumi.set(__self__, "ignore_signatures", ignore_signatures)
        pulumi.set(__self__, "introspect_jwt_tokens", introspect_jwt_tokens)
        pulumi.set(__self__, "introspection_accept", introspection_accept)
        pulumi.set(__self__, "introspection_check_active", introspection_check_active)
        pulumi.set(__self__, "introspection_endpoint", introspection_endpoint)
        pulumi.set(__self__, "introspection_endpoint_auth_method", introspection_endpoint_auth_method)
        pulumi.set(__self__, "introspection_headers_clients", introspection_headers_clients)
        pulumi.set(__self__, "introspection_headers_names", introspection_headers_names)
        pulumi.set(__self__, "introspection_headers_values", introspection_headers_values)
        pulumi.set(__self__, "introspection_hint", introspection_hint)
        pulumi.set(__self__, "introspection_post_args_clients", introspection_post_args_clients)
        pulumi.set(__self__, "introspection_post_args_names", introspection_post_args_names)
        pulumi.set(__self__, "introspection_post_args_values", introspection_post_args_values)
        pulumi.set(__self__, "introspection_token_param_name", introspection_token_param_name)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "issuers_alloweds", issuers_alloweds)
        pulumi.set(__self__, "jwt_session_claim", jwt_session_claim)
        pulumi.set(__self__, "jwt_session_cookie", jwt_session_cookie)
        pulumi.set(__self__, "keepalive", keepalive)
        pulumi.set(__self__, "leeway", leeway)
        pulumi.set(__self__, "login_action", login_action)
        pulumi.set(__self__, "login_methods", login_methods)
        pulumi.set(__self__, "login_redirect_mode", login_redirect_mode)
        pulumi.set(__self__, "login_redirect_uris", login_redirect_uris)
        pulumi.set(__self__, "login_tokens", login_tokens)
        pulumi.set(__self__, "logout_methods", logout_methods)
        pulumi.set(__self__, "logout_post_arg", logout_post_arg)
        pulumi.set(__self__, "logout_query_arg", logout_query_arg)
        pulumi.set(__self__, "logout_redirect_uris", logout_redirect_uris)
        pulumi.set(__self__, "logout_revoke", logout_revoke)
        pulumi.set(__self__, "logout_revoke_access_token", logout_revoke_access_token)
        pulumi.set(__self__, "logout_revoke_refresh_token", logout_revoke_refresh_token)
        pulumi.set(__self__, "logout_uri_suffix", logout_uri_suffix)
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "mtls_introspection_endpoint", mtls_introspection_endpoint)
        pulumi.set(__self__, "mtls_revocation_endpoint", mtls_revocation_endpoint)
        pulumi.set(__self__, "mtls_token_endpoint", mtls_token_endpoint)
        pulumi.set(__self__, "no_proxy", no_proxy)
        pulumi.set(__self__, "password_param_types", password_param_types)
        pulumi.set(__self__, "preserve_query_args", preserve_query_args)
        pulumi.set(__self__, "proof_of_possession_auth_methods_validation", proof_of_possession_auth_methods_validation)
        pulumi.set(__self__, "proof_of_possession_dpop", proof_of_possession_dpop)
        pulumi.set(__self__, "proof_of_possession_mtls", proof_of_possession_mtls)
        pulumi.set(__self__, "pushed_authorization_request_endpoint", pushed_authorization_request_endpoint)
        pulumi.set(__self__, "pushed_authorization_request_endpoint_auth_method", pushed_authorization_request_endpoint_auth_method)
        pulumi.set(__self__, "redirect_uris", redirect_uris)
        pulumi.set(__self__, "rediscovery_lifetime", rediscovery_lifetime)
        pulumi.set(__self__, "refresh_token_param_name", refresh_token_param_name)
        pulumi.set(__self__, "refresh_token_param_types", refresh_token_param_types)
        pulumi.set(__self__, "refresh_tokens", refresh_tokens)
        pulumi.set(__self__, "require_proof_key_for_code_exchange", require_proof_key_for_code_exchange)
        pulumi.set(__self__, "require_pushed_authorization_requests", require_pushed_authorization_requests)
        pulumi.set(__self__, "require_signed_request_object", require_signed_request_object)
        pulumi.set(__self__, "resolve_distributed_claims", resolve_distributed_claims)
        pulumi.set(__self__, "response_mode", response_mode)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "reverify", reverify)
        pulumi.set(__self__, "revocation_endpoint", revocation_endpoint)
        pulumi.set(__self__, "revocation_endpoint_auth_method", revocation_endpoint_auth_method)
        pulumi.set(__self__, "revocation_token_param_name", revocation_token_param_name)
        pulumi.set(__self__, "roles_claims", roles_claims)
        pulumi.set(__self__, "roles_requireds", roles_requireds)
        pulumi.set(__self__, "run_on_preflight", run_on_preflight)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "scopes_claims", scopes_claims)
        pulumi.set(__self__, "scopes_requireds", scopes_requireds)
        pulumi.set(__self__, "search_user_info", search_user_info)
        pulumi.set(__self__, "session_absolute_timeout", session_absolute_timeout)
        pulumi.set(__self__, "session_audience", session_audience)
        pulumi.set(__self__, "session_cookie_domain", session_cookie_domain)
        pulumi.set(__self__, "session_cookie_http_only", session_cookie_http_only)
        pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        pulumi.set(__self__, "session_cookie_path", session_cookie_path)
        pulumi.set(__self__, "session_cookie_same_site", session_cookie_same_site)
        pulumi.set(__self__, "session_cookie_secure", session_cookie_secure)
        pulumi.set(__self__, "session_enforce_same_subject", session_enforce_same_subject)
        pulumi.set(__self__, "session_hash_storage_key", session_hash_storage_key)
        pulumi.set(__self__, "session_hash_subject", session_hash_subject)
        pulumi.set(__self__, "session_idling_timeout", session_idling_timeout)
        pulumi.set(__self__, "session_memcached_host", session_memcached_host)
        pulumi.set(__self__, "session_memcached_port", session_memcached_port)
        pulumi.set(__self__, "session_memcached_prefix", session_memcached_prefix)
        pulumi.set(__self__, "session_memcached_socket", session_memcached_socket)
        pulumi.set(__self__, "session_redis_cluster_max_redirections", session_redis_cluster_max_redirections)
        pulumi.set(__self__, "session_redis_cluster_nodes", session_redis_cluster_nodes)
        pulumi.set(__self__, "session_redis_connect_timeout", session_redis_connect_timeout)
        pulumi.set(__self__, "session_redis_host", session_redis_host)
        pulumi.set(__self__, "session_redis_password", session_redis_password)
        pulumi.set(__self__, "session_redis_port", session_redis_port)
        pulumi.set(__self__, "session_redis_prefix", session_redis_prefix)
        pulumi.set(__self__, "session_redis_read_timeout", session_redis_read_timeout)
        pulumi.set(__self__, "session_redis_send_timeout", session_redis_send_timeout)
        pulumi.set(__self__, "session_redis_server_name", session_redis_server_name)
        pulumi.set(__self__, "session_redis_socket", session_redis_socket)
        pulumi.set(__self__, "session_redis_ssl", session_redis_ssl)
        pulumi.set(__self__, "session_redis_ssl_verify", session_redis_ssl_verify)
        pulumi.set(__self__, "session_redis_username", session_redis_username)
        pulumi.set(__self__, "session_remember", session_remember)
        pulumi.set(__self__, "session_remember_absolute_timeout", session_remember_absolute_timeout)
        pulumi.set(__self__, "session_remember_cookie_name", session_remember_cookie_name)
        pulumi.set(__self__, "session_remember_rolling_timeout", session_remember_rolling_timeout)
        pulumi.set(__self__, "session_request_headers", session_request_headers)
        pulumi.set(__self__, "session_response_headers", session_response_headers)
        pulumi.set(__self__, "session_rolling_timeout", session_rolling_timeout)
        pulumi.set(__self__, "session_secret", session_secret)
        pulumi.set(__self__, "session_storage", session_storage)
        pulumi.set(__self__, "session_store_metadata", session_store_metadata)
        pulumi.set(__self__, "ssl_verify", ssl_verify)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_client_auth_cert_id", tls_client_auth_cert_id)
        pulumi.set(__self__, "tls_client_auth_ssl_verify", tls_client_auth_ssl_verify)
        pulumi.set(__self__, "token_cache_key_include_scope", token_cache_key_include_scope)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "token_endpoint_auth_method", token_endpoint_auth_method)
        pulumi.set(__self__, "token_exchange_endpoint", token_exchange_endpoint)
        pulumi.set(__self__, "token_headers_clients", token_headers_clients)
        pulumi.set(__self__, "token_headers_grants", token_headers_grants)
        pulumi.set(__self__, "token_headers_names", token_headers_names)
        pulumi.set(__self__, "token_headers_prefix", token_headers_prefix)
        pulumi.set(__self__, "token_headers_replays", token_headers_replays)
        pulumi.set(__self__, "token_headers_values", token_headers_values)
        pulumi.set(__self__, "token_post_args_clients", token_post_args_clients)
        pulumi.set(__self__, "token_post_args_names", token_post_args_names)
        pulumi.set(__self__, "token_post_args_values", token_post_args_values)
        pulumi.set(__self__, "unauthorized_destroy_session", unauthorized_destroy_session)
        pulumi.set(__self__, "unauthorized_error_message", unauthorized_error_message)
        pulumi.set(__self__, "unauthorized_redirect_uris", unauthorized_redirect_uris)
        pulumi.set(__self__, "unexpected_redirect_uris", unexpected_redirect_uris)
        pulumi.set(__self__, "upstream_access_token_header", upstream_access_token_header)
        pulumi.set(__self__, "upstream_access_token_jwk_header", upstream_access_token_jwk_header)
        pulumi.set(__self__, "upstream_headers_claims", upstream_headers_claims)
        pulumi.set(__self__, "upstream_headers_names", upstream_headers_names)
        pulumi.set(__self__, "upstream_id_token_header", upstream_id_token_header)
        pulumi.set(__self__, "upstream_id_token_jwk_header", upstream_id_token_jwk_header)
        pulumi.set(__self__, "upstream_introspection_header", upstream_introspection_header)
        pulumi.set(__self__, "upstream_introspection_jwt_header", upstream_introspection_jwt_header)
        pulumi.set(__self__, "upstream_refresh_token_header", upstream_refresh_token_header)
        pulumi.set(__self__, "upstream_session_id_header", upstream_session_id_header)
        pulumi.set(__self__, "upstream_user_info_header", upstream_user_info_header)
        pulumi.set(__self__, "upstream_user_info_jwt_header", upstream_user_info_jwt_header)
        pulumi.set(__self__, "userinfo_accept", userinfo_accept)
        pulumi.set(__self__, "userinfo_endpoint", userinfo_endpoint)
        pulumi.set(__self__, "userinfo_headers_clients", userinfo_headers_clients)
        pulumi.set(__self__, "userinfo_headers_names", userinfo_headers_names)
        pulumi.set(__self__, "userinfo_headers_values", userinfo_headers_values)
        pulumi.set(__self__, "userinfo_query_args_clients", userinfo_query_args_clients)
        pulumi.set(__self__, "userinfo_query_args_names", userinfo_query_args_names)
        pulumi.set(__self__, "userinfo_query_args_values", userinfo_query_args_values)
        pulumi.set(__self__, "using_pseudo_issuer", using_pseudo_issuer)
        pulumi.set(__self__, "verify_claims", verify_claims)
        pulumi.set(__self__, "verify_nonce", verify_nonce)
        pulumi.set(__self__, "verify_parameters", verify_parameters)
        pulumi.set(__self__, "verify_signature", verify_signature)

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="audienceClaims")
    def audience_claims(self) -> Sequence[str]:
        """
        The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "audience_claims")

    @property
    @pulumi.getter(name="audienceRequireds")
    def audience_requireds(self) -> Sequence[str]:
        """
        The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "audience_requireds")

    @property
    @pulumi.getter
    def audiences(self) -> Sequence[str]:
        """
        The audience passed to the authorization endpoint.
        """
        return pulumi.get(self, "audiences")

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Sequence[str]:
        """
        Types of credentials/grants to enable.
        """
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="authenticatedGroupsClaims")
    def authenticated_groups_claims(self) -> Sequence[str]:
        """
        The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "authenticated_groups_claims")

    @property
    @pulumi.getter(name="authorizationCookieDomain")
    def authorization_cookie_domain(self) -> str:
        """
        The authorization cookie Domain flag.
        """
        return pulumi.get(self, "authorization_cookie_domain")

    @property
    @pulumi.getter(name="authorizationCookieHttpOnly")
    def authorization_cookie_http_only(self) -> bool:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "authorization_cookie_http_only")

    @property
    @pulumi.getter(name="authorizationCookieName")
    def authorization_cookie_name(self) -> str:
        """
        The authorization cookie name.
        """
        return pulumi.get(self, "authorization_cookie_name")

    @property
    @pulumi.getter(name="authorizationCookiePath")
    def authorization_cookie_path(self) -> str:
        """
        The authorization cookie Path flag.
        """
        return pulumi.get(self, "authorization_cookie_path")

    @property
    @pulumi.getter(name="authorizationCookieSameSite")
    def authorization_cookie_same_site(self) -> str:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "authorization_cookie_same_site")

    @property
    @pulumi.getter(name="authorizationCookieSecure")
    def authorization_cookie_secure(self) -> bool:
        """
        Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "authorization_cookie_secure")

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> str:
        """
        The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="authorizationQueryArgsClients")
    def authorization_query_args_clients(self) -> Sequence[str]:
        """
        Extra query arguments passed from the client to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_clients")

    @property
    @pulumi.getter(name="authorizationQueryArgsNames")
    def authorization_query_args_names(self) -> Sequence[str]:
        """
        Extra query argument names passed to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_names")

    @property
    @pulumi.getter(name="authorizationQueryArgsValues")
    def authorization_query_args_values(self) -> Sequence[str]:
        """
        Extra query argument values passed to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_query_args_values")

    @property
    @pulumi.getter(name="authorizationRollingTimeout")
    def authorization_rolling_timeout(self) -> float:
        """
        Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "authorization_rolling_timeout")

    @property
    @pulumi.getter(name="bearerTokenCookieName")
    def bearer_token_cookie_name(self) -> str:
        """
        The name of the cookie in which the bearer token is passed.
        """
        return pulumi.get(self, "bearer_token_cookie_name")

    @property
    @pulumi.getter(name="bearerTokenParamTypes")
    def bearer_token_param_types(self) -> Sequence[str]:
        """
        Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
        """
        return pulumi.get(self, "bearer_token_param_types")

    @property
    @pulumi.getter(name="byUsernameIgnoreCase")
    def by_username_ignore_case(self) -> bool:
        """
        If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
        """
        return pulumi.get(self, "by_username_ignore_case")

    @property
    @pulumi.getter(name="cacheIntrospection")
    def cache_introspection(self) -> bool:
        """
        Cache the introspection endpoint requests.
        """
        return pulumi.get(self, "cache_introspection")

    @property
    @pulumi.getter(name="cacheTokenExchange")
    def cache_token_exchange(self) -> bool:
        """
        Cache the token exchange endpoint requests.
        """
        return pulumi.get(self, "cache_token_exchange")

    @property
    @pulumi.getter(name="cacheTokens")
    def cache_tokens(self) -> bool:
        """
        Cache the token endpoint requests.
        """
        return pulumi.get(self, "cache_tokens")

    @property
    @pulumi.getter(name="cacheTokensSalt")
    def cache_tokens_salt(self) -> str:
        """
        Salt used for generating the cache key that is used for caching the token endpoint requests.
        """
        return pulumi.get(self, "cache_tokens_salt")

    @property
    @pulumi.getter(name="cacheTtl")
    def cache_ttl(self) -> float:
        """
        The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
        """
        return pulumi.get(self, "cache_ttl")

    @property
    @pulumi.getter(name="cacheTtlMax")
    def cache_ttl_max(self) -> float:
        """
        The maximum cache ttl in seconds (enforced).
        """
        return pulumi.get(self, "cache_ttl_max")

    @property
    @pulumi.getter(name="cacheTtlMin")
    def cache_ttl_min(self) -> float:
        """
        The minimum cache ttl in seconds (enforced).
        """
        return pulumi.get(self, "cache_ttl_min")

    @property
    @pulumi.getter(name="cacheTtlNeg")
    def cache_ttl_neg(self) -> float:
        """
        The negative cache ttl in seconds.
        """
        return pulumi.get(self, "cache_ttl_neg")

    @property
    @pulumi.getter(name="cacheTtlResurrect")
    def cache_ttl_resurrect(self) -> float:
        """
        The resurrection ttl in seconds.
        """
        return pulumi.get(self, "cache_ttl_resurrect")

    @property
    @pulumi.getter(name="cacheUserInfo")
    def cache_user_info(self) -> bool:
        """
        Cache the user info requests.
        """
        return pulumi.get(self, "cache_user_info")

    @property
    @pulumi.getter(name="clientAlgs")
    def client_algs(self) -> Sequence[str]:
        """
        The algorithm to use for client_secret_jwt (only HS***) or private_key_jwt authentication.
        """
        return pulumi.get(self, "client_algs")

    @property
    @pulumi.getter(name="clientArg")
    def client_arg(self) -> str:
        """
        The client to use for this request (the selection is made with a request parameter with the same name).
        """
        return pulumi.get(self, "client_arg")

    @property
    @pulumi.getter(name="clientAuths")
    def client_auths(self) -> Sequence[str]:
        """
        The default OpenID Connect client authentication method is 'client_secret_basic' (using 'Authorization: Basic' header), 'client_secret_post' (credentials in body), 'client_secret_jwt' (signed client assertion in body), 'private_key_jwt' (private key-signed assertion), 'tls_client_auth' (client certificate), 'self_signed_tls_client_auth' (self-signed client certificate), and 'none' (no authentication).
        """
        return pulumi.get(self, "client_auths")

    @property
    @pulumi.getter(name="clientCredentialsParamTypes")
    def client_credentials_param_types(self) -> Sequence[str]:
        """
        Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
        """
        return pulumi.get(self, "client_credentials_param_types")

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Sequence[str]:
        """
        The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
        """
        return pulumi.get(self, "client_ids")

    @property
    @pulumi.getter(name="clientJwks")
    def client_jwks(self) -> Sequence['outputs.GetGatewayPluginOpenidConnectConfigClientJwkResult']:
        """
        The JWK used for the private_key_jwt authentication.
        """
        return pulumi.get(self, "client_jwks")

    @property
    @pulumi.getter(name="clientSecrets")
    def client_secrets(self) -> Sequence[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secrets")

    @property
    @pulumi.getter(name="consumerBies")
    def consumer_bies(self) -> Sequence[str]:
        """
        Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
        """
        return pulumi.get(self, "consumer_bies")

    @property
    @pulumi.getter(name="consumerClaims")
    def consumer_claims(self) -> Sequence[str]:
        """
        The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "consumer_claims")

    @property
    @pulumi.getter(name="consumerOptional")
    def consumer_optional(self) -> bool:
        """
        Do not terminate the request if consumer mapping fails.
        """
        return pulumi.get(self, "consumer_optional")

    @property
    @pulumi.getter(name="credentialClaims")
    def credential_claims(self) -> Sequence[str]:
        """
        The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "credential_claims")

    @property
    @pulumi.getter(name="disableSessions")
    def disable_sessions(self) -> Sequence[str]:
        """
        Disable issuing the session cookie with the specified grants.
        """
        return pulumi.get(self, "disable_sessions")

    @property
    @pulumi.getter(name="discoveryHeadersNames")
    def discovery_headers_names(self) -> Sequence[str]:
        """
        Extra header names passed to the discovery endpoint.
        """
        return pulumi.get(self, "discovery_headers_names")

    @property
    @pulumi.getter(name="discoveryHeadersValues")
    def discovery_headers_values(self) -> Sequence[str]:
        """
        Extra header values passed to the discovery endpoint.
        """
        return pulumi.get(self, "discovery_headers_values")

    @property
    @pulumi.getter(name="displayErrors")
    def display_errors(self) -> bool:
        """
        Display errors on failure responses.
        """
        return pulumi.get(self, "display_errors")

    @property
    @pulumi.getter
    def domains(self) -> Sequence[str]:
        """
        The allowed values for the `hd` claim.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="downstreamAccessTokenHeader")
    def downstream_access_token_header(self) -> str:
        """
        The downstream access token header.
        """
        return pulumi.get(self, "downstream_access_token_header")

    @property
    @pulumi.getter(name="downstreamAccessTokenJwkHeader")
    def downstream_access_token_jwk_header(self) -> str:
        """
        The downstream access token JWK header.
        """
        return pulumi.get(self, "downstream_access_token_jwk_header")

    @property
    @pulumi.getter(name="downstreamHeadersClaims")
    def downstream_headers_claims(self) -> Sequence[str]:
        """
        The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "downstream_headers_claims")

    @property
    @pulumi.getter(name="downstreamHeadersNames")
    def downstream_headers_names(self) -> Sequence[str]:
        """
        The downstream header names for the claim values.
        """
        return pulumi.get(self, "downstream_headers_names")

    @property
    @pulumi.getter(name="downstreamIdTokenHeader")
    def downstream_id_token_header(self) -> str:
        """
        The downstream id token header.
        """
        return pulumi.get(self, "downstream_id_token_header")

    @property
    @pulumi.getter(name="downstreamIdTokenJwkHeader")
    def downstream_id_token_jwk_header(self) -> str:
        """
        The downstream id token JWK header.
        """
        return pulumi.get(self, "downstream_id_token_jwk_header")

    @property
    @pulumi.getter(name="downstreamIntrospectionHeader")
    def downstream_introspection_header(self) -> str:
        """
        The downstream introspection header.
        """
        return pulumi.get(self, "downstream_introspection_header")

    @property
    @pulumi.getter(name="downstreamIntrospectionJwtHeader")
    def downstream_introspection_jwt_header(self) -> str:
        """
        The downstream introspection JWT header.
        """
        return pulumi.get(self, "downstream_introspection_jwt_header")

    @property
    @pulumi.getter(name="downstreamRefreshTokenHeader")
    def downstream_refresh_token_header(self) -> str:
        """
        The downstream refresh token header.
        """
        return pulumi.get(self, "downstream_refresh_token_header")

    @property
    @pulumi.getter(name="downstreamSessionIdHeader")
    def downstream_session_id_header(self) -> str:
        """
        The downstream session id header.
        """
        return pulumi.get(self, "downstream_session_id_header")

    @property
    @pulumi.getter(name="downstreamUserInfoHeader")
    def downstream_user_info_header(self) -> str:
        """
        The downstream user info header.
        """
        return pulumi.get(self, "downstream_user_info_header")

    @property
    @pulumi.getter(name="downstreamUserInfoJwtHeader")
    def downstream_user_info_jwt_header(self) -> str:
        """
        The downstream user info JWT header (in case the user info returns a JWT response).
        """
        return pulumi.get(self, "downstream_user_info_jwt_header")

    @property
    @pulumi.getter(name="dpopProofLifetime")
    def dpop_proof_lifetime(self) -> float:
        """
        Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
        """
        return pulumi.get(self, "dpop_proof_lifetime")

    @property
    @pulumi.getter(name="dpopUseNonce")
    def dpop_use_nonce(self) -> bool:
        """
        Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
        """
        return pulumi.get(self, "dpop_use_nonce")

    @property
    @pulumi.getter(name="enableHsSignatures")
    def enable_hs_signatures(self) -> bool:
        """
        Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
        """
        return pulumi.get(self, "enable_hs_signatures")

    @property
    @pulumi.getter(name="endSessionEndpoint")
    def end_session_endpoint(self) -> str:
        """
        The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "end_session_endpoint")

    @property
    @pulumi.getter(name="exposeErrorCode")
    def expose_error_code(self) -> bool:
        """
        Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
        """
        return pulumi.get(self, "expose_error_code")

    @property
    @pulumi.getter(name="extraJwksUris")
    def extra_jwks_uris(self) -> Sequence[str]:
        """
        JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
        """
        return pulumi.get(self, "extra_jwks_uris")

    @property
    @pulumi.getter(name="forbiddenDestroySession")
    def forbidden_destroy_session(self) -> bool:
        """
        Destroy any active session for the forbidden requests.
        """
        return pulumi.get(self, "forbidden_destroy_session")

    @property
    @pulumi.getter(name="forbiddenErrorMessage")
    def forbidden_error_message(self) -> str:
        """
        The error message for the forbidden requests (when not using the redirection).
        """
        return pulumi.get(self, "forbidden_error_message")

    @property
    @pulumi.getter(name="forbiddenRedirectUris")
    def forbidden_redirect_uris(self) -> Sequence[str]:
        """
        Where to redirect the client on forbidden requests.
        """
        return pulumi.get(self, "forbidden_redirect_uris")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Sequence[str]:
        """
        The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsRequireds")
    def groups_requireds(self) -> Sequence[str]:
        """
        The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "groups_requireds")

    @property
    @pulumi.getter(name="hideCredentials")
    def hide_credentials(self) -> bool:
        """
        Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
        """
        return pulumi.get(self, "hide_credentials")

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> str:
        """
        The HTTP proxy.
        """
        return pulumi.get(self, "http_proxy")

    @property
    @pulumi.getter(name="httpProxyAuthorization")
    def http_proxy_authorization(self) -> str:
        """
        The HTTP proxy authorization.
        """
        return pulumi.get(self, "http_proxy_authorization")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> float:
        """
        The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> str:
        """
        The HTTPS proxy.
        """
        return pulumi.get(self, "https_proxy")

    @property
    @pulumi.getter(name="httpsProxyAuthorization")
    def https_proxy_authorization(self) -> str:
        """
        The HTTPS proxy authorization.
        """
        return pulumi.get(self, "https_proxy_authorization")

    @property
    @pulumi.getter(name="idTokenParamName")
    def id_token_param_name(self) -> str:
        """
        The name of the parameter used to pass the id token.
        """
        return pulumi.get(self, "id_token_param_name")

    @property
    @pulumi.getter(name="idTokenParamTypes")
    def id_token_param_types(self) -> Sequence[str]:
        """
        Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "id_token_param_types")

    @property
    @pulumi.getter(name="ignoreSignatures")
    def ignore_signatures(self) -> Sequence[str]:
        """
        Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
        """
        return pulumi.get(self, "ignore_signatures")

    @property
    @pulumi.getter(name="introspectJwtTokens")
    def introspect_jwt_tokens(self) -> bool:
        """
        Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
        """
        return pulumi.get(self, "introspect_jwt_tokens")

    @property
    @pulumi.getter(name="introspectionAccept")
    def introspection_accept(self) -> str:
        """
        The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
        """
        return pulumi.get(self, "introspection_accept")

    @property
    @pulumi.getter(name="introspectionCheckActive")
    def introspection_check_active(self) -> bool:
        """
        Check that the introspection response has an `active` claim with a value of `true`.
        """
        return pulumi.get(self, "introspection_check_active")

    @property
    @pulumi.getter(name="introspectionEndpoint")
    def introspection_endpoint(self) -> str:
        """
        The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "introspection_endpoint")

    @property
    @pulumi.getter(name="introspectionEndpointAuthMethod")
    def introspection_endpoint_auth_method(self) -> str:
        """
        The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "introspection_endpoint_auth_method")

    @property
    @pulumi.getter(name="introspectionHeadersClients")
    def introspection_headers_clients(self) -> Sequence[str]:
        """
        Extra headers passed from the client to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_clients")

    @property
    @pulumi.getter(name="introspectionHeadersNames")
    def introspection_headers_names(self) -> Sequence[str]:
        """
        Extra header names passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_names")

    @property
    @pulumi.getter(name="introspectionHeadersValues")
    def introspection_headers_values(self) -> Sequence[str]:
        """
        Extra header values passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_headers_values")

    @property
    @pulumi.getter(name="introspectionHint")
    def introspection_hint(self) -> str:
        """
        Introspection hint parameter value passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_hint")

    @property
    @pulumi.getter(name="introspectionPostArgsClients")
    def introspection_post_args_clients(self) -> Sequence[str]:
        """
        Extra post arguments passed from the client to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_clients")

    @property
    @pulumi.getter(name="introspectionPostArgsNames")
    def introspection_post_args_names(self) -> Sequence[str]:
        """
        Extra post argument names passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_names")

    @property
    @pulumi.getter(name="introspectionPostArgsValues")
    def introspection_post_args_values(self) -> Sequence[str]:
        """
        Extra post argument values passed to the introspection endpoint.
        """
        return pulumi.get(self, "introspection_post_args_values")

    @property
    @pulumi.getter(name="introspectionTokenParamName")
    def introspection_token_param_name(self) -> str:
        """
        Designate token's parameter name for introspection.
        """
        return pulumi.get(self, "introspection_token_param_name")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="issuersAlloweds")
    def issuers_alloweds(self) -> Sequence[str]:
        """
        The issuers allowed to be present in the tokens (`iss` claim).
        """
        return pulumi.get(self, "issuers_alloweds")

    @property
    @pulumi.getter(name="jwtSessionClaim")
    def jwt_session_claim(self) -> str:
        """
        The claim to match against the JWT session cookie.
        """
        return pulumi.get(self, "jwt_session_claim")

    @property
    @pulumi.getter(name="jwtSessionCookie")
    def jwt_session_cookie(self) -> str:
        """
        The name of the JWT session cookie.
        """
        return pulumi.get(self, "jwt_session_cookie")

    @property
    @pulumi.getter
    def keepalive(self) -> bool:
        """
        Use keepalive with the HTTP client.
        """
        return pulumi.get(self, "keepalive")

    @property
    @pulumi.getter
    def leeway(self) -> float:
        """
        Defines leeway time (in seconds) for `auth_time`, `exp`, `iat`, and `nbf` claims
        """
        return pulumi.get(self, "leeway")

    @property
    @pulumi.getter(name="loginAction")
    def login_action(self) -> str:
        """
        What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
        """
        return pulumi.get(self, "login_action")

    @property
    @pulumi.getter(name="loginMethods")
    def login_methods(self) -> Sequence[str]:
        """
        Enable login functionality with specified grants.
        """
        return pulumi.get(self, "login_methods")

    @property
    @pulumi.getter(name="loginRedirectMode")
    def login_redirect_mode(self) -> str:
        """
        Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
        """
        return pulumi.get(self, "login_redirect_mode")

    @property
    @pulumi.getter(name="loginRedirectUris")
    def login_redirect_uris(self) -> Sequence[str]:
        """
        Where to redirect the client when `login_action` is set to `redirect`.
        """
        return pulumi.get(self, "login_redirect_uris")

    @property
    @pulumi.getter(name="loginTokens")
    def login_tokens(self) -> Sequence[str]:
        """
        What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
        """
        return pulumi.get(self, "login_tokens")

    @property
    @pulumi.getter(name="logoutMethods")
    def logout_methods(self) -> Sequence[str]:
        """
        The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
        """
        return pulumi.get(self, "logout_methods")

    @property
    @pulumi.getter(name="logoutPostArg")
    def logout_post_arg(self) -> str:
        """
        The request body argument that activates the logout.
        """
        return pulumi.get(self, "logout_post_arg")

    @property
    @pulumi.getter(name="logoutQueryArg")
    def logout_query_arg(self) -> str:
        """
        The request query argument that activates the logout.
        """
        return pulumi.get(self, "logout_query_arg")

    @property
    @pulumi.getter(name="logoutRedirectUris")
    def logout_redirect_uris(self) -> Sequence[str]:
        """
        Where to redirect the client after the logout.
        """
        return pulumi.get(self, "logout_redirect_uris")

    @property
    @pulumi.getter(name="logoutRevoke")
    def logout_revoke(self) -> bool:
        """
        Revoke tokens as part of the logout.

        For more granular token revocation, you can also adjust the `logout_revoke_access_token` and `logout_revoke_refresh_token` parameters.
        """
        return pulumi.get(self, "logout_revoke")

    @property
    @pulumi.getter(name="logoutRevokeAccessToken")
    def logout_revoke_access_token(self) -> bool:
        """
        Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
        """
        return pulumi.get(self, "logout_revoke_access_token")

    @property
    @pulumi.getter(name="logoutRevokeRefreshToken")
    def logout_revoke_refresh_token(self) -> bool:
        """
        Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
        """
        return pulumi.get(self, "logout_revoke_refresh_token")

    @property
    @pulumi.getter(name="logoutUriSuffix")
    def logout_uri_suffix(self) -> str:
        """
        The request URI suffix that activates the logout.
        """
        return pulumi.get(self, "logout_uri_suffix")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> float:
        """
        The maximum age (in seconds) compared to the `auth_time` claim.
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="mtlsIntrospectionEndpoint")
    def mtls_introspection_endpoint(self) -> str:
        """
        Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_introspection_endpoint")

    @property
    @pulumi.getter(name="mtlsRevocationEndpoint")
    def mtls_revocation_endpoint(self) -> str:
        """
        Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_revocation_endpoint")

    @property
    @pulumi.getter(name="mtlsTokenEndpoint")
    def mtls_token_endpoint(self) -> str:
        """
        Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        """
        return pulumi.get(self, "mtls_token_endpoint")

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> str:
        """
        Do not use proxy with these hosts.
        """
        return pulumi.get(self, "no_proxy")

    @property
    @pulumi.getter(name="passwordParamTypes")
    def password_param_types(self) -> Sequence[str]:
        """
        Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "password_param_types")

    @property
    @pulumi.getter(name="preserveQueryArgs")
    def preserve_query_args(self) -> bool:
        """
        With this parameter, you can preserve request query arguments even when doing authorization code flow.
        """
        return pulumi.get(self, "preserve_query_args")

    @property
    @pulumi.getter(name="proofOfPossessionAuthMethodsValidation")
    def proof_of_possession_auth_methods_validation(self) -> bool:
        """
        If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
        """
        return pulumi.get(self, "proof_of_possession_auth_methods_validation")

    @property
    @pulumi.getter(name="proofOfPossessionDpop")
    def proof_of_possession_dpop(self) -> str:
        """
        Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
        """
        return pulumi.get(self, "proof_of_possession_dpop")

    @property
    @pulumi.getter(name="proofOfPossessionMtls")
    def proof_of_possession_mtls(self) -> str:
        """
        Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
        """
        return pulumi.get(self, "proof_of_possession_mtls")

    @property
    @pulumi.getter(name="pushedAuthorizationRequestEndpoint")
    def pushed_authorization_request_endpoint(self) -> str:
        """
        The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "pushed_authorization_request_endpoint")

    @property
    @pulumi.getter(name="pushedAuthorizationRequestEndpointAuthMethod")
    def pushed_authorization_request_endpoint_auth_method(self) -> str:
        """
        The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "pushed_authorization_request_endpoint_auth_method")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Sequence[str]:
        """
        The redirect URI passed to the authorization and token endpoints.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="rediscoveryLifetime")
    def rediscovery_lifetime(self) -> float:
        """
        Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
        """
        return pulumi.get(self, "rediscovery_lifetime")

    @property
    @pulumi.getter(name="refreshTokenParamName")
    def refresh_token_param_name(self) -> str:
        """
        The name of the parameter used to pass the refresh token.
        """
        return pulumi.get(self, "refresh_token_param_name")

    @property
    @pulumi.getter(name="refreshTokenParamTypes")
    def refresh_token_param_types(self) -> Sequence[str]:
        """
        Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        """
        return pulumi.get(self, "refresh_token_param_types")

    @property
    @pulumi.getter(name="refreshTokens")
    def refresh_tokens(self) -> bool:
        """
        Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
        """
        return pulumi.get(self, "refresh_tokens")

    @property
    @pulumi.getter(name="requireProofKeyForCodeExchange")
    def require_proof_key_for_code_exchange(self) -> bool:
        """
        Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
        """
        return pulumi.get(self, "require_proof_key_for_code_exchange")

    @property
    @pulumi.getter(name="requirePushedAuthorizationRequests")
    def require_pushed_authorization_requests(self) -> bool:
        """
        Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
        """
        return pulumi.get(self, "require_pushed_authorization_requests")

    @property
    @pulumi.getter(name="requireSignedRequestObject")
    def require_signed_request_object(self) -> bool:
        """
        Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `require_signed_request_object`, and enabled automatically (in case the `require_signed_request_object` is missing, the feature will not be enabled).
        """
        return pulumi.get(self, "require_signed_request_object")

    @property
    @pulumi.getter(name="resolveDistributedClaims")
    def resolve_distributed_claims(self) -> bool:
        """
        Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
        """
        return pulumi.get(self, "resolve_distributed_claims")

    @property
    @pulumi.getter(name="responseMode")
    def response_mode(self) -> str:
        """
        Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `form_post`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `form_post` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "form_post", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
        """
        return pulumi.get(self, "response_mode")

    @property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> Sequence[str]:
        """
        The response type passed to the authorization endpoint.
        """
        return pulumi.get(self, "response_types")

    @property
    @pulumi.getter
    def reverify(self) -> bool:
        """
        Specifies whether to always verify tokens stored in the session.
        """
        return pulumi.get(self, "reverify")

    @property
    @pulumi.getter(name="revocationEndpoint")
    def revocation_endpoint(self) -> str:
        """
        The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "revocation_endpoint")

    @property
    @pulumi.getter(name="revocationEndpointAuthMethod")
    def revocation_endpoint_auth_method(self) -> str:
        """
        The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "revocation_endpoint_auth_method")

    @property
    @pulumi.getter(name="revocationTokenParamName")
    def revocation_token_param_name(self) -> str:
        """
        Designate token's parameter name for revocation.
        """
        return pulumi.get(self, "revocation_token_param_name")

    @property
    @pulumi.getter(name="rolesClaims")
    def roles_claims(self) -> Sequence[str]:
        """
        The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "roles_claims")

    @property
    @pulumi.getter(name="rolesRequireds")
    def roles_requireds(self) -> Sequence[str]:
        """
        The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "roles_requireds")

    @property
    @pulumi.getter(name="runOnPreflight")
    def run_on_preflight(self) -> bool:
        """
        Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
        """
        return pulumi.get(self, "run_on_preflight")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The scopes passed to the authorization and token endpoints.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="scopesClaims")
    def scopes_claims(self) -> Sequence[str]:
        """
        The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "scopes_claims")

    @property
    @pulumi.getter(name="scopesRequireds")
    def scopes_requireds(self) -> Sequence[str]:
        """
        The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        """
        return pulumi.get(self, "scopes_requireds")

    @property
    @pulumi.getter(name="searchUserInfo")
    def search_user_info(self) -> bool:
        """
        Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
        """
        return pulumi.get(self, "search_user_info")

    @property
    @pulumi.getter(name="sessionAbsoluteTimeout")
    def session_absolute_timeout(self) -> float:
        """
        Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        """
        return pulumi.get(self, "session_absolute_timeout")

    @property
    @pulumi.getter(name="sessionAudience")
    def session_audience(self) -> str:
        """
        The session audience, which is the intended target application. For example `"my-application"`.
        """
        return pulumi.get(self, "session_audience")

    @property
    @pulumi.getter(name="sessionCookieDomain")
    def session_cookie_domain(self) -> str:
        """
        The session cookie Domain flag.
        """
        return pulumi.get(self, "session_cookie_domain")

    @property
    @pulumi.getter(name="sessionCookieHttpOnly")
    def session_cookie_http_only(self) -> bool:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "session_cookie_http_only")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> str:
        """
        The session cookie name.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionCookiePath")
    def session_cookie_path(self) -> str:
        """
        The session cookie Path flag.
        """
        return pulumi.get(self, "session_cookie_path")

    @property
    @pulumi.getter(name="sessionCookieSameSite")
    def session_cookie_same_site(self) -> str:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "session_cookie_same_site")

    @property
    @pulumi.getter(name="sessionCookieSecure")
    def session_cookie_secure(self) -> bool:
        """
        Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "session_cookie_secure")

    @property
    @pulumi.getter(name="sessionEnforceSameSubject")
    def session_enforce_same_subject(self) -> bool:
        """
        When set to `true`, audiences are forced to share the same subject.
        """
        return pulumi.get(self, "session_enforce_same_subject")

    @property
    @pulumi.getter(name="sessionHashStorageKey")
    def session_hash_storage_key(self) -> bool:
        """
        When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        """
        return pulumi.get(self, "session_hash_storage_key")

    @property
    @pulumi.getter(name="sessionHashSubject")
    def session_hash_subject(self) -> bool:
        """
        When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        """
        return pulumi.get(self, "session_hash_subject")

    @property
    @pulumi.getter(name="sessionIdlingTimeout")
    def session_idling_timeout(self) -> float:
        """
        Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
        """
        return pulumi.get(self, "session_idling_timeout")

    @property
    @pulumi.getter(name="sessionMemcachedHost")
    def session_memcached_host(self) -> str:
        """
        The memcached host.
        """
        return pulumi.get(self, "session_memcached_host")

    @property
    @pulumi.getter(name="sessionMemcachedPort")
    def session_memcached_port(self) -> int:
        """
        The memcached port.
        """
        return pulumi.get(self, "session_memcached_port")

    @property
    @pulumi.getter(name="sessionMemcachedPrefix")
    def session_memcached_prefix(self) -> str:
        """
        The memcached session key prefix.
        """
        return pulumi.get(self, "session_memcached_prefix")

    @property
    @pulumi.getter(name="sessionMemcachedSocket")
    def session_memcached_socket(self) -> str:
        """
        The memcached unix socket path.
        """
        return pulumi.get(self, "session_memcached_socket")

    @property
    @pulumi.getter(name="sessionRedisClusterMaxRedirections")
    def session_redis_cluster_max_redirections(self) -> int:
        """
        The Redis cluster maximum redirects.
        """
        return pulumi.get(self, "session_redis_cluster_max_redirections")

    @property
    @pulumi.getter(name="sessionRedisClusterNodes")
    def session_redis_cluster_nodes(self) -> Sequence['outputs.GetGatewayPluginOpenidConnectConfigSessionRedisClusterNodeResult']:
        """
        The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        """
        return pulumi.get(self, "session_redis_cluster_nodes")

    @property
    @pulumi.getter(name="sessionRedisConnectTimeout")
    def session_redis_connect_timeout(self) -> int:
        """
        Session redis connection timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_connect_timeout")

    @property
    @pulumi.getter(name="sessionRedisHost")
    def session_redis_host(self) -> str:
        """
        The Redis host.
        """
        return pulumi.get(self, "session_redis_host")

    @property
    @pulumi.getter(name="sessionRedisPassword")
    def session_redis_password(self) -> str:
        """
        Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "session_redis_password")

    @property
    @pulumi.getter(name="sessionRedisPort")
    def session_redis_port(self) -> int:
        """
        The Redis port.
        """
        return pulumi.get(self, "session_redis_port")

    @property
    @pulumi.getter(name="sessionRedisPrefix")
    def session_redis_prefix(self) -> str:
        """
        The Redis session key prefix.
        """
        return pulumi.get(self, "session_redis_prefix")

    @property
    @pulumi.getter(name="sessionRedisReadTimeout")
    def session_redis_read_timeout(self) -> int:
        """
        Session redis read timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_read_timeout")

    @property
    @pulumi.getter(name="sessionRedisSendTimeout")
    def session_redis_send_timeout(self) -> int:
        """
        Session redis send timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_send_timeout")

    @property
    @pulumi.getter(name="sessionRedisServerName")
    def session_redis_server_name(self) -> str:
        """
        The SNI used for connecting the Redis server.
        """
        return pulumi.get(self, "session_redis_server_name")

    @property
    @pulumi.getter(name="sessionRedisSocket")
    def session_redis_socket(self) -> str:
        """
        The Redis unix socket path.
        """
        return pulumi.get(self, "session_redis_socket")

    @property
    @pulumi.getter(name="sessionRedisSsl")
    def session_redis_ssl(self) -> bool:
        """
        Use SSL/TLS for Redis connection.
        """
        return pulumi.get(self, "session_redis_ssl")

    @property
    @pulumi.getter(name="sessionRedisSslVerify")
    def session_redis_ssl_verify(self) -> bool:
        """
        Verify identity provider server certificate.
        """
        return pulumi.get(self, "session_redis_ssl_verify")

    @property
    @pulumi.getter(name="sessionRedisUsername")
    def session_redis_username(self) -> str:
        """
        Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "session_redis_username")

    @property
    @pulumi.getter(name="sessionRemember")
    def session_remember(self) -> bool:
        """
        Enables or disables persistent sessions.
        """
        return pulumi.get(self, "session_remember")

    @property
    @pulumi.getter(name="sessionRememberAbsoluteTimeout")
    def session_remember_absolute_timeout(self) -> float:
        """
        Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        """
        return pulumi.get(self, "session_remember_absolute_timeout")

    @property
    @pulumi.getter(name="sessionRememberCookieName")
    def session_remember_cookie_name(self) -> str:
        """
        Persistent session cookie name. Use with the `remember` configuration parameter.
        """
        return pulumi.get(self, "session_remember_cookie_name")

    @property
    @pulumi.getter(name="sessionRememberRollingTimeout")
    def session_remember_rolling_timeout(self) -> float:
        """
        Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "session_remember_rolling_timeout")

    @property
    @pulumi.getter(name="sessionRequestHeaders")
    def session_request_headers(self) -> Sequence[str]:
        """
        Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
        """
        return pulumi.get(self, "session_request_headers")

    @property
    @pulumi.getter(name="sessionResponseHeaders")
    def session_response_headers(self) -> Sequence[str]:
        """
        Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
        """
        return pulumi.get(self, "session_response_headers")

    @property
    @pulumi.getter(name="sessionRollingTimeout")
    def session_rolling_timeout(self) -> float:
        """
        Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        """
        return pulumi.get(self, "session_rolling_timeout")

    @property
    @pulumi.getter(name="sessionSecret")
    def session_secret(self) -> str:
        """
        The session secret.
        """
        return pulumi.get(self, "session_secret")

    @property
    @pulumi.getter(name="sessionStorage")
    def session_storage(self) -> str:
        """
        The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        """
        return pulumi.get(self, "session_storage")

    @property
    @pulumi.getter(name="sessionStoreMetadata")
    def session_store_metadata(self) -> bool:
        """
        Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
        """
        return pulumi.get(self, "session_store_metadata")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> bool:
        """
        Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `lua_ssl_trusted_certificate`.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> float:
        """
        Network IO timeout in milliseconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsClientAuthCertId")
    def tls_client_auth_cert_id(self) -> str:
        """
        ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
        """
        return pulumi.get(self, "tls_client_auth_cert_id")

    @property
    @pulumi.getter(name="tlsClientAuthSslVerify")
    def tls_client_auth_ssl_verify(self) -> bool:
        """
        Verify identity provider server certificate during mTLS client authentication.
        """
        return pulumi.get(self, "tls_client_auth_ssl_verify")

    @property
    @pulumi.getter(name="tokenCacheKeyIncludeScope")
    def token_cache_key_include_scope(self) -> bool:
        """
        Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
        """
        return pulumi.get(self, "token_cache_key_include_scope")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="tokenEndpointAuthMethod")
    def token_endpoint_auth_method(self) -> str:
        """
        The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        """
        return pulumi.get(self, "token_endpoint_auth_method")

    @property
    @pulumi.getter(name="tokenExchangeEndpoint")
    def token_exchange_endpoint(self) -> str:
        """
        The token exchange endpoint.
        """
        return pulumi.get(self, "token_exchange_endpoint")

    @property
    @pulumi.getter(name="tokenHeadersClients")
    def token_headers_clients(self) -> Sequence[str]:
        """
        Extra headers passed from the client to the token endpoint.
        """
        return pulumi.get(self, "token_headers_clients")

    @property
    @pulumi.getter(name="tokenHeadersGrants")
    def token_headers_grants(self) -> Sequence[str]:
        """
        Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
        """
        return pulumi.get(self, "token_headers_grants")

    @property
    @pulumi.getter(name="tokenHeadersNames")
    def token_headers_names(self) -> Sequence[str]:
        """
        Extra header names passed to the token endpoint.
        """
        return pulumi.get(self, "token_headers_names")

    @property
    @pulumi.getter(name="tokenHeadersPrefix")
    def token_headers_prefix(self) -> str:
        """
        Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
        """
        return pulumi.get(self, "token_headers_prefix")

    @property
    @pulumi.getter(name="tokenHeadersReplays")
    def token_headers_replays(self) -> Sequence[str]:
        """
        The names of token endpoint response headers to forward to the downstream client.
        """
        return pulumi.get(self, "token_headers_replays")

    @property
    @pulumi.getter(name="tokenHeadersValues")
    def token_headers_values(self) -> Sequence[str]:
        """
        Extra header values passed to the token endpoint.
        """
        return pulumi.get(self, "token_headers_values")

    @property
    @pulumi.getter(name="tokenPostArgsClients")
    def token_post_args_clients(self) -> Sequence[str]:
        """
        Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_clients")

    @property
    @pulumi.getter(name="tokenPostArgsNames")
    def token_post_args_names(self) -> Sequence[str]:
        """
        Extra post argument names passed to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_names")

    @property
    @pulumi.getter(name="tokenPostArgsValues")
    def token_post_args_values(self) -> Sequence[str]:
        """
        Extra post argument values passed to the token endpoint.
        """
        return pulumi.get(self, "token_post_args_values")

    @property
    @pulumi.getter(name="unauthorizedDestroySession")
    def unauthorized_destroy_session(self) -> bool:
        """
        Destroy any active session for the unauthorized requests.
        """
        return pulumi.get(self, "unauthorized_destroy_session")

    @property
    @pulumi.getter(name="unauthorizedErrorMessage")
    def unauthorized_error_message(self) -> str:
        """
        The error message for the unauthorized requests (when not using the redirection).
        """
        return pulumi.get(self, "unauthorized_error_message")

    @property
    @pulumi.getter(name="unauthorizedRedirectUris")
    def unauthorized_redirect_uris(self) -> Sequence[str]:
        """
        Where to redirect the client on unauthorized requests.
        """
        return pulumi.get(self, "unauthorized_redirect_uris")

    @property
    @pulumi.getter(name="unexpectedRedirectUris")
    def unexpected_redirect_uris(self) -> Sequence[str]:
        """
        Where to redirect the client when unexpected errors happen with the requests.
        """
        return pulumi.get(self, "unexpected_redirect_uris")

    @property
    @pulumi.getter(name="upstreamAccessTokenHeader")
    def upstream_access_token_header(self) -> str:
        """
        The upstream access token header.
        """
        return pulumi.get(self, "upstream_access_token_header")

    @property
    @pulumi.getter(name="upstreamAccessTokenJwkHeader")
    def upstream_access_token_jwk_header(self) -> str:
        """
        The upstream access token JWK header.
        """
        return pulumi.get(self, "upstream_access_token_jwk_header")

    @property
    @pulumi.getter(name="upstreamHeadersClaims")
    def upstream_headers_claims(self) -> Sequence[str]:
        """
        The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        """
        return pulumi.get(self, "upstream_headers_claims")

    @property
    @pulumi.getter(name="upstreamHeadersNames")
    def upstream_headers_names(self) -> Sequence[str]:
        """
        The upstream header names for the claim values.
        """
        return pulumi.get(self, "upstream_headers_names")

    @property
    @pulumi.getter(name="upstreamIdTokenHeader")
    def upstream_id_token_header(self) -> str:
        """
        The upstream id token header.
        """
        return pulumi.get(self, "upstream_id_token_header")

    @property
    @pulumi.getter(name="upstreamIdTokenJwkHeader")
    def upstream_id_token_jwk_header(self) -> str:
        """
        The upstream id token JWK header.
        """
        return pulumi.get(self, "upstream_id_token_jwk_header")

    @property
    @pulumi.getter(name="upstreamIntrospectionHeader")
    def upstream_introspection_header(self) -> str:
        """
        The upstream introspection header.
        """
        return pulumi.get(self, "upstream_introspection_header")

    @property
    @pulumi.getter(name="upstreamIntrospectionJwtHeader")
    def upstream_introspection_jwt_header(self) -> str:
        """
        The upstream introspection JWT header.
        """
        return pulumi.get(self, "upstream_introspection_jwt_header")

    @property
    @pulumi.getter(name="upstreamRefreshTokenHeader")
    def upstream_refresh_token_header(self) -> str:
        """
        The upstream refresh token header.
        """
        return pulumi.get(self, "upstream_refresh_token_header")

    @property
    @pulumi.getter(name="upstreamSessionIdHeader")
    def upstream_session_id_header(self) -> str:
        """
        The upstream session id header.
        """
        return pulumi.get(self, "upstream_session_id_header")

    @property
    @pulumi.getter(name="upstreamUserInfoHeader")
    def upstream_user_info_header(self) -> str:
        """
        The upstream user info header.
        """
        return pulumi.get(self, "upstream_user_info_header")

    @property
    @pulumi.getter(name="upstreamUserInfoJwtHeader")
    def upstream_user_info_jwt_header(self) -> str:
        """
        The upstream user info JWT header (in case the user info returns a JWT response).
        """
        return pulumi.get(self, "upstream_user_info_jwt_header")

    @property
    @pulumi.getter(name="userinfoAccept")
    def userinfo_accept(self) -> str:
        """
        The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
        """
        return pulumi.get(self, "userinfo_accept")

    @property
    @pulumi.getter(name="userinfoEndpoint")
    def userinfo_endpoint(self) -> str:
        """
        The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
        """
        return pulumi.get(self, "userinfo_endpoint")

    @property
    @pulumi.getter(name="userinfoHeadersClients")
    def userinfo_headers_clients(self) -> Sequence[str]:
        """
        Extra headers passed from the client to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_clients")

    @property
    @pulumi.getter(name="userinfoHeadersNames")
    def userinfo_headers_names(self) -> Sequence[str]:
        """
        Extra header names passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_names")

    @property
    @pulumi.getter(name="userinfoHeadersValues")
    def userinfo_headers_values(self) -> Sequence[str]:
        """
        Extra header values passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_headers_values")

    @property
    @pulumi.getter(name="userinfoQueryArgsClients")
    def userinfo_query_args_clients(self) -> Sequence[str]:
        """
        Extra query arguments passed from the client to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_clients")

    @property
    @pulumi.getter(name="userinfoQueryArgsNames")
    def userinfo_query_args_names(self) -> Sequence[str]:
        """
        Extra query argument names passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_names")

    @property
    @pulumi.getter(name="userinfoQueryArgsValues")
    def userinfo_query_args_values(self) -> Sequence[str]:
        """
        Extra query argument values passed to the user info endpoint.
        """
        return pulumi.get(self, "userinfo_query_args_values")

    @property
    @pulumi.getter(name="usingPseudoIssuer")
    def using_pseudo_issuer(self) -> bool:
        """
        If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
        """
        return pulumi.get(self, "using_pseudo_issuer")

    @property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> bool:
        """
        Verify tokens for standard claims.
        """
        return pulumi.get(self, "verify_claims")

    @property
    @pulumi.getter(name="verifyNonce")
    def verify_nonce(self) -> bool:
        """
        Verify nonce on authorization code flow.
        """
        return pulumi.get(self, "verify_nonce")

    @property
    @pulumi.getter(name="verifyParameters")
    def verify_parameters(self) -> bool:
        """
        Verify plugin configuration against discovery.
        """
        return pulumi.get(self, "verify_parameters")

    @property
    @pulumi.getter(name="verifySignature")
    def verify_signature(self) -> bool:
        """
        Verify signature of tokens.
        """
        return pulumi.get(self, "verify_signature")


@pulumi.output_type
class GetGatewayPluginOpenidConnectConfigClientJwkResult(dict):
    def __init__(__self__, *,
                 alg: str,
                 crv: str,
                 d: str,
                 dp: str,
                 dq: str,
                 e: str,
                 issuer: str,
                 k: str,
                 key_ops: Sequence[str],
                 kid: str,
                 kty: str,
                 n: str,
                 oth: str,
                 p: str,
                 q: str,
                 qi: str,
                 r: str,
                 t: str,
                 use: str,
                 x: str,
                 x5cs: Sequence[str],
                 x5t: str,
                 x5t_number_s256: str,
                 x5u: str,
                 y: str):
        pulumi.set(__self__, "alg", alg)
        pulumi.set(__self__, "crv", crv)
        pulumi.set(__self__, "d", d)
        pulumi.set(__self__, "dp", dp)
        pulumi.set(__self__, "dq", dq)
        pulumi.set(__self__, "e", e)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "k", k)
        pulumi.set(__self__, "key_ops", key_ops)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "kty", kty)
        pulumi.set(__self__, "n", n)
        pulumi.set(__self__, "oth", oth)
        pulumi.set(__self__, "p", p)
        pulumi.set(__self__, "q", q)
        pulumi.set(__self__, "qi", qi)
        pulumi.set(__self__, "r", r)
        pulumi.set(__self__, "t", t)
        pulumi.set(__self__, "use", use)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "x5cs", x5cs)
        pulumi.set(__self__, "x5t", x5t)
        pulumi.set(__self__, "x5t_number_s256", x5t_number_s256)
        pulumi.set(__self__, "x5u", x5u)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def alg(self) -> str:
        return pulumi.get(self, "alg")

    @property
    @pulumi.getter
    def crv(self) -> str:
        return pulumi.get(self, "crv")

    @property
    @pulumi.getter
    def d(self) -> str:
        return pulumi.get(self, "d")

    @property
    @pulumi.getter
    def dp(self) -> str:
        return pulumi.get(self, "dp")

    @property
    @pulumi.getter
    def dq(self) -> str:
        return pulumi.get(self, "dq")

    @property
    @pulumi.getter
    def e(self) -> str:
        return pulumi.get(self, "e")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def k(self) -> str:
        return pulumi.get(self, "k")

    @property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Sequence[str]:
        return pulumi.get(self, "key_ops")

    @property
    @pulumi.getter
    def kid(self) -> str:
        return pulumi.get(self, "kid")

    @property
    @pulumi.getter
    def kty(self) -> str:
        return pulumi.get(self, "kty")

    @property
    @pulumi.getter
    def n(self) -> str:
        return pulumi.get(self, "n")

    @property
    @pulumi.getter
    def oth(self) -> str:
        return pulumi.get(self, "oth")

    @property
    @pulumi.getter
    def p(self) -> str:
        return pulumi.get(self, "p")

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def qi(self) -> str:
        return pulumi.get(self, "qi")

    @property
    @pulumi.getter
    def r(self) -> str:
        return pulumi.get(self, "r")

    @property
    @pulumi.getter
    def t(self) -> str:
        return pulumi.get(self, "t")

    @property
    @pulumi.getter
    def use(self) -> str:
        return pulumi.get(self, "use")

    @property
    @pulumi.getter
    def x(self) -> str:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def x5cs(self) -> Sequence[str]:
        return pulumi.get(self, "x5cs")

    @property
    @pulumi.getter
    def x5t(self) -> str:
        return pulumi.get(self, "x5t")

    @property
    @pulumi.getter(name="x5tNumberS256")
    def x5t_number_s256(self) -> str:
        return pulumi.get(self, "x5t_number_s256")

    @property
    @pulumi.getter
    def x5u(self) -> str:
        return pulumi.get(self, "x5u")

    @property
    @pulumi.getter
    def y(self) -> str:
        return pulumi.get(self, "y")


@pulumi.output_type
class GetGatewayPluginOpenidConnectConfigSessionRedisClusterNodeResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        """
        :param str ip: A string representing a host name, such as example.com.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetGatewayPluginOpenidConnectConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpenidConnectConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpenidConnectRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpenidConnectServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpentelemetryConfigResult(dict):
    def __init__(__self__, *,
                 batch_flush_delay: int,
                 batch_span_count: int,
                 connect_timeout: int,
                 endpoint: str,
                 header_type: str,
                 headers: Mapping[str, str],
                 http_response_header_for_traceid: str,
                 propagation: 'outputs.GetGatewayPluginOpentelemetryConfigPropagationResult',
                 queue: 'outputs.GetGatewayPluginOpentelemetryConfigQueueResult',
                 read_timeout: int,
                 resource_attributes: Mapping[str, str],
                 sampling_rate: float,
                 send_timeout: int):
        """
        :param int batch_flush_delay: The delay, in seconds, between two consecutive batches.
        :param int batch_span_count: The number of spans to be sent in a single batch.
        :param int connect_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str endpoint: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str header_type: must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
        :param Mapping[str, str] headers: The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
        :param int read_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param float sampling_rate: Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracing_sampling_rate` setting from kong.conf.
        :param int send_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        pulumi.set(__self__, "batch_flush_delay", batch_flush_delay)
        pulumi.set(__self__, "batch_span_count", batch_span_count)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "header_type", header_type)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_response_header_for_traceid", http_response_header_for_traceid)
        pulumi.set(__self__, "propagation", propagation)
        pulumi.set(__self__, "queue", queue)
        pulumi.set(__self__, "read_timeout", read_timeout)
        pulumi.set(__self__, "resource_attributes", resource_attributes)
        pulumi.set(__self__, "sampling_rate", sampling_rate)
        pulumi.set(__self__, "send_timeout", send_timeout)

    @property
    @pulumi.getter(name="batchFlushDelay")
    def batch_flush_delay(self) -> int:
        """
        The delay, in seconds, between two consecutive batches.
        """
        return pulumi.get(self, "batch_flush_delay")

    @property
    @pulumi.getter(name="batchSpanCount")
    def batch_span_count(self) -> int:
        """
        The number of spans to be sent in a single batch.
        """
        return pulumi.get(self, "batch_span_count")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="headerType")
    def header_type(self) -> str:
        """
        must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
        """
        return pulumi.get(self, "header_type")

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        """
        The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="httpResponseHeaderForTraceid")
    def http_response_header_for_traceid(self) -> str:
        return pulumi.get(self, "http_response_header_for_traceid")

    @property
    @pulumi.getter
    def propagation(self) -> 'outputs.GetGatewayPluginOpentelemetryConfigPropagationResult':
        return pulumi.get(self, "propagation")

    @property
    @pulumi.getter
    def queue(self) -> 'outputs.GetGatewayPluginOpentelemetryConfigQueueResult':
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="resourceAttributes")
    def resource_attributes(self) -> Mapping[str, str]:
        return pulumi.get(self, "resource_attributes")

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> float:
        """
        Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracing_sampling_rate` setting from kong.conf.
        """
        return pulumi.get(self, "sampling_rate")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "send_timeout")


@pulumi.output_type
class GetGatewayPluginOpentelemetryConfigPropagationResult(dict):
    def __init__(__self__, *,
                 clears: Sequence[str],
                 default_format: str,
                 extracts: Sequence[str],
                 injects: Sequence[str]):
        """
        :param Sequence[str] clears: Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
        :param str default_format: The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
        :param Sequence[str] extracts: Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
        :param Sequence[str] injects: Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
        """
        pulumi.set(__self__, "clears", clears)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "extracts", extracts)
        pulumi.set(__self__, "injects", injects)

    @property
    @pulumi.getter
    def clears(self) -> Sequence[str]:
        """
        Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
        """
        return pulumi.get(self, "clears")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        """
        The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
        """
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def extracts(self) -> Sequence[str]:
        """
        Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
        """
        return pulumi.get(self, "extracts")

    @property
    @pulumi.getter
    def injects(self) -> Sequence[str]:
        """
        Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
        """
        return pulumi.get(self, "injects")


@pulumi.output_type
class GetGatewayPluginOpentelemetryConfigQueueResult(dict):
    def __init__(__self__, *,
                 initial_retry_delay: float,
                 max_batch_size: int,
                 max_bytes: int,
                 max_coalescing_delay: float,
                 max_entries: int,
                 max_retry_delay: float,
                 max_retry_time: float):
        """
        :param float initial_retry_delay: Time in seconds before the initial retry is made for a failing batch.
        :param int max_batch_size: Maximum number of entries that can be processed at a time.
        :param int max_bytes: Maximum number of bytes that can be waiting on a queue, requires string content.
        :param float max_coalescing_delay: Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        :param int max_entries: Maximum number of entries that can be waiting on the queue.
        :param float max_retry_delay: Maximum time in seconds between retries, caps exponential backoff.
        :param float max_retry_time: Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        pulumi.set(__self__, "initial_retry_delay", initial_retry_delay)
        pulumi.set(__self__, "max_batch_size", max_batch_size)
        pulumi.set(__self__, "max_bytes", max_bytes)
        pulumi.set(__self__, "max_coalescing_delay", max_coalescing_delay)
        pulumi.set(__self__, "max_entries", max_entries)
        pulumi.set(__self__, "max_retry_delay", max_retry_delay)
        pulumi.set(__self__, "max_retry_time", max_retry_time)

    @property
    @pulumi.getter(name="initialRetryDelay")
    def initial_retry_delay(self) -> float:
        """
        Time in seconds before the initial retry is made for a failing batch.
        """
        return pulumi.get(self, "initial_retry_delay")

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> int:
        """
        Maximum number of entries that can be processed at a time.
        """
        return pulumi.get(self, "max_batch_size")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> int:
        """
        Maximum number of bytes that can be waiting on a queue, requires string content.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxCoalescingDelay")
    def max_coalescing_delay(self) -> float:
        """
        Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        """
        return pulumi.get(self, "max_coalescing_delay")

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> int:
        """
        Maximum number of entries that can be waiting on the queue.
        """
        return pulumi.get(self, "max_entries")

    @property
    @pulumi.getter(name="maxRetryDelay")
    def max_retry_delay(self) -> float:
        """
        Maximum time in seconds between retries, caps exponential backoff.
        """
        return pulumi.get(self, "max_retry_delay")

    @property
    @pulumi.getter(name="maxRetryTime")
    def max_retry_time(self) -> float:
        """
        Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        return pulumi.get(self, "max_retry_time")


@pulumi.output_type
class GetGatewayPluginOpentelemetryConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpentelemetryConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpentelemetryRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginOpentelemetryServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPostFunctionConfigResult(dict):
    def __init__(__self__, *,
                 accesses: Sequence[str],
                 body_filters: Sequence[str],
                 certificates: Sequence[str],
                 header_filters: Sequence[str],
                 logs: Sequence[str],
                 rewrites: Sequence[str],
                 ws_client_frames: Sequence[str],
                 ws_closes: Sequence[str],
                 ws_handshakes: Sequence[str],
                 ws_upstream_frames: Sequence[str]):
        pulumi.set(__self__, "accesses", accesses)
        pulumi.set(__self__, "body_filters", body_filters)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "header_filters", header_filters)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "rewrites", rewrites)
        pulumi.set(__self__, "ws_client_frames", ws_client_frames)
        pulumi.set(__self__, "ws_closes", ws_closes)
        pulumi.set(__self__, "ws_handshakes", ws_handshakes)
        pulumi.set(__self__, "ws_upstream_frames", ws_upstream_frames)

    @property
    @pulumi.getter
    def accesses(self) -> Sequence[str]:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="bodyFilters")
    def body_filters(self) -> Sequence[str]:
        return pulumi.get(self, "body_filters")

    @property
    @pulumi.getter
    def certificates(self) -> Sequence[str]:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="headerFilters")
    def header_filters(self) -> Sequence[str]:
        return pulumi.get(self, "header_filters")

    @property
    @pulumi.getter
    def logs(self) -> Sequence[str]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def rewrites(self) -> Sequence[str]:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter(name="wsClientFrames")
    def ws_client_frames(self) -> Sequence[str]:
        return pulumi.get(self, "ws_client_frames")

    @property
    @pulumi.getter(name="wsCloses")
    def ws_closes(self) -> Sequence[str]:
        return pulumi.get(self, "ws_closes")

    @property
    @pulumi.getter(name="wsHandshakes")
    def ws_handshakes(self) -> Sequence[str]:
        return pulumi.get(self, "ws_handshakes")

    @property
    @pulumi.getter(name="wsUpstreamFrames")
    def ws_upstream_frames(self) -> Sequence[str]:
        return pulumi.get(self, "ws_upstream_frames")


@pulumi.output_type
class GetGatewayPluginPostFunctionConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPostFunctionConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPostFunctionRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPostFunctionServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPreFunctionConfigResult(dict):
    def __init__(__self__, *,
                 accesses: Sequence[str],
                 body_filters: Sequence[str],
                 certificates: Sequence[str],
                 header_filters: Sequence[str],
                 logs: Sequence[str],
                 rewrites: Sequence[str],
                 ws_client_frames: Sequence[str],
                 ws_closes: Sequence[str],
                 ws_handshakes: Sequence[str],
                 ws_upstream_frames: Sequence[str]):
        pulumi.set(__self__, "accesses", accesses)
        pulumi.set(__self__, "body_filters", body_filters)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "header_filters", header_filters)
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "rewrites", rewrites)
        pulumi.set(__self__, "ws_client_frames", ws_client_frames)
        pulumi.set(__self__, "ws_closes", ws_closes)
        pulumi.set(__self__, "ws_handshakes", ws_handshakes)
        pulumi.set(__self__, "ws_upstream_frames", ws_upstream_frames)

    @property
    @pulumi.getter
    def accesses(self) -> Sequence[str]:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="bodyFilters")
    def body_filters(self) -> Sequence[str]:
        return pulumi.get(self, "body_filters")

    @property
    @pulumi.getter
    def certificates(self) -> Sequence[str]:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="headerFilters")
    def header_filters(self) -> Sequence[str]:
        return pulumi.get(self, "header_filters")

    @property
    @pulumi.getter
    def logs(self) -> Sequence[str]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def rewrites(self) -> Sequence[str]:
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter(name="wsClientFrames")
    def ws_client_frames(self) -> Sequence[str]:
        return pulumi.get(self, "ws_client_frames")

    @property
    @pulumi.getter(name="wsCloses")
    def ws_closes(self) -> Sequence[str]:
        return pulumi.get(self, "ws_closes")

    @property
    @pulumi.getter(name="wsHandshakes")
    def ws_handshakes(self) -> Sequence[str]:
        return pulumi.get(self, "ws_handshakes")

    @property
    @pulumi.getter(name="wsUpstreamFrames")
    def ws_upstream_frames(self) -> Sequence[str]:
        return pulumi.get(self, "ws_upstream_frames")


@pulumi.output_type
class GetGatewayPluginPreFunctionConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPreFunctionConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPreFunctionRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPreFunctionServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPrometheusConfigResult(dict):
    def __init__(__self__, *,
                 bandwidth_metrics: bool,
                 latency_metrics: bool,
                 per_consumer: bool,
                 status_code_metrics: bool,
                 upstream_health_metrics: bool):
        """
        :param bool bandwidth_metrics: A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidth_bytes` and `stream_sessions_total` metrics will be exported.
        :param bool latency_metrics: A boolean value that determines if latency metrics should be collected. If enabled, `kong_latency_ms`, `upstream_latency_ms` and `request_latency_ms` metrics will be exported.
        :param bool per_consumer: A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kong_http_requests_total` and `kong_bandwidth_bytes` metrics fill in the consumer label when available.
        :param bool status_code_metrics: A boolean value that determines if status code metrics should be collected. If enabled, `http_requests_total`, `stream_sessions_total` metrics will be exported.
        :param bool upstream_health_metrics: A boolean value that determines if upstream metrics should be collected. If enabled, `upstream_target_health` metric will be exported.
        """
        pulumi.set(__self__, "bandwidth_metrics", bandwidth_metrics)
        pulumi.set(__self__, "latency_metrics", latency_metrics)
        pulumi.set(__self__, "per_consumer", per_consumer)
        pulumi.set(__self__, "status_code_metrics", status_code_metrics)
        pulumi.set(__self__, "upstream_health_metrics", upstream_health_metrics)

    @property
    @pulumi.getter(name="bandwidthMetrics")
    def bandwidth_metrics(self) -> bool:
        """
        A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidth_bytes` and `stream_sessions_total` metrics will be exported.
        """
        return pulumi.get(self, "bandwidth_metrics")

    @property
    @pulumi.getter(name="latencyMetrics")
    def latency_metrics(self) -> bool:
        """
        A boolean value that determines if latency metrics should be collected. If enabled, `kong_latency_ms`, `upstream_latency_ms` and `request_latency_ms` metrics will be exported.
        """
        return pulumi.get(self, "latency_metrics")

    @property
    @pulumi.getter(name="perConsumer")
    def per_consumer(self) -> bool:
        """
        A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kong_http_requests_total` and `kong_bandwidth_bytes` metrics fill in the consumer label when available.
        """
        return pulumi.get(self, "per_consumer")

    @property
    @pulumi.getter(name="statusCodeMetrics")
    def status_code_metrics(self) -> bool:
        """
        A boolean value that determines if status code metrics should be collected. If enabled, `http_requests_total`, `stream_sessions_total` metrics will be exported.
        """
        return pulumi.get(self, "status_code_metrics")

    @property
    @pulumi.getter(name="upstreamHealthMetrics")
    def upstream_health_metrics(self) -> bool:
        """
        A boolean value that determines if upstream metrics should be collected. If enabled, `upstream_target_health` metric will be exported.
        """
        return pulumi.get(self, "upstream_health_metrics")


@pulumi.output_type
class GetGatewayPluginPrometheusConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPrometheusConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPrometheusRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginPrometheusServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginProxyCacheConfigResult(dict):
    def __init__(__self__, *,
                 cache_control: bool,
                 cache_ttl: int,
                 content_types: Sequence[str],
                 ignore_uri_case: bool,
                 memory: 'outputs.GetGatewayPluginProxyCacheConfigMemoryResult',
                 request_methods: Sequence[str],
                 response_codes: Sequence[int],
                 response_headers: 'outputs.GetGatewayPluginProxyCacheConfigResponseHeadersResult',
                 storage_ttl: int,
                 strategy: str,
                 vary_headers: Sequence[str],
                 vary_query_params: Sequence[str]):
        """
        :param bool cache_control: When enabled, respect the Cache-Control behaviors defined in RFC7234.
        :param int cache_ttl: TTL, in seconds, of cache entities.
        :param Sequence[str] content_types: Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
        :param Sequence[str] request_methods: Downstream request methods considered cacheable.
        :param Sequence[int] response_codes: Upstream response status code considered cacheable.
        :param 'GetGatewayPluginProxyCacheConfigResponseHeadersArgs' response_headers: Caching related diagnostic headers that should be included in cached responses
        :param int storage_ttl: Number of seconds to keep resources in the storage backend. This value is independent of `cache_ttl` or resource TTLs defined by Cache-Control behaviors.
        :param str strategy: The backing data store in which to hold cache entities. must be one of ["memory"]
        :param Sequence[str] vary_headers: Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
        :param Sequence[str] vary_query_params: Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
        """
        pulumi.set(__self__, "cache_control", cache_control)
        pulumi.set(__self__, "cache_ttl", cache_ttl)
        pulumi.set(__self__, "content_types", content_types)
        pulumi.set(__self__, "ignore_uri_case", ignore_uri_case)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "request_methods", request_methods)
        pulumi.set(__self__, "response_codes", response_codes)
        pulumi.set(__self__, "response_headers", response_headers)
        pulumi.set(__self__, "storage_ttl", storage_ttl)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "vary_headers", vary_headers)
        pulumi.set(__self__, "vary_query_params", vary_query_params)

    @property
    @pulumi.getter(name="cacheControl")
    def cache_control(self) -> bool:
        """
        When enabled, respect the Cache-Control behaviors defined in RFC7234.
        """
        return pulumi.get(self, "cache_control")

    @property
    @pulumi.getter(name="cacheTtl")
    def cache_ttl(self) -> int:
        """
        TTL, in seconds, of cache entities.
        """
        return pulumi.get(self, "cache_ttl")

    @property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Sequence[str]:
        """
        Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
        """
        return pulumi.get(self, "content_types")

    @property
    @pulumi.getter(name="ignoreUriCase")
    def ignore_uri_case(self) -> bool:
        return pulumi.get(self, "ignore_uri_case")

    @property
    @pulumi.getter
    def memory(self) -> 'outputs.GetGatewayPluginProxyCacheConfigMemoryResult':
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Sequence[str]:
        """
        Downstream request methods considered cacheable.
        """
        return pulumi.get(self, "request_methods")

    @property
    @pulumi.getter(name="responseCodes")
    def response_codes(self) -> Sequence[int]:
        """
        Upstream response status code considered cacheable.
        """
        return pulumi.get(self, "response_codes")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> 'outputs.GetGatewayPluginProxyCacheConfigResponseHeadersResult':
        """
        Caching related diagnostic headers that should be included in cached responses
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="storageTtl")
    def storage_ttl(self) -> int:
        """
        Number of seconds to keep resources in the storage backend. This value is independent of `cache_ttl` or resource TTLs defined by Cache-Control behaviors.
        """
        return pulumi.get(self, "storage_ttl")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The backing data store in which to hold cache entities. must be one of ["memory"]
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="varyHeaders")
    def vary_headers(self) -> Sequence[str]:
        """
        Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
        """
        return pulumi.get(self, "vary_headers")

    @property
    @pulumi.getter(name="varyQueryParams")
    def vary_query_params(self) -> Sequence[str]:
        """
        Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
        """
        return pulumi.get(self, "vary_query_params")


@pulumi.output_type
class GetGatewayPluginProxyCacheConfigMemoryResult(dict):
    def __init__(__self__, *,
                 dictionary_name: str):
        """
        :param str dictionary_name: The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
        """
        pulumi.set(__self__, "dictionary_name", dictionary_name)

    @property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> str:
        """
        The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
        """
        return pulumi.get(self, "dictionary_name")


@pulumi.output_type
class GetGatewayPluginProxyCacheConfigResponseHeadersResult(dict):
    def __init__(__self__, *,
                 age: bool,
                 x_cache_key: bool,
                 x_cache_status: bool):
        pulumi.set(__self__, "age", age)
        pulumi.set(__self__, "x_cache_key", x_cache_key)
        pulumi.set(__self__, "x_cache_status", x_cache_status)

    @property
    @pulumi.getter
    def age(self) -> bool:
        return pulumi.get(self, "age")

    @property
    @pulumi.getter(name="xCacheKey")
    def x_cache_key(self) -> bool:
        return pulumi.get(self, "x_cache_key")

    @property
    @pulumi.getter(name="xCacheStatus")
    def x_cache_status(self) -> bool:
        return pulumi.get(self, "x_cache_status")


@pulumi.output_type
class GetGatewayPluginProxyCacheConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginProxyCacheConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginProxyCacheRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginProxyCacheServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedConfigResult(dict):
    def __init__(__self__, *,
                 consumer_groups: Sequence[str],
                 dictionary_name: str,
                 disable_penalty: bool,
                 enforce_consumer_groups: bool,
                 error_code: float,
                 error_message: str,
                 header_name: str,
                 hide_client_headers: bool,
                 identifier: str,
                 limits: Sequence[float],
                 namespace: str,
                 path: str,
                 redis: 'outputs.GetGatewayPluginRateLimitingAdvancedConfigRedisResult',
                 retry_after_jitter_max: float,
                 strategy: str,
                 sync_rate: float,
                 window_sizes: Sequence[float],
                 window_type: str):
        """
        :param Sequence[str] consumer_groups: List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforce_consumer_groups` is set to `true`.
        :param str dictionary_name: The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
        :param bool disable_penalty: If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
        :param bool enforce_consumer_groups: Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforce_consumer_groups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforce_consumer_groups` to `true` to re-enforce the groups.
        :param float error_code: Set a custom error code to return when the rate limit is exceeded.
        :param str error_message: Set a custom error message to return when the rate limit is exceeded.
        :param str header_name: A string representing an HTTP header name.
        :param bool hide_client_headers: Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
        :param str identifier: The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
        :param Sequence[float] limits: One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
        :param str namespace: The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `sync_rate`, `window_size`, `dictionary_name`, need to be the same.
        :param str path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param float retry_after_jitter_max: The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
        :param str strategy: The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
        :param float sync_rate: How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
        :param Sequence[float] window_sizes: One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
        :param str window_type: Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
        """
        pulumi.set(__self__, "consumer_groups", consumer_groups)
        pulumi.set(__self__, "dictionary_name", dictionary_name)
        pulumi.set(__self__, "disable_penalty", disable_penalty)
        pulumi.set(__self__, "enforce_consumer_groups", enforce_consumer_groups)
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "redis", redis)
        pulumi.set(__self__, "retry_after_jitter_max", retry_after_jitter_max)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "sync_rate", sync_rate)
        pulumi.set(__self__, "window_sizes", window_sizes)
        pulumi.set(__self__, "window_type", window_type)

    @property
    @pulumi.getter(name="consumerGroups")
    def consumer_groups(self) -> Sequence[str]:
        """
        List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforce_consumer_groups` is set to `true`.
        """
        return pulumi.get(self, "consumer_groups")

    @property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> str:
        """
        The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
        """
        return pulumi.get(self, "dictionary_name")

    @property
    @pulumi.getter(name="disablePenalty")
    def disable_penalty(self) -> bool:
        """
        If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
        """
        return pulumi.get(self, "disable_penalty")

    @property
    @pulumi.getter(name="enforceConsumerGroups")
    def enforce_consumer_groups(self) -> bool:
        """
        Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforce_consumer_groups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforce_consumer_groups` to `true` to re-enforce the groups.
        """
        return pulumi.get(self, "enforce_consumer_groups")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> float:
        """
        Set a custom error code to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Set a custom error message to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> bool:
        """
        Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
        """
        return pulumi.get(self, "hide_client_headers")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def limits(self) -> Sequence[float]:
        """
        One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `sync_rate`, `window_size`, `dictionary_name`, need to be the same.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def redis(self) -> 'outputs.GetGatewayPluginRateLimitingAdvancedConfigRedisResult':
        return pulumi.get(self, "redis")

    @property
    @pulumi.getter(name="retryAfterJitterMax")
    def retry_after_jitter_max(self) -> float:
        """
        The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
        """
        return pulumi.get(self, "retry_after_jitter_max")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="syncRate")
    def sync_rate(self) -> float:
        """
        How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
        """
        return pulumi.get(self, "sync_rate")

    @property
    @pulumi.getter(name="windowSizes")
    def window_sizes(self) -> Sequence[float]:
        """
        One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
        """
        return pulumi.get(self, "window_sizes")

    @property
    @pulumi.getter(name="windowType")
    def window_type(self) -> str:
        """
        Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
        """
        return pulumi.get(self, "window_type")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedConfigRedisResult(dict):
    def __init__(__self__, *,
                 cluster_addresses: Sequence[str],
                 connect_timeout: int,
                 database: int,
                 host: str,
                 keepalive_backlog: int,
                 keepalive_pool_size: int,
                 password: str,
                 port: int,
                 read_timeout: int,
                 send_timeout: int,
                 sentinel_addresses: Sequence[str],
                 sentinel_master: str,
                 sentinel_password: str,
                 sentinel_role: str,
                 sentinel_username: str,
                 server_name: str,
                 ssl: bool,
                 ssl_verify: bool,
                 timeout: int,
                 username: str):
        """
        :param Sequence[str] cluster_addresses: Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
        :param int connect_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param int database: Database to use for the Redis connection when using the `redis` strategy
        :param str host: A string representing a host name, such as example.com.
        :param int keepalive_backlog: Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalive_pool_size`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalive_pool_size`.
        :param int keepalive_pool_size: The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalive_pool_size` nor `keepalive_backlog` is specified, no pool is created. If `keepalive_pool_size` isn't specified but `keepalive_backlog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
        :param str password: Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param int read_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param int send_timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param Sequence[str] sentinel_addresses: Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
        :param str sentinel_master: Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
        :param str sentinel_password: Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
        :param str sentinel_role: Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
        :param str sentinel_username: Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
        :param str server_name: A string representing an SNI (server name indication) value for TLS.
        :param bool ssl: If set to true, uses SSL to connect to Redis.
        :param bool ssl_verify: If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        :param int timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str username: Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        pulumi.set(__self__, "cluster_addresses", cluster_addresses)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keepalive_backlog", keepalive_backlog)
        pulumi.set(__self__, "keepalive_pool_size", keepalive_pool_size)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "read_timeout", read_timeout)
        pulumi.set(__self__, "send_timeout", send_timeout)
        pulumi.set(__self__, "sentinel_addresses", sentinel_addresses)
        pulumi.set(__self__, "sentinel_master", sentinel_master)
        pulumi.set(__self__, "sentinel_password", sentinel_password)
        pulumi.set(__self__, "sentinel_role", sentinel_role)
        pulumi.set(__self__, "sentinel_username", sentinel_username)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "ssl_verify", ssl_verify)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clusterAddresses")
    def cluster_addresses(self) -> Sequence[str]:
        """
        Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
        """
        return pulumi.get(self, "cluster_addresses")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def database(self) -> int:
        """
        Database to use for the Redis connection when using the `redis` strategy
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepaliveBacklog")
    def keepalive_backlog(self) -> int:
        """
        Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalive_pool_size`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalive_pool_size`.
        """
        return pulumi.get(self, "keepalive_backlog")

    @property
    @pulumi.getter(name="keepalivePoolSize")
    def keepalive_pool_size(self) -> int:
        """
        The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalive_pool_size` nor `keepalive_backlog` is specified, no pool is created. If `keepalive_pool_size` isn't specified but `keepalive_backlog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
        """
        return pulumi.get(self, "keepalive_pool_size")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "read_timeout")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "send_timeout")

    @property
    @pulumi.getter(name="sentinelAddresses")
    def sentinel_addresses(self) -> Sequence[str]:
        """
        Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
        """
        return pulumi.get(self, "sentinel_addresses")

    @property
    @pulumi.getter(name="sentinelMaster")
    def sentinel_master(self) -> str:
        """
        Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
        """
        return pulumi.get(self, "sentinel_master")

    @property
    @pulumi.getter(name="sentinelPassword")
    def sentinel_password(self) -> str:
        """
        Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
        """
        return pulumi.get(self, "sentinel_password")

    @property
    @pulumi.getter(name="sentinelRole")
    def sentinel_role(self) -> str:
        """
        Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
        """
        return pulumi.get(self, "sentinel_role")

    @property
    @pulumi.getter(name="sentinelUsername")
    def sentinel_username(self) -> str:
        """
        Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
        """
        return pulumi.get(self, "sentinel_username")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        A string representing an SNI (server name indication) value for TLS.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        """
        If set to true, uses SSL to connect to Redis.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> bool:
        """
        If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingAdvancedServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingConfigResult(dict):
    def __init__(__self__, *,
                 day: float,
                 error_code: float,
                 error_message: str,
                 fault_tolerant: bool,
                 header_name: str,
                 hide_client_headers: bool,
                 hour: float,
                 limit_by: str,
                 minute: float,
                 month: float,
                 path: str,
                 policy: str,
                 redis: 'outputs.GetGatewayPluginRateLimitingConfigRedisResult',
                 second: float,
                 sync_rate: float,
                 year: float):
        """
        :param float day: The number of HTTP requests that can be made per day.
        :param float error_code: Set a custom error code to return when the rate limit is exceeded.
        :param str error_message: Set a custom error message to return when the rate limit is exceeded.
        :param bool fault_tolerant: A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
        :param str header_name: A string representing an HTTP header name.
        :param bool hide_client_headers: Optionally hide informative response headers.
        :param float hour: The number of HTTP requests that can be made per hour.
        :param str limit_by: The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
        :param float minute: The number of HTTP requests that can be made per minute.
        :param float month: The number of HTTP requests that can be made per month.
        :param str path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str policy: The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
        :param 'GetGatewayPluginRateLimitingConfigRedisArgs' redis: Redis configuration
        :param float second: The number of HTTP requests that can be made per second.
        :param float sync_rate: How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
        :param float year: The number of HTTP requests that can be made per year.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "fault_tolerant", fault_tolerant)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "hide_client_headers", hide_client_headers)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "limit_by", limit_by)
        pulumi.set(__self__, "minute", minute)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "redis", redis)
        pulumi.set(__self__, "second", second)
        pulumi.set(__self__, "sync_rate", sync_rate)
        pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> float:
        """
        The number of HTTP requests that can be made per day.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> float:
        """
        Set a custom error code to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Set a custom error message to return when the rate limit is exceeded.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="faultTolerant")
    def fault_tolerant(self) -> bool:
        """
        A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
        """
        return pulumi.get(self, "fault_tolerant")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="hideClientHeaders")
    def hide_client_headers(self) -> bool:
        """
        Optionally hide informative response headers.
        """
        return pulumi.get(self, "hide_client_headers")

    @property
    @pulumi.getter
    def hour(self) -> float:
        """
        The number of HTTP requests that can be made per hour.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter(name="limitBy")
    def limit_by(self) -> str:
        """
        The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
        """
        return pulumi.get(self, "limit_by")

    @property
    @pulumi.getter
    def minute(self) -> float:
        """
        The number of HTTP requests that can be made per minute.
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter
    def month(self) -> float:
        """
        The number of HTTP requests that can be made per month.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def redis(self) -> 'outputs.GetGatewayPluginRateLimitingConfigRedisResult':
        """
        Redis configuration
        """
        return pulumi.get(self, "redis")

    @property
    @pulumi.getter
    def second(self) -> float:
        """
        The number of HTTP requests that can be made per second.
        """
        return pulumi.get(self, "second")

    @property
    @pulumi.getter(name="syncRate")
    def sync_rate(self) -> float:
        """
        How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
        """
        return pulumi.get(self, "sync_rate")

    @property
    @pulumi.getter
    def year(self) -> float:
        """
        The number of HTTP requests that can be made per year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class GetGatewayPluginRateLimitingConfigRedisResult(dict):
    def __init__(__self__, *,
                 database: int,
                 host: str,
                 password: str,
                 port: int,
                 server_name: str,
                 ssl: bool,
                 ssl_verify: bool,
                 timeout: int,
                 username: str):
        """
        :param int database: Database to use for the Redis connection when using the `redis` strategy
        :param str host: A string representing a host name, such as example.com.
        :param str password: Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        :param str server_name: A string representing an SNI (server name indication) value for TLS.
        :param bool ssl: If set to true, uses SSL to connect to Redis.
        :param bool ssl_verify: If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        :param int timeout: An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        :param str username: Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "ssl_verify", ssl_verify)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> int:
        """
        Database to use for the Redis connection when using the `redis` strategy
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        A string representing an SNI (server name indication) value for TLS.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        """
        If set to true, uses SSL to connect to Redis.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslVerify")
    def ssl_verify(self) -> bool:
        """
        If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `lua_ssl_trusted_certificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `lua_ssl_verify_depth` accordingly.
        """
        return pulumi.get(self, "ssl_verify")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGatewayPluginRateLimitingConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRateLimitingServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTerminationConfigResult(dict):
    def __init__(__self__, *,
                 body: str,
                 content_type: str,
                 echo: bool,
                 message: str,
                 status_code: int,
                 trigger: str):
        """
        :param str body: The raw response body to send. This is mutually exclusive with the `config.message` field.
        :param str content_type: Content type of the raw response configured with `config.body`.
        :param bool echo: When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
        :param str message: The message to send, if using the default response generator.
        :param int status_code: The response code to send. Must be an integer between 100 and 599.
        :param str trigger: A string representing an HTTP header name.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "echo", echo)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The raw response body to send. This is mutually exclusive with the `config.message` field.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        Content type of the raw response configured with `config.body`.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def echo(self) -> bool:
        """
        When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
        """
        return pulumi.get(self, "echo")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message to send, if using the default response generator.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The response code to send. Must be an integer between 100 and 599.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def trigger(self) -> str:
        """
        A string representing an HTTP header name.
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class GetGatewayPluginRequestTerminationConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTerminationConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTerminationRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTerminationServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigResult(dict):
    def __init__(__self__, *,
                 add: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAddResult',
                 allow: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAllowResult',
                 append: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAppendResult',
                 dots_in_keys: bool,
                 http_method: str,
                 remove: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigRemoveResult',
                 rename: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigRenameResult',
                 replace: 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigReplaceResult'):
        """
        :param bool dots_in_keys: Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
        :param str http_method: A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        pulumi.set(__self__, "add", add)
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "dots_in_keys", dots_in_keys)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "rename", rename)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAddResult':
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def allow(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAllowResult':
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def append(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigAppendResult':
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="dotsInKeys")
    def dots_in_keys(self) -> bool:
        """
        Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
        """
        return pulumi.get(self, "dots_in_keys")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> str:
        """
        A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def remove(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigRemoveResult':
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigRenameResult':
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> 'outputs.GetGatewayPluginRequestTransformerAdvancedConfigReplaceResult':
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigAddResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigAllowResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigAppendResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigRemoveResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigRenameResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConfigReplaceResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 querystrings: Sequence[str],
                 uri: str):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "querystrings", querystrings)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerAdvancedServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigResult(dict):
    def __init__(__self__, *,
                 add: 'outputs.GetGatewayPluginRequestTransformerConfigAddResult',
                 append: 'outputs.GetGatewayPluginRequestTransformerConfigAppendResult',
                 http_method: str,
                 remove: 'outputs.GetGatewayPluginRequestTransformerConfigRemoveResult',
                 rename: 'outputs.GetGatewayPluginRequestTransformerConfigRenameResult',
                 replace: 'outputs.GetGatewayPluginRequestTransformerConfigReplaceResult'):
        """
        :param str http_method: A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        pulumi.set(__self__, "add", add)
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "rename", rename)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> 'outputs.GetGatewayPluginRequestTransformerConfigAddResult':
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def append(self) -> 'outputs.GetGatewayPluginRequestTransformerConfigAppendResult':
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> str:
        """
        A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def remove(self) -> 'outputs.GetGatewayPluginRequestTransformerConfigRemoveResult':
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> 'outputs.GetGatewayPluginRequestTransformerConfigRenameResult':
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> 'outputs.GetGatewayPluginRequestTransformerConfigReplaceResult':
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigAddResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigAppendResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigRemoveResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigRenameResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str]):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConfigReplaceResult(dict):
    def __init__(__self__, *,
                 bodies: Sequence[str],
                 headers: Sequence[str],
                 querystrings: Sequence[str],
                 uri: str):
        pulumi.set(__self__, "bodies", bodies)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "querystrings", querystrings)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def bodies(self) -> Sequence[str]:
        return pulumi.get(self, "bodies")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def querystrings(self) -> Sequence[str]:
        return pulumi.get(self, "querystrings")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginRequestTransformerServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigResult(dict):
    def __init__(__self__, *,
                 add: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAddResult',
                 allow: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAllowResult',
                 append: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAppendResult',
                 dots_in_keys: bool,
                 remove: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigRemoveResult',
                 rename: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigRenameResult',
                 replace: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigReplaceResult',
                 transform: 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigTransformResult'):
        """
        :param bool dots_in_keys: Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
        """
        pulumi.set(__self__, "add", add)
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "dots_in_keys", dots_in_keys)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "rename", rename)
        pulumi.set(__self__, "replace", replace)
        pulumi.set(__self__, "transform", transform)

    @property
    @pulumi.getter
    def add(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAddResult':
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def allow(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAllowResult':
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def append(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigAppendResult':
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="dotsInKeys")
    def dots_in_keys(self) -> bool:
        """
        Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
        """
        return pulumi.get(self, "dots_in_keys")

    @property
    @pulumi.getter
    def remove(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigRemoveResult':
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigRenameResult':
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigReplaceResult':
        return pulumi.get(self, "replace")

    @property
    @pulumi.getter
    def transform(self) -> 'outputs.GetGatewayPluginResponseTransformerAdvancedConfigTransformResult':
        return pulumi.get(self, "transform")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigAddResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 if_statuses: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "if_statuses", if_statuses)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigAllowResult(dict):
    def __init__(__self__, *,
                 jsons: Sequence[str]):
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigAppendResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 if_statuses: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "if_statuses", if_statuses)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigRemoveResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 if_statuses: Sequence[str],
                 jsons: Sequence[str]):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "if_statuses", if_statuses)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigRenameResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 if_statuses: Sequence[str]):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "if_statuses", if_statuses)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigReplaceResult(dict):
    def __init__(__self__, *,
                 body: str,
                 headers: Sequence[str],
                 if_statuses: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        """
        :param str body: String with which to replace the entire response body.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "if_statuses", if_statuses)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        String with which to replace the entire response body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConfigTransformResult(dict):
    def __init__(__self__, *,
                 functions: Sequence[str],
                 if_statuses: Sequence[str],
                 jsons: Sequence[str]):
        pulumi.set(__self__, "functions", functions)
        pulumi.set(__self__, "if_statuses", if_statuses)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def functions(self) -> Sequence[str]:
        return pulumi.get(self, "functions")

    @property
    @pulumi.getter(name="ifStatuses")
    def if_statuses(self) -> Sequence[str]:
        return pulumi.get(self, "if_statuses")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerAdvancedServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigResult(dict):
    def __init__(__self__, *,
                 add: 'outputs.GetGatewayPluginResponseTransformerConfigAddResult',
                 append: 'outputs.GetGatewayPluginResponseTransformerConfigAppendResult',
                 remove: 'outputs.GetGatewayPluginResponseTransformerConfigRemoveResult',
                 rename: 'outputs.GetGatewayPluginResponseTransformerConfigRenameResult',
                 replace: 'outputs.GetGatewayPluginResponseTransformerConfigReplaceResult'):
        pulumi.set(__self__, "add", add)
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "rename", rename)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def add(self) -> 'outputs.GetGatewayPluginResponseTransformerConfigAddResult':
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def append(self) -> 'outputs.GetGatewayPluginResponseTransformerConfigAppendResult':
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def remove(self) -> 'outputs.GetGatewayPluginResponseTransformerConfigRemoveResult':
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def rename(self) -> 'outputs.GetGatewayPluginResponseTransformerConfigRenameResult':
        return pulumi.get(self, "rename")

    @property
    @pulumi.getter
    def replace(self) -> 'outputs.GetGatewayPluginResponseTransformerConfigReplaceResult':
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigAddResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigAppendResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigRemoveResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 jsons: Sequence[str]):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigRenameResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str]):
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConfigReplaceResult(dict):
    def __init__(__self__, *,
                 headers: Sequence[str],
                 json_types: Sequence[str],
                 jsons: Sequence[str]):
        """
        :param Sequence[str] json_types: List of JSON type names. Specify the types of the JSON values returned when appending
               JSON properties. Each string element can be one of: boolean, number, or string.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "json_types", json_types)
        pulumi.set(__self__, "jsons", jsons)

    @property
    @pulumi.getter
    def headers(self) -> Sequence[str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonTypes")
    def json_types(self) -> Sequence[str]:
        """
        List of JSON type names. Specify the types of the JSON values returned when appending
        JSON properties. Each string element can be one of: boolean, number, or string.
        """
        return pulumi.get(self, "json_types")

    @property
    @pulumi.getter
    def jsons(self) -> Sequence[str]:
        return pulumi.get(self, "jsons")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginResponseTransformerServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginSamlConfigResult(dict):
    def __init__(__self__, *,
                 anonymous: str,
                 assertion_consumer_path: str,
                 idp_certificate: str,
                 idp_sso_url: str,
                 issuer: str,
                 nameid_format: str,
                 request_digest_algorithm: str,
                 request_signature_algorithm: str,
                 request_signing_certificate: str,
                 request_signing_key: str,
                 response_digest_algorithm: str,
                 response_encryption_key: str,
                 response_signature_algorithm: str,
                 session_absolute_timeout: float,
                 session_audience: str,
                 session_cookie_domain: str,
                 session_cookie_http_only: bool,
                 session_cookie_name: str,
                 session_cookie_path: str,
                 session_cookie_same_site: str,
                 session_cookie_secure: bool,
                 session_enforce_same_subject: bool,
                 session_hash_storage_key: bool,
                 session_hash_subject: bool,
                 session_idling_timeout: float,
                 session_memcached_host: str,
                 session_memcached_port: int,
                 session_memcached_prefix: str,
                 session_memcached_socket: str,
                 session_redis_cluster_max_redirections: int,
                 session_redis_cluster_nodes: Sequence['outputs.GetGatewayPluginSamlConfigSessionRedisClusterNodeResult'],
                 session_redis_connect_timeout: int,
                 session_redis_host: str,
                 session_redis_password: str,
                 session_redis_port: int,
                 session_redis_prefix: str,
                 session_redis_read_timeout: int,
                 session_redis_send_timeout: int,
                 session_redis_server_name: str,
                 session_redis_socket: str,
                 session_redis_ssl: bool,
                 session_redis_ssl_verify: bool,
                 session_redis_username: str,
                 session_remember: bool,
                 session_remember_absolute_timeout: float,
                 session_remember_cookie_name: str,
                 session_remember_rolling_timeout: float,
                 session_request_headers: Sequence[str],
                 session_response_headers: Sequence[str],
                 session_rolling_timeout: float,
                 session_secret: str,
                 session_storage: str,
                 session_store_metadata: bool,
                 validate_assertion_signature: bool):
        """
        :param str anonymous: An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
        :param str assertion_consumer_path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str idp_certificate: The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
        :param str idp_sso_url: A string representing a URL, such as https://example.com/path/to/resource?q=search.
        :param str issuer: The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
        :param str nameid_format: The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
        :param str request_digest_algorithm: The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        :param str request_signature_algorithm: The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        :param str request_signing_certificate: The certificate for signing requests.
        :param str request_signing_key: The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `request_signing_certificate` parameter must be set as well.
        :param str response_digest_algorithm: The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        :param str response_encryption_key: The private encryption key required to decrypt encrypted assertions.
        :param str response_signature_algorithm: The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        :param float session_absolute_timeout: The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        :param str session_audience: The session audience, for example "my-application"
        :param str session_cookie_domain: The session cookie domain flag.
        :param bool session_cookie_http_only: Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        :param str session_cookie_name: The session cookie name.
        :param str session_cookie_path: A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        :param str session_cookie_same_site: Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        :param bool session_cookie_secure: The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        :param bool session_enforce_same_subject: When set to `true`, audiences are forced to share the same subject.
        :param bool session_hash_storage_key: When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        :param bool session_hash_subject: When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        :param float session_idling_timeout: The session cookie idle time in seconds.
        :param str session_memcached_host: The memcached host.
        :param int session_memcached_port: An integer representing a port number between 0 and 65535, inclusive.
        :param str session_memcached_prefix: The memcached session key prefix.
        :param str session_memcached_socket: The memcached unix socket path.
        :param int session_redis_cluster_max_redirections: The Redis cluster maximum redirects.
        :param Sequence['GetGatewayPluginSamlConfigSessionRedisClusterNodeArgs'] session_redis_cluster_nodes: The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        :param int session_redis_connect_timeout: The Redis connection timeout in milliseconds.
        :param str session_redis_host: The Redis host IP.
        :param str session_redis_password: Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
        :param int session_redis_port: An integer representing a port number between 0 and 65535, inclusive.
        :param str session_redis_prefix: The Redis session key prefix.
        :param int session_redis_read_timeout: The Redis read timeout in milliseconds.
        :param int session_redis_send_timeout: The Redis send timeout in milliseconds.
        :param str session_redis_server_name: The SNI used for connecting to the Redis server.
        :param str session_redis_socket: The Redis unix socket path.
        :param bool session_redis_ssl: Use SSL/TLS for the Redis connection.
        :param bool session_redis_ssl_verify: Verify the Redis server certificate.
        :param str session_redis_username: Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
        :param bool session_remember: Enables or disables persistent sessions
        :param float session_remember_absolute_timeout: Persistent session absolute timeout in seconds.
        :param str session_remember_cookie_name: Persistent session cookie name
        :param float session_remember_rolling_timeout: Persistent session rolling timeout in seconds.
        :param float session_rolling_timeout: The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        :param str session_secret: The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
        :param str session_storage: The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        :param bool session_store_metadata: Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specific_audience` belonging to a specific subject.
        :param bool validate_assertion_signature: Enable signature validation for SAML responses.
        """
        pulumi.set(__self__, "anonymous", anonymous)
        pulumi.set(__self__, "assertion_consumer_path", assertion_consumer_path)
        pulumi.set(__self__, "idp_certificate", idp_certificate)
        pulumi.set(__self__, "idp_sso_url", idp_sso_url)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "nameid_format", nameid_format)
        pulumi.set(__self__, "request_digest_algorithm", request_digest_algorithm)
        pulumi.set(__self__, "request_signature_algorithm", request_signature_algorithm)
        pulumi.set(__self__, "request_signing_certificate", request_signing_certificate)
        pulumi.set(__self__, "request_signing_key", request_signing_key)
        pulumi.set(__self__, "response_digest_algorithm", response_digest_algorithm)
        pulumi.set(__self__, "response_encryption_key", response_encryption_key)
        pulumi.set(__self__, "response_signature_algorithm", response_signature_algorithm)
        pulumi.set(__self__, "session_absolute_timeout", session_absolute_timeout)
        pulumi.set(__self__, "session_audience", session_audience)
        pulumi.set(__self__, "session_cookie_domain", session_cookie_domain)
        pulumi.set(__self__, "session_cookie_http_only", session_cookie_http_only)
        pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        pulumi.set(__self__, "session_cookie_path", session_cookie_path)
        pulumi.set(__self__, "session_cookie_same_site", session_cookie_same_site)
        pulumi.set(__self__, "session_cookie_secure", session_cookie_secure)
        pulumi.set(__self__, "session_enforce_same_subject", session_enforce_same_subject)
        pulumi.set(__self__, "session_hash_storage_key", session_hash_storage_key)
        pulumi.set(__self__, "session_hash_subject", session_hash_subject)
        pulumi.set(__self__, "session_idling_timeout", session_idling_timeout)
        pulumi.set(__self__, "session_memcached_host", session_memcached_host)
        pulumi.set(__self__, "session_memcached_port", session_memcached_port)
        pulumi.set(__self__, "session_memcached_prefix", session_memcached_prefix)
        pulumi.set(__self__, "session_memcached_socket", session_memcached_socket)
        pulumi.set(__self__, "session_redis_cluster_max_redirections", session_redis_cluster_max_redirections)
        pulumi.set(__self__, "session_redis_cluster_nodes", session_redis_cluster_nodes)
        pulumi.set(__self__, "session_redis_connect_timeout", session_redis_connect_timeout)
        pulumi.set(__self__, "session_redis_host", session_redis_host)
        pulumi.set(__self__, "session_redis_password", session_redis_password)
        pulumi.set(__self__, "session_redis_port", session_redis_port)
        pulumi.set(__self__, "session_redis_prefix", session_redis_prefix)
        pulumi.set(__self__, "session_redis_read_timeout", session_redis_read_timeout)
        pulumi.set(__self__, "session_redis_send_timeout", session_redis_send_timeout)
        pulumi.set(__self__, "session_redis_server_name", session_redis_server_name)
        pulumi.set(__self__, "session_redis_socket", session_redis_socket)
        pulumi.set(__self__, "session_redis_ssl", session_redis_ssl)
        pulumi.set(__self__, "session_redis_ssl_verify", session_redis_ssl_verify)
        pulumi.set(__self__, "session_redis_username", session_redis_username)
        pulumi.set(__self__, "session_remember", session_remember)
        pulumi.set(__self__, "session_remember_absolute_timeout", session_remember_absolute_timeout)
        pulumi.set(__self__, "session_remember_cookie_name", session_remember_cookie_name)
        pulumi.set(__self__, "session_remember_rolling_timeout", session_remember_rolling_timeout)
        pulumi.set(__self__, "session_request_headers", session_request_headers)
        pulumi.set(__self__, "session_response_headers", session_response_headers)
        pulumi.set(__self__, "session_rolling_timeout", session_rolling_timeout)
        pulumi.set(__self__, "session_secret", session_secret)
        pulumi.set(__self__, "session_storage", session_storage)
        pulumi.set(__self__, "session_store_metadata", session_store_metadata)
        pulumi.set(__self__, "validate_assertion_signature", validate_assertion_signature)

    @property
    @pulumi.getter
    def anonymous(self) -> str:
        """
        An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
        """
        return pulumi.get(self, "anonymous")

    @property
    @pulumi.getter(name="assertionConsumerPath")
    def assertion_consumer_path(self) -> str:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "assertion_consumer_path")

    @property
    @pulumi.getter(name="idpCertificate")
    def idp_certificate(self) -> str:
        """
        The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
        """
        return pulumi.get(self, "idp_certificate")

    @property
    @pulumi.getter(name="idpSsoUrl")
    def idp_sso_url(self) -> str:
        """
        A string representing a URL, such as https://example.com/path/to/resource?q=search.
        """
        return pulumi.get(self, "idp_sso_url")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="nameidFormat")
    def nameid_format(self) -> str:
        """
        The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
        """
        return pulumi.get(self, "nameid_format")

    @property
    @pulumi.getter(name="requestDigestAlgorithm")
    def request_digest_algorithm(self) -> str:
        """
        The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        """
        return pulumi.get(self, "request_digest_algorithm")

    @property
    @pulumi.getter(name="requestSignatureAlgorithm")
    def request_signature_algorithm(self) -> str:
        """
        The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        """
        return pulumi.get(self, "request_signature_algorithm")

    @property
    @pulumi.getter(name="requestSigningCertificate")
    def request_signing_certificate(self) -> str:
        """
        The certificate for signing requests.
        """
        return pulumi.get(self, "request_signing_certificate")

    @property
    @pulumi.getter(name="requestSigningKey")
    def request_signing_key(self) -> str:
        """
        The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `request_signing_certificate` parameter must be set as well.
        """
        return pulumi.get(self, "request_signing_key")

    @property
    @pulumi.getter(name="responseDigestAlgorithm")
    def response_digest_algorithm(self) -> str:
        """
        The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        """
        return pulumi.get(self, "response_digest_algorithm")

    @property
    @pulumi.getter(name="responseEncryptionKey")
    def response_encryption_key(self) -> str:
        """
        The private encryption key required to decrypt encrypted assertions.
        """
        return pulumi.get(self, "response_encryption_key")

    @property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> str:
        """
        The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        """
        return pulumi.get(self, "response_signature_algorithm")

    @property
    @pulumi.getter(name="sessionAbsoluteTimeout")
    def session_absolute_timeout(self) -> float:
        """
        The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        """
        return pulumi.get(self, "session_absolute_timeout")

    @property
    @pulumi.getter(name="sessionAudience")
    def session_audience(self) -> str:
        """
        The session audience, for example "my-application"
        """
        return pulumi.get(self, "session_audience")

    @property
    @pulumi.getter(name="sessionCookieDomain")
    def session_cookie_domain(self) -> str:
        """
        The session cookie domain flag.
        """
        return pulumi.get(self, "session_cookie_domain")

    @property
    @pulumi.getter(name="sessionCookieHttpOnly")
    def session_cookie_http_only(self) -> bool:
        """
        Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        """
        return pulumi.get(self, "session_cookie_http_only")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> str:
        """
        The session cookie name.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionCookiePath")
    def session_cookie_path(self) -> str:
        """
        A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        """
        return pulumi.get(self, "session_cookie_path")

    @property
    @pulumi.getter(name="sessionCookieSameSite")
    def session_cookie_same_site(self) -> str:
        """
        Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        """
        return pulumi.get(self, "session_cookie_same_site")

    @property
    @pulumi.getter(name="sessionCookieSecure")
    def session_cookie_secure(self) -> bool:
        """
        The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        """
        return pulumi.get(self, "session_cookie_secure")

    @property
    @pulumi.getter(name="sessionEnforceSameSubject")
    def session_enforce_same_subject(self) -> bool:
        """
        When set to `true`, audiences are forced to share the same subject.
        """
        return pulumi.get(self, "session_enforce_same_subject")

    @property
    @pulumi.getter(name="sessionHashStorageKey")
    def session_hash_storage_key(self) -> bool:
        """
        When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        """
        return pulumi.get(self, "session_hash_storage_key")

    @property
    @pulumi.getter(name="sessionHashSubject")
    def session_hash_subject(self) -> bool:
        """
        When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        """
        return pulumi.get(self, "session_hash_subject")

    @property
    @pulumi.getter(name="sessionIdlingTimeout")
    def session_idling_timeout(self) -> float:
        """
        The session cookie idle time in seconds.
        """
        return pulumi.get(self, "session_idling_timeout")

    @property
    @pulumi.getter(name="sessionMemcachedHost")
    def session_memcached_host(self) -> str:
        """
        The memcached host.
        """
        return pulumi.get(self, "session_memcached_host")

    @property
    @pulumi.getter(name="sessionMemcachedPort")
    def session_memcached_port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "session_memcached_port")

    @property
    @pulumi.getter(name="sessionMemcachedPrefix")
    def session_memcached_prefix(self) -> str:
        """
        The memcached session key prefix.
        """
        return pulumi.get(self, "session_memcached_prefix")

    @property
    @pulumi.getter(name="sessionMemcachedSocket")
    def session_memcached_socket(self) -> str:
        """
        The memcached unix socket path.
        """
        return pulumi.get(self, "session_memcached_socket")

    @property
    @pulumi.getter(name="sessionRedisClusterMaxRedirections")
    def session_redis_cluster_max_redirections(self) -> int:
        """
        The Redis cluster maximum redirects.
        """
        return pulumi.get(self, "session_redis_cluster_max_redirections")

    @property
    @pulumi.getter(name="sessionRedisClusterNodes")
    def session_redis_cluster_nodes(self) -> Sequence['outputs.GetGatewayPluginSamlConfigSessionRedisClusterNodeResult']:
        """
        The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        """
        return pulumi.get(self, "session_redis_cluster_nodes")

    @property
    @pulumi.getter(name="sessionRedisConnectTimeout")
    def session_redis_connect_timeout(self) -> int:
        """
        The Redis connection timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_connect_timeout")

    @property
    @pulumi.getter(name="sessionRedisHost")
    def session_redis_host(self) -> str:
        """
        The Redis host IP.
        """
        return pulumi.get(self, "session_redis_host")

    @property
    @pulumi.getter(name="sessionRedisPassword")
    def session_redis_password(self) -> str:
        """
        Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
        """
        return pulumi.get(self, "session_redis_password")

    @property
    @pulumi.getter(name="sessionRedisPort")
    def session_redis_port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "session_redis_port")

    @property
    @pulumi.getter(name="sessionRedisPrefix")
    def session_redis_prefix(self) -> str:
        """
        The Redis session key prefix.
        """
        return pulumi.get(self, "session_redis_prefix")

    @property
    @pulumi.getter(name="sessionRedisReadTimeout")
    def session_redis_read_timeout(self) -> int:
        """
        The Redis read timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_read_timeout")

    @property
    @pulumi.getter(name="sessionRedisSendTimeout")
    def session_redis_send_timeout(self) -> int:
        """
        The Redis send timeout in milliseconds.
        """
        return pulumi.get(self, "session_redis_send_timeout")

    @property
    @pulumi.getter(name="sessionRedisServerName")
    def session_redis_server_name(self) -> str:
        """
        The SNI used for connecting to the Redis server.
        """
        return pulumi.get(self, "session_redis_server_name")

    @property
    @pulumi.getter(name="sessionRedisSocket")
    def session_redis_socket(self) -> str:
        """
        The Redis unix socket path.
        """
        return pulumi.get(self, "session_redis_socket")

    @property
    @pulumi.getter(name="sessionRedisSsl")
    def session_redis_ssl(self) -> bool:
        """
        Use SSL/TLS for the Redis connection.
        """
        return pulumi.get(self, "session_redis_ssl")

    @property
    @pulumi.getter(name="sessionRedisSslVerify")
    def session_redis_ssl_verify(self) -> bool:
        """
        Verify the Redis server certificate.
        """
        return pulumi.get(self, "session_redis_ssl_verify")

    @property
    @pulumi.getter(name="sessionRedisUsername")
    def session_redis_username(self) -> str:
        """
        Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
        """
        return pulumi.get(self, "session_redis_username")

    @property
    @pulumi.getter(name="sessionRemember")
    def session_remember(self) -> bool:
        """
        Enables or disables persistent sessions
        """
        return pulumi.get(self, "session_remember")

    @property
    @pulumi.getter(name="sessionRememberAbsoluteTimeout")
    def session_remember_absolute_timeout(self) -> float:
        """
        Persistent session absolute timeout in seconds.
        """
        return pulumi.get(self, "session_remember_absolute_timeout")

    @property
    @pulumi.getter(name="sessionRememberCookieName")
    def session_remember_cookie_name(self) -> str:
        """
        Persistent session cookie name
        """
        return pulumi.get(self, "session_remember_cookie_name")

    @property
    @pulumi.getter(name="sessionRememberRollingTimeout")
    def session_remember_rolling_timeout(self) -> float:
        """
        Persistent session rolling timeout in seconds.
        """
        return pulumi.get(self, "session_remember_rolling_timeout")

    @property
    @pulumi.getter(name="sessionRequestHeaders")
    def session_request_headers(self) -> Sequence[str]:
        return pulumi.get(self, "session_request_headers")

    @property
    @pulumi.getter(name="sessionResponseHeaders")
    def session_response_headers(self) -> Sequence[str]:
        return pulumi.get(self, "session_response_headers")

    @property
    @pulumi.getter(name="sessionRollingTimeout")
    def session_rolling_timeout(self) -> float:
        """
        The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        """
        return pulumi.get(self, "session_rolling_timeout")

    @property
    @pulumi.getter(name="sessionSecret")
    def session_secret(self) -> str:
        """
        The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
        """
        return pulumi.get(self, "session_secret")

    @property
    @pulumi.getter(name="sessionStorage")
    def session_storage(self) -> str:
        """
        The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        """
        return pulumi.get(self, "session_storage")

    @property
    @pulumi.getter(name="sessionStoreMetadata")
    def session_store_metadata(self) -> bool:
        """
        Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specific_audience` belonging to a specific subject.
        """
        return pulumi.get(self, "session_store_metadata")

    @property
    @pulumi.getter(name="validateAssertionSignature")
    def validate_assertion_signature(self) -> bool:
        """
        Enable signature validation for SAML responses.
        """
        return pulumi.get(self, "validate_assertion_signature")


@pulumi.output_type
class GetGatewayPluginSamlConfigSessionRedisClusterNodeResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        """
        :param str ip: A string representing a host name, such as example.com.
        :param int port: An integer representing a port number between 0 and 65535, inclusive.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        A string representing a host name, such as example.com.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        An integer representing a port number between 0 and 65535, inclusive.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetGatewayPluginSamlConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginSamlConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginSamlRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginSamlServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginStatsdConfigResult(dict):
    def __init__(__self__, *,
                 allow_status_codes: Sequence[str],
                 consumer_identifier_default: str,
                 flush_timeout: float,
                 host: str,
                 hostname_in_prefix: bool,
                 metrics: Sequence['outputs.GetGatewayPluginStatsdConfigMetricResult'],
                 port: int,
                 prefix: str,
                 queue: 'outputs.GetGatewayPluginStatsdConfigQueueResult',
                 queue_size: int,
                 retry_count: int,
                 service_identifier_default: str,
                 tag_style: str,
                 udp_packet_size: float,
                 use_tcp: bool,
                 workspace_identifier_default: str):
        """
        :param Sequence[str] allow_status_codes: List of status code ranges that are allowed to be logged in metrics.
        :param str consumer_identifier_default: must be one of ["consumer_id", "custom_id", "username"]
        :param str host: The IP address or hostname of StatsD server to send data to.
        :param Sequence['GetGatewayPluginStatsdConfigMetricArgs'] metrics: List of metrics to be logged.
        :param int port: The port of StatsD server to send data to.
        :param str prefix: String to prefix to each metric's name.
        :param str service_identifier_default: must be one of ["service_id", "service_name", "service_host", "service_name_or_host"]
        :param str tag_style: must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
        :param str workspace_identifier_default: must be one of ["workspace_id", "workspace_name"]
        """
        pulumi.set(__self__, "allow_status_codes", allow_status_codes)
        pulumi.set(__self__, "consumer_identifier_default", consumer_identifier_default)
        pulumi.set(__self__, "flush_timeout", flush_timeout)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "hostname_in_prefix", hostname_in_prefix)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "queue", queue)
        pulumi.set(__self__, "queue_size", queue_size)
        pulumi.set(__self__, "retry_count", retry_count)
        pulumi.set(__self__, "service_identifier_default", service_identifier_default)
        pulumi.set(__self__, "tag_style", tag_style)
        pulumi.set(__self__, "udp_packet_size", udp_packet_size)
        pulumi.set(__self__, "use_tcp", use_tcp)
        pulumi.set(__self__, "workspace_identifier_default", workspace_identifier_default)

    @property
    @pulumi.getter(name="allowStatusCodes")
    def allow_status_codes(self) -> Sequence[str]:
        """
        List of status code ranges that are allowed to be logged in metrics.
        """
        return pulumi.get(self, "allow_status_codes")

    @property
    @pulumi.getter(name="consumerIdentifierDefault")
    def consumer_identifier_default(self) -> str:
        """
        must be one of ["consumer_id", "custom_id", "username"]
        """
        return pulumi.get(self, "consumer_identifier_default")

    @property
    @pulumi.getter(name="flushTimeout")
    def flush_timeout(self) -> float:
        return pulumi.get(self, "flush_timeout")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The IP address or hostname of StatsD server to send data to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="hostnameInPrefix")
    def hostname_in_prefix(self) -> bool:
        return pulumi.get(self, "hostname_in_prefix")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetGatewayPluginStatsdConfigMetricResult']:
        """
        List of metrics to be logged.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of StatsD server to send data to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        String to prefix to each metric's name.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def queue(self) -> 'outputs.GetGatewayPluginStatsdConfigQueueResult':
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> int:
        return pulumi.get(self, "queue_size")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> int:
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="serviceIdentifierDefault")
    def service_identifier_default(self) -> str:
        """
        must be one of ["service_id", "service_name", "service_host", "service_name_or_host"]
        """
        return pulumi.get(self, "service_identifier_default")

    @property
    @pulumi.getter(name="tagStyle")
    def tag_style(self) -> str:
        """
        must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
        """
        return pulumi.get(self, "tag_style")

    @property
    @pulumi.getter(name="udpPacketSize")
    def udp_packet_size(self) -> float:
        return pulumi.get(self, "udp_packet_size")

    @property
    @pulumi.getter(name="useTcp")
    def use_tcp(self) -> bool:
        return pulumi.get(self, "use_tcp")

    @property
    @pulumi.getter(name="workspaceIdentifierDefault")
    def workspace_identifier_default(self) -> str:
        """
        must be one of ["workspace_id", "workspace_name"]
        """
        return pulumi.get(self, "workspace_identifier_default")


@pulumi.output_type
class GetGatewayPluginStatsdConfigMetricResult(dict):
    def __init__(__self__, *,
                 consumer_identifier: str,
                 name: str,
                 sample_rate: float,
                 service_identifier: str,
                 stat_type: str,
                 workspace_identifier: str):
        """
        :param str consumer_identifier: Authenticated user detail. must be one of ["consumer_id", "custom_id", "username"]
        :param str name: StatsD metric’s name. must be one of ["kong_latency", "latency", "request_count", "request_per_user", "request_size", "response_size", "status_count", "status_count_per_user", "unique_users", "upstream_latency", "status_count_per_workspace", "status_count_per_user_per_route", "shdict_usage", "cache_datastore_hits_total", "cache_datastore_misses_total"]
        :param float sample_rate: Sampling rate
        :param str service_identifier: Service detail. must be one of ["service_id", "service_name", "service_host", "service_name_or_host"]
        :param str stat_type: Determines what sort of event a metric represents. must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
        :param str workspace_identifier: Workspace detail. must be one of ["workspace_id", "workspace_name"]
        """
        pulumi.set(__self__, "consumer_identifier", consumer_identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sample_rate", sample_rate)
        pulumi.set(__self__, "service_identifier", service_identifier)
        pulumi.set(__self__, "stat_type", stat_type)
        pulumi.set(__self__, "workspace_identifier", workspace_identifier)

    @property
    @pulumi.getter(name="consumerIdentifier")
    def consumer_identifier(self) -> str:
        """
        Authenticated user detail. must be one of ["consumer_id", "custom_id", "username"]
        """
        return pulumi.get(self, "consumer_identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        StatsD metric’s name. must be one of ["kong_latency", "latency", "request_count", "request_per_user", "request_size", "response_size", "status_count", "status_count_per_user", "unique_users", "upstream_latency", "status_count_per_workspace", "status_count_per_user_per_route", "shdict_usage", "cache_datastore_hits_total", "cache_datastore_misses_total"]
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        """
        Sampling rate
        """
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter(name="serviceIdentifier")
    def service_identifier(self) -> str:
        """
        Service detail. must be one of ["service_id", "service_name", "service_host", "service_name_or_host"]
        """
        return pulumi.get(self, "service_identifier")

    @property
    @pulumi.getter(name="statType")
    def stat_type(self) -> str:
        """
        Determines what sort of event a metric represents. must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
        """
        return pulumi.get(self, "stat_type")

    @property
    @pulumi.getter(name="workspaceIdentifier")
    def workspace_identifier(self) -> str:
        """
        Workspace detail. must be one of ["workspace_id", "workspace_name"]
        """
        return pulumi.get(self, "workspace_identifier")


@pulumi.output_type
class GetGatewayPluginStatsdConfigQueueResult(dict):
    def __init__(__self__, *,
                 initial_retry_delay: float,
                 max_batch_size: int,
                 max_bytes: int,
                 max_coalescing_delay: float,
                 max_entries: int,
                 max_retry_delay: float,
                 max_retry_time: float):
        """
        :param float initial_retry_delay: Time in seconds before the initial retry is made for a failing batch.
        :param int max_batch_size: Maximum number of entries that can be processed at a time.
        :param int max_bytes: Maximum number of bytes that can be waiting on a queue, requires string content.
        :param float max_coalescing_delay: Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        :param int max_entries: Maximum number of entries that can be waiting on the queue.
        :param float max_retry_delay: Maximum time in seconds between retries, caps exponential backoff.
        :param float max_retry_time: Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        pulumi.set(__self__, "initial_retry_delay", initial_retry_delay)
        pulumi.set(__self__, "max_batch_size", max_batch_size)
        pulumi.set(__self__, "max_bytes", max_bytes)
        pulumi.set(__self__, "max_coalescing_delay", max_coalescing_delay)
        pulumi.set(__self__, "max_entries", max_entries)
        pulumi.set(__self__, "max_retry_delay", max_retry_delay)
        pulumi.set(__self__, "max_retry_time", max_retry_time)

    @property
    @pulumi.getter(name="initialRetryDelay")
    def initial_retry_delay(self) -> float:
        """
        Time in seconds before the initial retry is made for a failing batch.
        """
        return pulumi.get(self, "initial_retry_delay")

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> int:
        """
        Maximum number of entries that can be processed at a time.
        """
        return pulumi.get(self, "max_batch_size")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> int:
        """
        Maximum number of bytes that can be waiting on a queue, requires string content.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxCoalescingDelay")
    def max_coalescing_delay(self) -> float:
        """
        Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
        """
        return pulumi.get(self, "max_coalescing_delay")

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> int:
        """
        Maximum number of entries that can be waiting on the queue.
        """
        return pulumi.get(self, "max_entries")

    @property
    @pulumi.getter(name="maxRetryDelay")
    def max_retry_delay(self) -> float:
        """
        Maximum time in seconds between retries, caps exponential backoff.
        """
        return pulumi.get(self, "max_retry_delay")

    @property
    @pulumi.getter(name="maxRetryTime")
    def max_retry_time(self) -> float:
        """
        Time in seconds before the queue gives up calling a failed handler for a batch.
        """
        return pulumi.get(self, "max_retry_time")


@pulumi.output_type
class GetGatewayPluginStatsdConsumerResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginStatsdConsumerGroupResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginStatsdRouteResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayPluginStatsdServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayRouteDestinationResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetGatewayRouteServiceResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayRouteSourceResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 port: int):
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetGatewayServiceClientCertificateResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewaySniCertificateResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayTargetUpstreamResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayUpstreamClientCertificateResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksResult(dict):
    def __init__(__self__, *,
                 active: 'outputs.GetGatewayUpstreamHealthchecksActiveResult',
                 passive: 'outputs.GetGatewayUpstreamHealthchecksPassiveResult',
                 threshold: float):
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "passive", passive)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def active(self) -> 'outputs.GetGatewayUpstreamHealthchecksActiveResult':
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def passive(self) -> 'outputs.GetGatewayUpstreamHealthchecksPassiveResult':
        return pulumi.get(self, "passive")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksActiveResult(dict):
    def __init__(__self__, *,
                 concurrency: int,
                 headers: Mapping[str, str],
                 healthy: 'outputs.GetGatewayUpstreamHealthchecksActiveHealthyResult',
                 http_path: str,
                 https_sni: str,
                 https_verify_certificate: bool,
                 timeout: float,
                 type: str,
                 unhealthy: 'outputs.GetGatewayUpstreamHealthchecksActiveUnhealthyResult'):
        """
        :param str type: must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        pulumi.set(__self__, "concurrency", concurrency)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "healthy", healthy)
        pulumi.set(__self__, "http_path", http_path)
        pulumi.set(__self__, "https_sni", https_sni)
        pulumi.set(__self__, "https_verify_certificate", https_verify_certificate)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter
    def concurrency(self) -> int:
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def healthy(self) -> 'outputs.GetGatewayUpstreamHealthchecksActiveHealthyResult':
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> str:
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter(name="httpsSni")
    def https_sni(self) -> str:
        return pulumi.get(self, "https_sni")

    @property
    @pulumi.getter(name="httpsVerifyCertificate")
    def https_verify_certificate(self) -> bool:
        return pulumi.get(self, "https_verify_certificate")

    @property
    @pulumi.getter
    def timeout(self) -> float:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unhealthy(self) -> 'outputs.GetGatewayUpstreamHealthchecksActiveUnhealthyResult':
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksActiveHealthyResult(dict):
    def __init__(__self__, *,
                 http_statuses: Sequence[int],
                 interval: float,
                 successes: int):
        pulumi.set(__self__, "http_statuses", http_statuses)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "successes", successes)

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Sequence[int]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def interval(self) -> float:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def successes(self) -> int:
        return pulumi.get(self, "successes")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksActiveUnhealthyResult(dict):
    def __init__(__self__, *,
                 http_failures: int,
                 http_statuses: Sequence[int],
                 interval: float,
                 tcp_failures: int,
                 timeouts: int):
        pulumi.set(__self__, "http_failures", http_failures)
        pulumi.set(__self__, "http_statuses", http_statuses)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "tcp_failures", tcp_failures)
        pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="httpFailures")
    def http_failures(self) -> int:
        return pulumi.get(self, "http_failures")

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Sequence[int]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def interval(self) -> float:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="tcpFailures")
    def tcp_failures(self) -> int:
        return pulumi.get(self, "tcp_failures")

    @property
    @pulumi.getter
    def timeouts(self) -> int:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksPassiveResult(dict):
    def __init__(__self__, *,
                 healthy: 'outputs.GetGatewayUpstreamHealthchecksPassiveHealthyResult',
                 type: str,
                 unhealthy: 'outputs.GetGatewayUpstreamHealthchecksPassiveUnhealthyResult'):
        """
        :param str type: must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        pulumi.set(__self__, "healthy", healthy)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter
    def healthy(self) -> 'outputs.GetGatewayUpstreamHealthchecksPassiveHealthyResult':
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        must be one of ["tcp", "http", "https", "grpc", "grpcs"]
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unhealthy(self) -> 'outputs.GetGatewayUpstreamHealthchecksPassiveUnhealthyResult':
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksPassiveHealthyResult(dict):
    def __init__(__self__, *,
                 http_statuses: Sequence[int],
                 successes: int):
        pulumi.set(__self__, "http_statuses", http_statuses)
        pulumi.set(__self__, "successes", successes)

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Sequence[int]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter
    def successes(self) -> int:
        return pulumi.get(self, "successes")


@pulumi.output_type
class GetGatewayUpstreamHealthchecksPassiveUnhealthyResult(dict):
    def __init__(__self__, *,
                 http_failures: int,
                 http_statuses: Sequence[int],
                 tcp_failures: int,
                 timeouts: int):
        pulumi.set(__self__, "http_failures", http_failures)
        pulumi.set(__self__, "http_statuses", http_statuses)
        pulumi.set(__self__, "tcp_failures", tcp_failures)
        pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="httpFailures")
    def http_failures(self) -> int:
        return pulumi.get(self, "http_failures")

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Sequence[int]:
        return pulumi.get(self, "http_statuses")

    @property
    @pulumi.getter(name="tcpFailures")
    def tcp_failures(self) -> int:
        return pulumi.get(self, "tcp_failures")

    @property
    @pulumi.getter
    def timeouts(self) -> int:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class GetPortalAppearanceCustomFontsResult(dict):
    def __init__(__self__, *,
                 base: str,
                 code: str,
                 headings: str):
        """
        :param str base: The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        :param str code: The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        :param str headings: The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "headings", headings)

    @property
    @pulumi.getter
    def base(self) -> str:
        """
        The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def headings(self) -> str:
        """
        The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
        """
        return pulumi.get(self, "headings")


@pulumi.output_type
class GetPortalAppearanceCustomThemeResult(dict):
    def __init__(__self__, *,
                 colors: 'outputs.GetPortalAppearanceCustomThemeColorsResult'):
        pulumi.set(__self__, "colors", colors)

    @property
    @pulumi.getter
    def colors(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsResult':
        return pulumi.get(self, "colors")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsResult(dict):
    def __init__(__self__, *,
                 button: 'outputs.GetPortalAppearanceCustomThemeColorsButtonResult',
                 section: 'outputs.GetPortalAppearanceCustomThemeColorsSectionResult',
                 text: 'outputs.GetPortalAppearanceCustomThemeColorsTextResult'):
        pulumi.set(__self__, "button", button)
        pulumi.set(__self__, "section", section)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def button(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsButtonResult':
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def section(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionResult':
        return pulumi.get(self, "section")

    @property
    @pulumi.getter
    def text(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextResult':
        return pulumi.get(self, "text")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsButtonResult(dict):
    def __init__(__self__, *,
                 primary_fill: 'outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryFillResult',
                 primary_text: 'outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryTextResult'):
        pulumi.set(__self__, "primary_fill", primary_fill)
        pulumi.set(__self__, "primary_text", primary_text)

    @property
    @pulumi.getter(name="primaryFill")
    def primary_fill(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryFillResult':
        return pulumi.get(self, "primary_fill")

    @property
    @pulumi.getter(name="primaryText")
    def primary_text(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryTextResult':
        return pulumi.get(self, "primary_text")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsButtonPrimaryFillResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsButtonPrimaryTextResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionResult(dict):
    def __init__(__self__, *,
                 accent: 'outputs.GetPortalAppearanceCustomThemeColorsSectionAccentResult',
                 body: 'outputs.GetPortalAppearanceCustomThemeColorsSectionBodyResult',
                 footer: 'outputs.GetPortalAppearanceCustomThemeColorsSectionFooterResult',
                 header: 'outputs.GetPortalAppearanceCustomThemeColorsSectionHeaderResult',
                 hero: 'outputs.GetPortalAppearanceCustomThemeColorsSectionHeroResult',
                 stroke: 'outputs.GetPortalAppearanceCustomThemeColorsSectionStrokeResult',
                 tertiary: 'outputs.GetPortalAppearanceCustomThemeColorsSectionTertiaryResult'):
        pulumi.set(__self__, "accent", accent)
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "footer", footer)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "hero", hero)
        pulumi.set(__self__, "stroke", stroke)
        pulumi.set(__self__, "tertiary", tertiary)

    @property
    @pulumi.getter
    def accent(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionAccentResult':
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter
    def body(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionBodyResult':
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def footer(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionFooterResult':
        return pulumi.get(self, "footer")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionHeaderResult':
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def hero(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionHeroResult':
        return pulumi.get(self, "hero")

    @property
    @pulumi.getter
    def stroke(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionStrokeResult':
        return pulumi.get(self, "stroke")

    @property
    @pulumi.getter
    def tertiary(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsSectionTertiaryResult':
        return pulumi.get(self, "tertiary")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionAccentResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionBodyResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionFooterResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionHeaderResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionHeroResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionStrokeResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsSectionTertiaryResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextResult(dict):
    def __init__(__self__, *,
                 accent: 'outputs.GetPortalAppearanceCustomThemeColorsTextAccentResult',
                 footer: 'outputs.GetPortalAppearanceCustomThemeColorsTextFooterResult',
                 header: 'outputs.GetPortalAppearanceCustomThemeColorsTextHeaderResult',
                 headings: 'outputs.GetPortalAppearanceCustomThemeColorsTextHeadingsResult',
                 hero: 'outputs.GetPortalAppearanceCustomThemeColorsTextHeroResult',
                 link: 'outputs.GetPortalAppearanceCustomThemeColorsTextLinkResult',
                 primary: 'outputs.GetPortalAppearanceCustomThemeColorsTextPrimaryResult',
                 secondary: 'outputs.GetPortalAppearanceCustomThemeColorsTextSecondaryResult'):
        pulumi.set(__self__, "accent", accent)
        pulumi.set(__self__, "footer", footer)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "headings", headings)
        pulumi.set(__self__, "hero", hero)
        pulumi.set(__self__, "link", link)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def accent(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextAccentResult':
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter
    def footer(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextFooterResult':
        return pulumi.get(self, "footer")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextHeaderResult':
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def headings(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextHeadingsResult':
        return pulumi.get(self, "headings")

    @property
    @pulumi.getter
    def hero(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextHeroResult':
        return pulumi.get(self, "hero")

    @property
    @pulumi.getter
    def link(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextLinkResult':
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def primary(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextPrimaryResult':
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter
    def secondary(self) -> 'outputs.GetPortalAppearanceCustomThemeColorsTextSecondaryResult':
        return pulumi.get(self, "secondary")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextAccentResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextFooterResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextHeaderResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextHeadingsResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextHeroResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextLinkResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextPrimaryResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceCustomThemeColorsTextSecondaryResult(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPortalAppearanceImagesResult(dict):
    def __init__(__self__, *,
                 catalog_cover: 'outputs.GetPortalAppearanceImagesCatalogCoverResult',
                 favicon: 'outputs.GetPortalAppearanceImagesFaviconResult',
                 logo: 'outputs.GetPortalAppearanceImagesLogoResult'):
        """
        :param 'GetPortalAppearanceImagesCatalogCoverArgs' catalog_cover: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        :param 'GetPortalAppearanceImagesFaviconArgs' favicon: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        :param 'GetPortalAppearanceImagesLogoArgs' logo: The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        """
        pulumi.set(__self__, "catalog_cover", catalog_cover)
        pulumi.set(__self__, "favicon", favicon)
        pulumi.set(__self__, "logo", logo)

    @property
    @pulumi.getter(name="catalogCover")
    def catalog_cover(self) -> 'outputs.GetPortalAppearanceImagesCatalogCoverResult':
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        """
        return pulumi.get(self, "catalog_cover")

    @property
    @pulumi.getter
    def favicon(self) -> 'outputs.GetPortalAppearanceImagesFaviconResult':
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        """
        return pulumi.get(self, "favicon")

    @property
    @pulumi.getter
    def logo(self) -> 'outputs.GetPortalAppearanceImagesLogoResult':
        """
        The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
        """
        return pulumi.get(self, "logo")


@pulumi.output_type
class GetPortalAppearanceImagesCatalogCoverResult(dict):
    def __init__(__self__, *,
                 data: str,
                 filename: str):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> str:
        return pulumi.get(self, "filename")


@pulumi.output_type
class GetPortalAppearanceImagesFaviconResult(dict):
    def __init__(__self__, *,
                 data: str,
                 filename: str):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> str:
        return pulumi.get(self, "filename")


@pulumi.output_type
class GetPortalAppearanceImagesLogoResult(dict):
    def __init__(__self__, *,
                 data: str,
                 filename: str):
        """
        :param str data: must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def filename(self) -> str:
        return pulumi.get(self, "filename")


@pulumi.output_type
class GetPortalAppearanceTextResult(dict):
    def __init__(__self__, *,
                 catalog: 'outputs.GetPortalAppearanceTextCatalogResult'):
        pulumi.set(__self__, "catalog", catalog)

    @property
    @pulumi.getter
    def catalog(self) -> 'outputs.GetPortalAppearanceTextCatalogResult':
        return pulumi.get(self, "catalog")


@pulumi.output_type
class GetPortalAppearanceTextCatalogResult(dict):
    def __init__(__self__, *,
                 primary_header: str,
                 welcome_message: str):
        pulumi.set(__self__, "primary_header", primary_header)
        pulumi.set(__self__, "welcome_message", welcome_message)

    @property
    @pulumi.getter(name="primaryHeader")
    def primary_header(self) -> str:
        return pulumi.get(self, "primary_header")

    @property
    @pulumi.getter(name="welcomeMessage")
    def welcome_message(self) -> str:
        return pulumi.get(self, "welcome_message")


@pulumi.output_type
class GetPortalAuthOidcConfigResult(dict):
    def __init__(__self__, *,
                 claim_mappings: 'outputs.GetPortalAuthOidcConfigClaimMappingsResult',
                 client_id: str,
                 issuer: str,
                 scopes: Sequence[str]):
        """
        :param 'GetPortalAuthOidcConfigClaimMappingsArgs' claim_mappings: Mappings from a portal developer atribute to an Identity Provider claim.
        """
        pulumi.set(__self__, "claim_mappings", claim_mappings)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="claimMappings")
    def claim_mappings(self) -> 'outputs.GetPortalAuthOidcConfigClaimMappingsResult':
        """
        Mappings from a portal developer atribute to an Identity Provider claim.
        """
        return pulumi.get(self, "claim_mappings")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetPortalAuthOidcConfigClaimMappingsResult(dict):
    def __init__(__self__, *,
                 email: str,
                 groups: str,
                 name: str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def groups(self) -> str:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPortalListDataResult(dict):
    def __init__(__self__, *,
                 application_count: float,
                 auto_approve_applications: bool,
                 auto_approve_developers: bool,
                 created_at: str,
                 custom_client_domain: str,
                 custom_domain: str,
                 default_application_auth_strategy_id: str,
                 default_domain: str,
                 description: str,
                 developer_count: float,
                 display_name: str,
                 id: str,
                 is_public: bool,
                 labels: Mapping[str, str],
                 name: str,
                 published_product_count: float,
                 rbac_enabled: bool,
                 updated_at: str):
        """
        :param float application_count: Number of applications created in the portal.
        :param bool auto_approve_applications: Whether the requests from applications to register for products will be automatically approved, or if they will be set to pending until approved by an admin.
        :param bool auto_approve_developers: Whether the developer account registrations will be automatically approved, or if they will be set to pending until approved by an admin.
        :param str created_at: An ISO-8601 timestamp representation of entity creation date.
        :param str custom_client_domain: The custom domain to access a self-hosted customized developer portal client. If this is set, the Konnect-hosted portal client will no longer be available. `custom_domain` must be also set for this value to be set. See https://github.com/Kong/konnect-portal for information on how to get started deploying and customizing your own Konnect portal.
        :param str custom_domain: The custom domain to access the developer portal. A CNAME for the portal's default domain must be able to be set for the custom domain for it to be valid. After setting a valid CNAME, an SSL/TLS certificate will be automatically manged for the custom domain, and traffic will be able to use the custom domain to route to the portal's web client and API.
        :param str default_application_auth_strategy_id: Default strategy ID applied on applications for the portal
        :param str default_domain: The domain assigned to the portal by Konnect. This is the default place to access the portal and its API if not using a `custom_domain``.
        :param str description: The description of the portal.
        :param float developer_count: Number of developers using the portal.
        :param str display_name: The display name of the portal. This value will be the portal's `name` in Portal API.
        :param str id: Contains a unique identifier used for this resource.
        :param bool is_public: Whether the portal catalog can be accessed publicly without any developer authentication. Developer accounts and applications cannot be created if the portal is public.
        :param Mapping[str, str] labels: Labels store metadata of an entity that can be used for filtering an entity list or for searching across entity types. 
               
               Keys must be of length 1-63 characters, and cannot start with "kong", "konnect", "mesh", "kic", or "_".
        :param str name: The name of the portal, used to distinguish it from other portals. Name must be unique.
        :param float published_product_count: Number of api products published to the portal
        :param bool rbac_enabled: Whether the portal resources are protected by Role Based Access Control (RBAC). If enabled, developers view or register for products until unless assigned to teams with access to view and consume specific products.
        :param str updated_at: An ISO-8601 timestamp representation of entity update date.
        """
        pulumi.set(__self__, "application_count", application_count)
        pulumi.set(__self__, "auto_approve_applications", auto_approve_applications)
        pulumi.set(__self__, "auto_approve_developers", auto_approve_developers)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_client_domain", custom_client_domain)
        pulumi.set(__self__, "custom_domain", custom_domain)
        pulumi.set(__self__, "default_application_auth_strategy_id", default_application_auth_strategy_id)
        pulumi.set(__self__, "default_domain", default_domain)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "developer_count", developer_count)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_public", is_public)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "published_product_count", published_product_count)
        pulumi.set(__self__, "rbac_enabled", rbac_enabled)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="applicationCount")
    def application_count(self) -> float:
        """
        Number of applications created in the portal.
        """
        return pulumi.get(self, "application_count")

    @property
    @pulumi.getter(name="autoApproveApplications")
    def auto_approve_applications(self) -> bool:
        """
        Whether the requests from applications to register for products will be automatically approved, or if they will be set to pending until approved by an admin.
        """
        return pulumi.get(self, "auto_approve_applications")

    @property
    @pulumi.getter(name="autoApproveDevelopers")
    def auto_approve_developers(self) -> bool:
        """
        Whether the developer account registrations will be automatically approved, or if they will be set to pending until approved by an admin.
        """
        return pulumi.get(self, "auto_approve_developers")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customClientDomain")
    def custom_client_domain(self) -> str:
        """
        The custom domain to access a self-hosted customized developer portal client. If this is set, the Konnect-hosted portal client will no longer be available. `custom_domain` must be also set for this value to be set. See https://github.com/Kong/konnect-portal for information on how to get started deploying and customizing your own Konnect portal.
        """
        return pulumi.get(self, "custom_client_domain")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> str:
        """
        The custom domain to access the developer portal. A CNAME for the portal's default domain must be able to be set for the custom domain for it to be valid. After setting a valid CNAME, an SSL/TLS certificate will be automatically manged for the custom domain, and traffic will be able to use the custom domain to route to the portal's web client and API.
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="defaultApplicationAuthStrategyId")
    def default_application_auth_strategy_id(self) -> str:
        """
        Default strategy ID applied on applications for the portal
        """
        return pulumi.get(self, "default_application_auth_strategy_id")

    @property
    @pulumi.getter(name="defaultDomain")
    def default_domain(self) -> str:
        """
        The domain assigned to the portal by Konnect. This is the default place to access the portal and its API if not using a `custom_domain``.
        """
        return pulumi.get(self, "default_domain")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the portal.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="developerCount")
    def developer_count(self) -> float:
        """
        Number of developers using the portal.
        """
        return pulumi.get(self, "developer_count")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the portal. This value will be the portal's `name` in Portal API.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Contains a unique identifier used for this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> bool:
        """
        Whether the portal catalog can be accessed publicly without any developer authentication. Developer accounts and applications cannot be created if the portal is public.
        """
        return pulumi.get(self, "is_public")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels store metadata of an entity that can be used for filtering an entity list or for searching across entity types. 

        Keys must be of length 1-63 characters, and cannot start with "kong", "konnect", "mesh", "kic", or "_".
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the portal, used to distinguish it from other portals. Name must be unique.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publishedProductCount")
    def published_product_count(self) -> float:
        """
        Number of api products published to the portal
        """
        return pulumi.get(self, "published_product_count")

    @property
    @pulumi.getter(name="rbacEnabled")
    def rbac_enabled(self) -> bool:
        """
        Whether the portal resources are protected by Role Based Access Control (RBAC). If enabled, developers view or register for products until unless assigned to teams with access to view and consume specific products.
        """
        return pulumi.get(self, "rbac_enabled")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        An ISO-8601 timestamp representation of entity update date.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetPortalListMetaResult(dict):
    def __init__(__self__, *,
                 page: 'outputs.GetPortalListMetaPageResult'):
        """
        :param 'GetPortalListMetaPageArgs' page: Contains pagination query parameters and the total number of objects returned.
        """
        pulumi.set(__self__, "page", page)

    @property
    @pulumi.getter
    def page(self) -> 'outputs.GetPortalListMetaPageResult':
        """
        Contains pagination query parameters and the total number of objects returned.
        """
        return pulumi.get(self, "page")


@pulumi.output_type
class GetPortalListMetaPageResult(dict):
    def __init__(__self__, *,
                 number: float,
                 size: float,
                 total: float):
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def number(self) -> float:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def total(self) -> float:
        return pulumi.get(self, "total")


@pulumi.output_type
class GetPortalProductVersionAuthStrategyResult(dict):
    def __init__(__self__, *,
                 client_credentials: 'outputs.GetPortalProductVersionAuthStrategyClientCredentialsResult',
                 key_auth: 'outputs.GetPortalProductVersionAuthStrategyKeyAuthResult'):
        """
        :param 'GetPortalProductVersionAuthStrategyClientCredentialsArgs' client_credentials: Client Credential Auth strategy that the application uses.
        :param 'GetPortalProductVersionAuthStrategyKeyAuthArgs' key_auth: KeyAuth Auth strategy that the application uses.
        """
        pulumi.set(__self__, "client_credentials", client_credentials)
        pulumi.set(__self__, "key_auth", key_auth)

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> 'outputs.GetPortalProductVersionAuthStrategyClientCredentialsResult':
        """
        Client Credential Auth strategy that the application uses.
        """
        return pulumi.get(self, "client_credentials")

    @property
    @pulumi.getter(name="keyAuth")
    def key_auth(self) -> 'outputs.GetPortalProductVersionAuthStrategyKeyAuthResult':
        """
        KeyAuth Auth strategy that the application uses.
        """
        return pulumi.get(self, "key_auth")


@pulumi.output_type
class GetPortalProductVersionAuthStrategyClientCredentialsResult(dict):
    def __init__(__self__, *,
                 auth_methods: Sequence[str],
                 credential_type: str,
                 id: str,
                 name: str):
        """
        :param str credential_type: must be one of ["client_credentials", "self_managed_client_credentials"]
        :param str id: The Application Auth Strategy ID.
        """
        pulumi.set(__self__, "auth_methods", auth_methods)
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authMethods")
    def auth_methods(self) -> Sequence[str]:
        return pulumi.get(self, "auth_methods")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        must be one of ["client_credentials", "self_managed_client_credentials"]
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Application Auth Strategy ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPortalProductVersionAuthStrategyKeyAuthResult(dict):
    def __init__(__self__, *,
                 credential_type: str,
                 id: str,
                 name: str):
        """
        :param str credential_type: must be one of ["key_auth"]
        :param str id: The Application Auth Strategy ID.
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        must be one of ["key_auth"]
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Application Auth Strategy ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServerlessCloudGatewayControlPlaneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 prefix: str,
                 region: str):
        """
        :param str id: ID of the serverless cloud gateway CP.
        :param str prefix: The prefix of the serverless cloud gateway CP.
        :param str region: The control plane region. must be one of ["us", "eu", "au"]
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the serverless cloud gateway CP.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The prefix of the serverless cloud gateway CP.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The control plane region. must be one of ["us", "eu", "au"]
        """
        return pulumi.get(self, "region")


