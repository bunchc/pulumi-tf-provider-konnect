// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApiProductDocumentMetadata {
}

export interface ApiProductPortal {
    portalId: string;
    portalName: string;
}

export interface ApiProductVersionGatewayService {
    /**
     * The identifier of the control plane that the gateway service resides in. Not Null
     */
    controlPlaneId: string;
    /**
     * The identifier of a gateway service associated with the version of the API product. Not Null
     */
    id: string;
    /**
     * This field is deprecated, please use `controlPlaneId` instead. The identifier of the control plane that the gateway service resides in
     */
    runtimeGroupId: string;
}

export interface ApiProductVersionPortal {
    applicationRegistrationEnabled: boolean;
    authStrategies: outputs.ApiProductVersionPortalAuthStrategy[];
    autoApproveRegistration: boolean;
    deprecated: boolean;
    portalId: string;
    portalName: string;
    portalProductVersionId: string;
    /**
     * must be one of ["published", "unpublished"]
     */
    publishStatus: string;
}

export interface ApiProductVersionPortalAuthStrategy {
    id: string;
    name: string;
}

export interface ApplicationAuthStrategyKeyAuth {
    /**
     * At least one published product version is using this auth strategy.
     */
    active: boolean;
    /**
     * JSON-B object containing the configuration for the Key Auth strategy. Requires replacement if changed. ; Not Null
     */
    configs: outputs.ApplicationAuthStrategyKeyAuthConfigs;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     */
    createdAt: string;
    dcrProvider: outputs.ApplicationAuthStrategyKeyAuthDcrProvider;
    /**
     * The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    /**
     * The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
     */
    name: string;
    /**
     * Requires replacement if changed. ; Not Null; must be one of ["keyAuth"]
     */
    strategyType: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     */
    updatedAt: string;
}

export interface ApplicationAuthStrategyKeyAuthConfigs {
    /**
     * The most basic mode to configure an Application Auth Strategy for an API Product Version.
     * Using this mode will allow developers to generate API keys that will authenticate their application requests.
     * Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
     */
    keyAuth: outputs.ApplicationAuthStrategyKeyAuthConfigsKeyAuth;
}

export interface ApplicationAuthStrategyKeyAuthConfigsKeyAuth {
    /**
     * The names of the headers containing the API key. You can specify multiple header names. Requires replacement if changed.
     */
    keyNames: string[];
}

export interface ApplicationAuthStrategyKeyAuthDcrProvider {
    /**
     * The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    name: string;
    /**
     * The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
     */
    providerType: string;
}

export interface ApplicationAuthStrategyOpenidConnect {
    /**
     * At least one published product version is using this auth strategy.
     */
    active: boolean;
    /**
     * JSON-B object containing the configuration for the OIDC strategy. Requires replacement if changed. ; Not Null
     */
    configs: outputs.ApplicationAuthStrategyOpenidConnectConfigs;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     */
    createdAt: string;
    dcrProvider: outputs.ApplicationAuthStrategyOpenidConnectDcrProvider;
    /**
     * Requires replacement if changed.
     */
    dcrProviderId: string;
    /**
     * The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    /**
     * The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
     */
    name: string;
    /**
     * Requires replacement if changed. ; Not Null; must be one of ["openidConnect"]
     */
    strategyType: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     */
    updatedAt: string;
}

export interface ApplicationAuthStrategyOpenidConnectConfigs {
    /**
     * A more advanced mode to configure an API Product Version’s Application Auth Strategy.
     * Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests.
     * Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy.
     * An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
     */
    openidConnect: outputs.ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect;
}

export interface ApplicationAuthStrategyOpenidConnectConfigsOpenidConnect {
    /**
     * Parsed as JSON.
     */
    additionalProperties: string;
    /**
     * Requires replacement if changed. ; Not Null
     */
    authMethods: string[];
    /**
     * Requires replacement if changed. ; Not Null
     */
    credentialClaims: string[];
    /**
     * Requires replacement if changed. ; Not Null
     */
    issuer: string;
    /**
     * Requires replacement if changed. ; Not Null
     */
    scopes: string[];
}

export interface ApplicationAuthStrategyOpenidConnectDcrProvider {
    /**
     * The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    name: string;
    /**
     * The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
     */
    providerType: string;
}

export interface CloudGatewayConfigurationDataplaneGroup {
    /**
     * Not Null
     */
    autoscale: outputs.CloudGatewayConfigurationDataplaneGroupAutoscale;
    /**
     * Not Null
     */
    cloudGatewayNetworkId: string;
    /**
     * An RFC-3339 timestamp representation of data-plane group creation date.
     */
    createdAt: string;
    /**
     * List of egress IP addresses for the network that this data-plane group runs on.
     */
    egressIpAddresses: string[];
    /**
     * ID of the data-plane group that represents a deployment target for a set of data-planes.
     */
    id: string;
    /**
     * List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
     */
    privateIpAddresses: string[];
    /**
     * Name of cloud provider. Not Null; must be one of ["aws"]
     */
    provider: string;
    /**
     * Region ID for cloud provider region. Not Null
     */
    region: string;
    /**
     * State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
     */
    state: string;
    /**
     * An RFC-3339 timestamp representation of data-plane group update date.
     */
    updatedAt: string;
}

export interface CloudGatewayConfigurationDataplaneGroupAutoscale {
    /**
     * Object that describes the autopilot autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleAutopilot: outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot;
    /**
     * Object that describes the static autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleStatic: outputs.CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic;
}

export interface CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot {
    /**
     * Base number of requests per second that the deployment target should support. Not Null
     */
    baseRps: number;
    /**
     * Not Null; must be one of ["autopilot"]
     */
    kind: string;
    /**
     * Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
     */
    maxRps: number;
}

export interface CloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic {
    /**
     * Instance type name to indicate capacity. Not Null; must be one of ["small", "medium", "large"]
     */
    instanceType: string;
    /**
     * Not Null; must be one of ["static"]
     */
    kind: string;
    /**
     * Number of data-planes the deployment target will contain. Not Null
     */
    requestedInstances: number;
}

export interface CloudGatewayConfigurationDataplaneGroupConfig {
    autoscale: outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscale;
    cloudGatewayNetworkId: string;
    /**
     * Name of cloud provider. must be one of ["aws"]
     */
    provider: string;
    /**
     * Region ID for cloud provider region.
     */
    region: string;
}

export interface CloudGatewayConfigurationDataplaneGroupConfigAutoscale {
    /**
     * Object that describes the autopilot autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleAutopilot: outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot;
    /**
     * Object that describes the static autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleStatic: outputs.CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic;
}

export interface CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot {
    /**
     * Base number of requests per second that the deployment target should support.
     */
    baseRps: number;
    /**
     * must be one of ["autopilot"]
     */
    kind: string;
    /**
     * Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
     */
    maxRps: number;
}

export interface CloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic {
    /**
     * Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
     */
    instanceType: string;
    /**
     * must be one of ["static"]
     */
    kind: string;
    /**
     * Number of data-planes the deployment target will contain.
     */
    requestedInstances: number;
}

export interface CloudGatewayCustomDomainStateMetadata {
    /**
     * Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
     */
    reason: string;
    /**
     * Reported status of the custom domain from backing infrastructure.
     */
    reportedStatus: string;
}

export interface CloudGatewayNetworkFirewall {
    /**
     * List of allowed CIDR blocks to access a network.
     */
    allowedCidrBlocks: string[];
    /**
     * List of denied CIDR blocks to access a network.
     */
    deniedCidrBlocks: string[];
}

export interface CloudGatewayNetworkProviderMetadata {
    subnetIds: string[];
    vpcId: string;
}

export interface CloudGatewayTransitGatewayDnsConfig {
    /**
     * Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
     * for a transit gateway.
     */
    domainProxyLists: string[];
    /**
     * Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway. Requires replacement if changed. ; Not Null
     */
    remoteDnsServerIpAddresses: string[];
}

export interface CloudGatewayTransitGatewayTransitGatewayAttachmentConfig {
    /**
     * Requires replacement if changed.
     */
    awsTransitGatewayAttachmentConfig: outputs.CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig;
}

export interface CloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig {
    /**
     * Requires replacement if changed. ; Not Null; must be one of ["aws-transit-gateway-attachment"]
     */
    kind: string;
    /**
     * Resource Share ARN to verify request to create transit gateway attachment. Requires replacement if changed. ; Not Null
     */
    ramShareArn: string;
    /**
     * AWS Transit Gateway ID to create attachment to. Requires replacement if changed. ; Not Null
     */
    transitGatewayId: string;
}

export interface GatewayAclConsumer {
    id: string;
}

export interface GatewayBasicAuthConsumer {
    id: string;
}

export interface GatewayControlPlaneConfig {
    /**
     * Control Plane Endpoint.
     */
    controlPlaneEndpoint: string;
    /**
     * Telemetry Endpoint.
     */
    telemetryEndpoint: string;
}

export interface GatewayControlPlaneMembershipMember {
    /**
     * Requires replacement if changed.
     */
    id?: string;
}

export interface GatewayControlPlaneProxyUrl {
    /**
     * Hostname of the proxy URL.
     */
    host: string;
    /**
     * Port of the proxy URL.
     */
    port: number;
    /**
     * Protocol of the proxy URL.
     */
    protocol: string;
}

export interface GatewayHmacAuthConsumer {
    id: string;
}

export interface GatewayJwtConsumer {
    id: string;
}

export interface GatewayKeyAuthConsumer {
    id: string;
}

export interface GatewayKeyPem {
    privateKey: string;
    publicKey: string;
}

export interface GatewayKeySet {
    id: string;
}

export interface GatewayPluginAclConfig {
    /**
     * Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
     */
    allows: string[];
    /**
     * Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
     */
    denies: string[];
    /**
     * If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
     */
    hideGroupsHeader: boolean;
    includeConsumerGroups: boolean;
}

export interface GatewayPluginAclConsumer {
    id: string;
}

export interface GatewayPluginAclConsumerGroup {
    id: string;
}

export interface GatewayPluginAclRoute {
    id: string;
}

export interface GatewayPluginAclService {
    id: string;
}

export interface GatewayPluginAiPromptDecoratorConfig {
    prompts: outputs.GatewayPluginAiPromptDecoratorConfigPrompts;
}

export interface GatewayPluginAiPromptDecoratorConfigPrompts {
    /**
     * Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
     */
    appends: outputs.GatewayPluginAiPromptDecoratorConfigPromptsAppend[];
    /**
     * Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
     */
    prepends: outputs.GatewayPluginAiPromptDecoratorConfigPromptsPrepend[];
}

export interface GatewayPluginAiPromptDecoratorConfigPromptsAppend {
    /**
     * Not Null
     */
    content: string;
    /**
     * must be one of ["system", "assistant", "user"]
     */
    role: string;
}

export interface GatewayPluginAiPromptDecoratorConfigPromptsPrepend {
    /**
     * Not Null
     */
    content: string;
    /**
     * must be one of ["system", "assistant", "user"]
     */
    role: string;
}

export interface GatewayPluginAiPromptDecoratorConsumer {
    id: string;
}

export interface GatewayPluginAiPromptDecoratorConsumerGroup {
    id: string;
}

export interface GatewayPluginAiPromptDecoratorRoute {
    id: string;
}

export interface GatewayPluginAiPromptDecoratorService {
    id: string;
}

export interface GatewayPluginAiPromptGuardConfig {
    /**
     * If true, will ignore all previous chat prompts from the conversation history.
     */
    allowAllConversationHistory: boolean;
    /**
     * Array of valid regex patterns, or valid questions from the 'user' role in chat.
     */
    allowPatterns: string[];
    /**
     * Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
     */
    denyPatterns: string[];
}

export interface GatewayPluginAiPromptGuardConsumer {
    id: string;
}

export interface GatewayPluginAiPromptGuardConsumerGroup {
    id: string;
}

export interface GatewayPluginAiPromptGuardRoute {
    id: string;
}

export interface GatewayPluginAiPromptGuardService {
    id: string;
}

export interface GatewayPluginAiPromptTemplateConfig {
    /**
     * Set true to allow requests that don't call or match any template.
     */
    allowUntemplatedRequests: boolean;
    /**
     * Set true to add the original request to the Kong log plugin(s) output.
     */
    logOriginalRequest: boolean;
    /**
     * Array of templates available to the request context.
     */
    templates: outputs.GatewayPluginAiPromptTemplateConfigTemplate[];
}

export interface GatewayPluginAiPromptTemplateConfigTemplate {
    /**
     * Unique name for the template, can be called with `{template://NAME}`. Not Null
     */
    name: string;
    /**
     * Template string for this request, supports mustache-style `{{placeholders}}`. Not Null
     */
    template: string;
}

export interface GatewayPluginAiPromptTemplateConsumer {
    id: string;
}

export interface GatewayPluginAiPromptTemplateConsumerGroup {
    id: string;
}

export interface GatewayPluginAiPromptTemplateRoute {
    id: string;
}

export interface GatewayPluginAiPromptTemplateService {
    id: string;
}

export interface GatewayPluginAiProxyConfig {
    auth: outputs.GatewayPluginAiProxyConfigAuth;
    logging: outputs.GatewayPluginAiProxyConfigLogging;
    model: outputs.GatewayPluginAiProxyConfigModel;
    /**
     * Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
     */
    responseStreaming: string;
    /**
     * The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
     */
    routeType: string;
}

export interface GatewayPluginAiProxyConfigAuth {
    /**
     * If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
     */
    azureClientId: string;
    /**
     * If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
     */
    azureClientSecret: string;
    /**
     * If azure*use*managed_identity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
     */
    azureTenantId: string;
    /**
     * Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
     */
    azureUseManagedIdentity: boolean;
    /**
     * If AI model requires authentication via Authorization or API key header, specify its name here.
     */
    headerName: string;
    /**
     * Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
     */
    headerValue: string;
    /**
     * Specify whether the 'param*name' and 'param*value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
     */
    paramLocation: string;
    /**
     * If AI model requires authentication via query parameter, specify its name here.
     */
    paramName: string;
    /**
     * Specify the full parameter value for 'param_name'.
     */
    paramValue: string;
}

export interface GatewayPluginAiProxyConfigLogging {
    /**
     * If enabled, will log the request and response body into the Kong log plugin(s) output.
     */
    logPayloads: boolean;
    /**
     * If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
     */
    logStatistics: boolean;
}

export interface GatewayPluginAiProxyConfigModel {
    /**
     * Model name to execute.
     */
    name: string;
    /**
     * Key/value settings for the model
     */
    options: outputs.GatewayPluginAiProxyConfigModelOptions;
    /**
     * AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
     */
    provider: string;
}

export interface GatewayPluginAiProxyConfigModelOptions {
    /**
     * Defines the schema/API version, if using Anthropic provider.
     */
    anthropicVersion: string;
    /**
     * 'api-version' for Azure OpenAI instances.
     */
    azureApiVersion: string;
    /**
     * Deployment ID for Azure OpenAI instances.
     */
    azureDeploymentId: string;
    /**
     * Instance name for Azure OpenAI hosted models.
     */
    azureInstance: string;
    /**
     * If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
     */
    llama2Format: string;
    /**
     * Defines the max_tokens, if using chat or completion models.
     */
    maxTokens: number;
    /**
     * If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
     */
    mistralFormat: string;
    /**
     * Defines the matching temperature, if using chat or completion models.
     */
    temperature: number;
    /**
     * Defines the top-k most likely tokens, if supported.
     */
    topK: number;
    /**
     * Defines the top-p probability mass, if supported.
     */
    topP: number;
    /**
     * Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
     */
    upstreamPath: string;
    /**
     * Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
     */
    upstreamUrl: string;
}

export interface GatewayPluginAiProxyConsumer {
    id: string;
}

export interface GatewayPluginAiProxyConsumerGroup {
    id: string;
}

export interface GatewayPluginAiProxyRoute {
    id: string;
}

export interface GatewayPluginAiProxyService {
    id: string;
}

export interface GatewayPluginAwsLambdaConfig {
    /**
     * The target AWS IAM role ARN used to invoke the Lambda function.
     */
    awsAssumeRoleArn: string;
    /**
     * Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
     */
    awsImdsProtocolVersion: string;
    /**
     * The AWS key credential to be used when invoking the function.
     */
    awsKey: string;
    /**
     * A string representing a host name, such as example.com.
     */
    awsRegion: string;
    /**
     * The identifier of the assumed role session.
     */
    awsRoleSessionName: string;
    /**
     * The AWS secret credential to be used when invoking the function.
     */
    awsSecret: string;
    /**
     * An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
     */
    awsgatewayCompatible: boolean;
    /**
     * An optional value that Base64-encodes the request body.
     */
    base64EncodeBody: boolean;
    disableHttps: boolean;
    /**
     * An optional value that defines whether the request body is sent in the request*body field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate request*body_args field of the request.
     */
    forwardRequestBody: boolean;
    /**
     * An optional value that defines whether the original HTTP request headers are sent as a map in the requestHeaders field of the JSON-encoded request.
     */
    forwardRequestHeaders: boolean;
    /**
     * An optional value that defines whether the original HTTP request method verb is sent in the requestMethod field of the JSON-encoded request.
     */
    forwardRequestMethod: boolean;
    /**
     * An optional value that defines whether the original HTTP request URI is sent in the requestUri field of the JSON-encoded request.
     */
    forwardRequestUri: boolean;
    /**
     * The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
     */
    functionName: string;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
     */
    invocationType: string;
    /**
     * An optional value that defines whether the response format to receive from the Lambda to this format.
     */
    isProxyIntegration: boolean;
    /**
     * An optional value in milliseconds that defines how long an idle connection lives before being closed.
     */
    keepalive: number;
    /**
     * The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
     */
    logType: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    proxyUrl: string;
    /**
     * The qualifier to use when invoking the function.
     */
    qualifier: string;
    /**
     * An optional value that defines whether Kong should send large bodies that are buffered to disk
     */
    skipLargeBodies: boolean;
    /**
     * An optional timeout in milliseconds when invoking the function.
     */
    timeout: number;
    /**
     * The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
     */
    unhandledStatus: number;
}

export interface GatewayPluginAwsLambdaConsumer {
    id: string;
}

export interface GatewayPluginAwsLambdaConsumerGroup {
    id: string;
}

export interface GatewayPluginAwsLambdaRoute {
    id: string;
}

export interface GatewayPluginAwsLambdaService {
    id: string;
}

export interface GatewayPluginBasicAuthConfig {
    /**
     * An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `customId`.
     */
    anonymous: string;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
     */
    hideCredentials: boolean;
    /**
     * When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
     */
    realm: string;
}

export interface GatewayPluginBasicAuthConsumer {
    id: string;
}

export interface GatewayPluginBasicAuthConsumerGroup {
    id: string;
}

export interface GatewayPluginBasicAuthRoute {
    id: string;
}

export interface GatewayPluginBasicAuthService {
    id: string;
}

export interface GatewayPluginCorrelationIdConfig {
    /**
     * Whether to echo the header back to downstream (the client).
     */
    echoDownstream: boolean;
    /**
     * The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
     */
    generator: string;
    /**
     * The HTTP header name to use for the correlation ID.
     */
    headerName: string;
}

export interface GatewayPluginCorrelationIdConsumer {
    id: string;
}

export interface GatewayPluginCorrelationIdConsumerGroup {
    id: string;
}

export interface GatewayPluginCorrelationIdRoute {
    id: string;
}

export interface GatewayPluginCorrelationIdService {
    id: string;
}

export interface GatewayPluginCorsConfig {
    /**
     * Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
     */
    credentials: boolean;
    /**
     * Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
     */
    exposedHeaders: string[];
    /**
     * Value for the `Access-Control-Allow-Headers` header.
     */
    headers: string[];
    /**
     * Indicates how long the results of the preflight request can be cached, in `seconds`.
     */
    maxAge: number;
    /**
     * 'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
     */
    methods: string[];
    /**
     * List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
     */
    origins: string[];
    /**
     * A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
     */
    preflightContinue: boolean;
    /**
     * Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
     */
    privateNetwork: boolean;
}

export interface GatewayPluginCorsConsumer {
    id: string;
}

export interface GatewayPluginCorsConsumerGroup {
    id: string;
}

export interface GatewayPluginCorsRoute {
    id: string;
}

export interface GatewayPluginCorsService {
    id: string;
}

export interface GatewayPluginExitTransformerConfig {
    functions: string[];
    /**
     * Determines whether to handle unexpected errors by transforming their responses.
     */
    handleUnexpected: boolean;
    /**
     * Determines whether to handle unknown status codes by transforming their responses.
     */
    handleUnknown: boolean;
}

export interface GatewayPluginExitTransformerConsumer {
    id: string;
}

export interface GatewayPluginExitTransformerConsumerGroup {
    id: string;
}

export interface GatewayPluginExitTransformerRoute {
    id: string;
}

export interface GatewayPluginExitTransformerService {
    id: string;
}

export interface GatewayPluginFileLogConfig {
    /**
     * Lua code as a key-value map
     */
    customFieldsByLua: {[key: string]: string};
    /**
     * The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
     */
    path: string;
    /**
     * Determines whether the log file is closed and reopened on every request.
     */
    reopen: boolean;
}

export interface GatewayPluginFileLogConsumer {
    id: string;
}

export interface GatewayPluginFileLogConsumerGroup {
    id: string;
}

export interface GatewayPluginFileLogRoute {
    id: string;
}

export interface GatewayPluginFileLogService {
    id: string;
}

export interface GatewayPluginIpRestrictionConfig {
    /**
     * List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
     */
    allows: string[];
    /**
     * List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
     */
    denies: string[];
    /**
     * The message to send as a response body to rejected requests.
     */
    message: string;
    /**
     * The HTTP status of the requests that will be rejected by the plugin.
     */
    status: number;
}

export interface GatewayPluginIpRestrictionConsumer {
    id: string;
}

export interface GatewayPluginIpRestrictionConsumerGroup {
    id: string;
}

export interface GatewayPluginIpRestrictionRoute {
    id: string;
}

export interface GatewayPluginIpRestrictionService {
    id: string;
}

export interface GatewayPluginJqConfig {
    requestIfMediaTypes: string[];
    requestJqProgram: string;
    requestJqProgramOptions: outputs.GatewayPluginJqConfigRequestJqProgramOptions;
    responseIfMediaTypes: string[];
    responseIfStatusCodes: number[];
    responseJqProgram: string;
    responseJqProgramOptions: outputs.GatewayPluginJqConfigResponseJqProgramOptions;
}

export interface GatewayPluginJqConfigRequestJqProgramOptions {
    asciiOutput: boolean;
    compactOutput: boolean;
    joinOutput: boolean;
    rawOutput: boolean;
    sortKeys: boolean;
}

export interface GatewayPluginJqConfigResponseJqProgramOptions {
    asciiOutput: boolean;
    compactOutput: boolean;
    joinOutput: boolean;
    rawOutput: boolean;
    sortKeys: boolean;
}

export interface GatewayPluginJqConsumer {
    id: string;
}

export interface GatewayPluginJqConsumerGroup {
    id: string;
}

export interface GatewayPluginJqRoute {
    id: string;
}

export interface GatewayPluginJqService {
    id: string;
}

export interface GatewayPluginJwtConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
     */
    anonymous: string;
    /**
     * A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
     */
    claimsToVerifies: string[];
    /**
     * A list of cookie names that Kong will inspect to retrieve JWTs.
     */
    cookieNames: string[];
    /**
     * A list of HTTP header names that Kong will inspect to retrieve JWTs.
     */
    headerNames: string[];
    /**
     * The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
     */
    keyClaimName: string;
    /**
     * A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximumExpiration seconds in the future.
     */
    maximumExpiration: number;
    /**
     * A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
     */
    runOnPreflight: boolean;
    /**
     * If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
     */
    secretIsBase64: boolean;
    /**
     * A list of querystring parameters that Kong will inspect to retrieve JWTs.
     */
    uriParamNames: string[];
}

export interface GatewayPluginJwtConsumer {
    id: string;
}

export interface GatewayPluginJwtConsumerGroup {
    id: string;
}

export interface GatewayPluginJwtRoute {
    id: string;
}

export interface GatewayPluginJwtService {
    id: string;
}

export interface GatewayPluginJwtSignerConfig {
    /**
     * When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `customId`.
     */
    accessTokenConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
     */
    accessTokenConsumerClaims: string[];
    /**
     * If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
     */
    accessTokenIntrospectionAuthorization: string;
    /**
     * This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
     */
    accessTokenIntrospectionBodyArgs: string;
    /**
     * When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
     */
    accessTokenIntrospectionConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
     */
    accessTokenIntrospectionConsumerClaims: string[];
    /**
     * When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
     */
    accessTokenIntrospectionEndpoint: string;
    /**
     * If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
     */
    accessTokenIntrospectionHint: string;
    /**
     * If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
     */
    accessTokenIntrospectionJwtClaims: string[];
    /**
     * Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
     */
    accessTokenIntrospectionLeeway: number;
    /**
     * Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realmAccess", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
     */
    accessTokenIntrospectionScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
     */
    accessTokenIntrospectionScopesRequireds: string[];
    /**
     * Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
     */
    accessTokenIntrospectionTimeout: number;
    /**
     * The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `originalIss` claim of the newly signed access token.
     */
    accessTokenIssuer: string;
    /**
     * Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
     */
    accessTokenJwksUri: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenJwksUri` is an https uri that requires mTLS Auth.
     */
    accessTokenJwksUriClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `accessTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `accessTokenJwksUriClientUsername`
     */
    accessTokenJwksUriClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `accessTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `accessTokenJwksUriClientPassword`
     */
    accessTokenJwksUriClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `accessTokenJwksUri`. The default value 0 means no auto-rotation.
     */
    accessTokenJwksUriRotatePeriod: number;
    /**
     * The name of the keyset containing signing keys.
     */
    accessTokenKeyset: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenKeyset` is an https uri that requires mTLS Auth.
     */
    accessTokenKeysetClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `accessTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `accessTokenKeysetClientUsername`
     */
    accessTokenKeysetClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `accessTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `accessTokenKeysetClientPassword`
     */
    accessTokenKeysetClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `accessTokenKeyset`. The default value 0 means no auto-rotation.
     */
    accessTokenKeysetRotatePeriod: number;
    /**
     * Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
     */
    accessTokenLeeway: number;
    /**
     * If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
     */
    accessTokenOptional: boolean;
    /**
     * This parameter tells the name of the header where to look for the access token.
     */
    accessTokenRequestHeader: string;
    /**
     * Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
     */
    accessTokenScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
     */
    accessTokenScopesRequireds: string[];
    /**
     * When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
     */
    accessTokenSigningAlgorithm: string;
    /**
     * Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
     */
    accessTokenUpstreamHeader: string;
    /**
     * If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
     */
    accessTokenUpstreamLeeway: number;
    /**
     * Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addAccessTokenClaims: {[key: string]: string};
    /**
     * Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addChannelTokenClaims: {[key: string]: string};
    /**
     * Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addClaims: {[key: string]: string};
    /**
     * Whether to cache access token introspection results.
     */
    cacheAccessTokenIntrospection: boolean;
    /**
     * Whether to cache channel token introspection results.
     */
    cacheChannelTokenIntrospection: boolean;
    /**
     * When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `customId`.
     */
    channelTokenConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `customId`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
     */
    channelTokenConsumerClaims: string[];
    /**
     * When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
     */
    channelTokenIntrospectionAuthorization: string;
    /**
     * If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
     */
    channelTokenIntrospectionBodyArgs: string;
    /**
     * When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `customId`.
     */
    channelTokenIntrospectionConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
     */
    channelTokenIntrospectionConsumerClaims: string[];
    /**
     * When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
     */
    channelTokenIntrospectionEndpoint: string;
    /**
     * If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
     */
    channelTokenIntrospectionHint: string;
    /**
     * If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
     */
    channelTokenIntrospectionJwtClaims: string[];
    /**
     * You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
     */
    channelTokenIntrospectionLeeway: number;
    /**
     * Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
     */
    channelTokenIntrospectionScopesClaims: string[];
    /**
     * Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
     */
    channelTokenIntrospectionScopesRequireds: string[];
    /**
     * Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
     */
    channelTokenIntrospectionTimeout: number;
    /**
     * The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `originalIss` claim of the newly signed channel token.
     */
    channelTokenIssuer: string;
    /**
     * If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
     */
    channelTokenJwksUri: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenJwksUri` is an https uri that requires mTLS Auth.
     */
    channelTokenJwksUriClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `channelTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `channelTokenJwksUriClientUsername`
     */
    channelTokenJwksUriClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `channelTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `channelTokenJwksUriClientPassword`
     */
    channelTokenJwksUriClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `channelTokenJwksUri`. The default value 0 means no auto-rotation.
     */
    channelTokenJwksUriRotatePeriod: number;
    /**
     * The name of the keyset containing signing keys.
     */
    channelTokenKeyset: string;
    /**
     * The client certificate that will be used to authenticate Kong if `channelTokenKeyset` is an https uri that requires mTLS Auth.
     */
    channelTokenKeysetClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `channelTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `channelTokenKeysetClientUsername`
     */
    channelTokenKeysetClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `channelTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `channelTokenKeysetClientPassword`
     */
    channelTokenKeysetClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `channelTokenKeyset`. The default value 0 means no auto-rotation.
     */
    channelTokenKeysetRotatePeriod: number;
    /**
     * Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
     */
    channelTokenLeeway: number;
    /**
     * If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
     */
    channelTokenOptional: boolean;
    /**
     * This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
     */
    channelTokenRequestHeader: string;
    /**
     * Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
     */
    channelTokenScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
     */
    channelTokenScopesRequireds: string[];
    /**
     * When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
     */
    channelTokenSigningAlgorithm: string;
    /**
     * This plugin removes the `config.channel_token_request_header` from the request after reading its value.
     */
    channelTokenUpstreamHeader: string;
    /**
     * If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
     */
    channelTokenUpstreamLeeway: number;
    /**
     * If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
     */
    enableAccessTokenIntrospection: boolean;
    /**
     * If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
     */
    enableChannelTokenIntrospection: boolean;
    /**
     * Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
     */
    enableHsSignatures: boolean;
    /**
     * Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
     */
    enableInstrumentation: boolean;
    /**
     * The HTTP header name used to store the original access token.
     */
    originalAccessTokenUpstreamHeader: string;
    /**
     * The HTTP header name used to store the original channel token.
     */
    originalChannelTokenUpstreamHeader: string;
    /**
     * When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
     */
    realm: string;
    /**
     * remove claims. It should be an array, and each element is a claim key string.
     */
    removeAccessTokenClaims: string[];
    /**
     * remove claims. It should be an array, and each element is a claim key string.
     */
    removeChannelTokenClaims: string[];
    /**
     * Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setAccessTokenClaims: {[key: string]: string};
    /**
     * Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setChannelTokenClaims: {[key: string]: string};
    /**
     * Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setClaims: {[key: string]: string};
    /**
     * Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
     */
    trustAccessTokenIntrospection: boolean;
    /**
     * Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel*token*introspection*jwt*claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
     */
    trustChannelTokenIntrospection: boolean;
    /**
     * Quickly turn access token expiry verification off and on as needed.
     */
    verifyAccessTokenExpiry: boolean;
    /**
     * Quickly turn access token introspection expiry verification off and on as needed.
     */
    verifyAccessTokenIntrospectionExpiry: boolean;
    /**
     * Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
     */
    verifyAccessTokenIntrospectionScopes: boolean;
    /**
     * Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
     */
    verifyAccessTokenScopes: boolean;
    /**
     * Quickly turn access token signature verification off and on as needed.
     */
    verifyAccessTokenSignature: boolean;
    verifyChannelTokenExpiry: boolean;
    /**
     * Quickly turn on/off the channel token introspection expiry verification.
     */
    verifyChannelTokenIntrospectionExpiry: boolean;
    /**
     * Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
     */
    verifyChannelTokenIntrospectionScopes: boolean;
    /**
     * Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
     */
    verifyChannelTokenScopes: boolean;
    /**
     * Quickly turn on/off the channel token signature verification.
     */
    verifyChannelTokenSignature: boolean;
}

export interface GatewayPluginJwtSignerConsumer {
    id: string;
}

export interface GatewayPluginJwtSignerConsumerGroup {
    id: string;
}

export interface GatewayPluginJwtSignerRoute {
    id: string;
}

export interface GatewayPluginJwtSignerService {
    id: string;
}

export interface GatewayPluginKeyAuthConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
     */
    anonymous: string;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
     */
    hideCredentials: boolean;
    /**
     * If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
     */
    keyInBody: boolean;
    /**
     * If enabled (default), the plugin reads the request header and tries to find the key in it.
     */
    keyInHeader: boolean;
    /**
     * If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
     */
    keyInQuery: boolean;
    /**
     * Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
     */
    keyNames: string[];
    /**
     * When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
     */
    realm: string;
    /**
     * A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
     */
    runOnPreflight: boolean;
}

export interface GatewayPluginKeyAuthConsumer {
    id: string;
}

export interface GatewayPluginKeyAuthConsumerGroup {
    id: string;
}

export interface GatewayPluginKeyAuthRoute {
    id: string;
}

export interface GatewayPluginKeyAuthService {
    id: string;
}

export interface GatewayPluginOauth2Config {
    /**
     * Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
     */
    acceptHttpIfAlreadyTerminated: boolean;
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
     */
    anonymous: string;
    /**
     * The name of the header that is supposed to carry the access token.
     */
    authHeaderName: string;
    /**
     * An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
     */
    enableAuthorizationCode: boolean;
    /**
     * An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
     */
    enableClientCredentials: boolean;
    /**
     * An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
     */
    enableImplicitGrant: boolean;
    /**
     * An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
     */
    enablePasswordGrant: boolean;
    /**
     * An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
     */
    globalCredentials: boolean;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service.
     */
    hideCredentials: boolean;
    /**
     * An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
     */
    mandatoryScope: boolean;
    persistentRefreshToken: boolean;
    /**
     * Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
     */
    pkce: string;
    /**
     * The unique key the plugin has generated when it has been added to the Service.
     */
    provisionKey: string;
    /**
     * Time-to-live value for data
     */
    refreshTokenTtl: number;
    /**
     * An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
     */
    reuseRefreshToken: boolean;
    /**
     * Describes an array of scope names that will be available to the end user. If `mandatoryScope` is set to `true`, then `scopes` are required.
     */
    scopes: string[];
    /**
     * An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
     */
    tokenExpiration: number;
}

export interface GatewayPluginOauth2Consumer {
    id: string;
}

export interface GatewayPluginOauth2ConsumerGroup {
    id: string;
}

export interface GatewayPluginOauth2Route {
    id: string;
}

export interface GatewayPluginOauth2Service {
    id: string;
}

export interface GatewayPluginOpenidConnectConfig {
    /**
     * An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `customId`.
     */
    anonymous: string;
    /**
     * The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    audienceClaims: string[];
    /**
     * The audiences (`audienceClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    audienceRequireds: string[];
    /**
     * The audience passed to the authorization endpoint.
     */
    audiences: string[];
    /**
     * Types of credentials/grants to enable.
     */
    authMethods: string[];
    /**
     * The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    authenticatedGroupsClaims: string[];
    /**
     * The authorization cookie Domain flag.
     */
    authorizationCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    authorizationCookieHttpOnly: boolean;
    /**
     * The authorization cookie name.
     */
    authorizationCookieName: string;
    /**
     * The authorization cookie Path flag.
     */
    authorizationCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    authorizationCookieSameSite: string;
    /**
     * Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    authorizationCookieSecure: boolean;
    /**
     * The authorization endpoint. If set it overrides the value in `authorizationEndpoint` returned by the discovery endpoint.
     */
    authorizationEndpoint: string;
    /**
     * Extra query arguments passed from the client to the authorization endpoint.
     */
    authorizationQueryArgsClients: string[];
    /**
     * Extra query argument names passed to the authorization endpoint.
     */
    authorizationQueryArgsNames: string[];
    /**
     * Extra query argument values passed to the authorization endpoint.
     */
    authorizationQueryArgsValues: string[];
    /**
     * Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
     */
    authorizationRollingTimeout: number;
    /**
     * The name of the cookie in which the bearer token is passed.
     */
    bearerTokenCookieName: string;
    /**
     * Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
     */
    bearerTokenParamTypes: string[];
    /**
     * If `consumerBy` is set to `username`, specify whether `username` can match consumers case-insensitively.
     */
    byUsernameIgnoreCase: boolean;
    /**
     * Cache the introspection endpoint requests.
     */
    cacheIntrospection: boolean;
    /**
     * Cache the token exchange endpoint requests.
     */
    cacheTokenExchange: boolean;
    /**
     * Cache the token endpoint requests.
     */
    cacheTokens: boolean;
    /**
     * Salt used for generating the cache key that is used for caching the token endpoint requests.
     */
    cacheTokensSalt: string;
    /**
     * The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
     */
    cacheTtl: number;
    /**
     * The maximum cache ttl in seconds (enforced).
     */
    cacheTtlMax: number;
    /**
     * The minimum cache ttl in seconds (enforced).
     */
    cacheTtlMin: number;
    /**
     * The negative cache ttl in seconds.
     */
    cacheTtlNeg: number;
    /**
     * The resurrection ttl in seconds.
     */
    cacheTtlResurrect: number;
    /**
     * Cache the user info requests.
     */
    cacheUserInfo: boolean;
    /**
     * The algorithm to use for client*secret*jwt (only HS***) or private*key*jwt authentication.
     */
    clientAlgs: string[];
    /**
     * The client to use for this request (the selection is made with a request parameter with the same name).
     */
    clientArg: string;
    /**
     * The default OpenID Connect client authentication method is 'client*secret*basic' (using 'Authorization: Basic' header), 'client*secret*post' (credentials in body), 'client*secret*jwt' (signed client assertion in body), 'private*key*jwt' (private key-signed assertion), 'tls*client*auth' (client certificate), 'self*signed*tls*client*auth' (self-signed client certificate), and 'none' (no authentication).
     */
    clientAuths: string[];
    /**
     * Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
     */
    clientCredentialsParamTypes: string[];
    /**
     * The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
     */
    clientIds: string[];
    /**
     * The JWK used for the private*key*jwt authentication.
     */
    clientJwks: outputs.GatewayPluginOpenidConnectConfigClientJwk[];
    /**
     * The client secret.
     */
    clientSecrets: string[];
    /**
     * Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `customId`: try to find the matching Consumer by `customId`.
     */
    consumerBies: string[];
    /**
     * The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    consumerClaims: string[];
    /**
     * Do not terminate the request if consumer mapping fails.
     */
    consumerOptional: boolean;
    /**
     * The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    credentialClaims: string[];
    /**
     * Disable issuing the session cookie with the specified grants.
     */
    disableSessions: string[];
    /**
     * Extra header names passed to the discovery endpoint.
     */
    discoveryHeadersNames: string[];
    /**
     * Extra header values passed to the discovery endpoint.
     */
    discoveryHeadersValues: string[];
    /**
     * Display errors on failure responses.
     */
    displayErrors: boolean;
    /**
     * The allowed values for the `hd` claim.
     */
    domains: string[];
    /**
     * The downstream access token header.
     */
    downstreamAccessTokenHeader: string;
    /**
     * The downstream access token JWK header.
     */
    downstreamAccessTokenJwkHeader: string;
    /**
     * The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    downstreamHeadersClaims: string[];
    /**
     * The downstream header names for the claim values.
     */
    downstreamHeadersNames: string[];
    /**
     * The downstream id token header.
     */
    downstreamIdTokenHeader: string;
    /**
     * The downstream id token JWK header.
     */
    downstreamIdTokenJwkHeader: string;
    /**
     * The downstream introspection header.
     */
    downstreamIntrospectionHeader: string;
    /**
     * The downstream introspection JWT header.
     */
    downstreamIntrospectionJwtHeader: string;
    /**
     * The downstream refresh token header.
     */
    downstreamRefreshTokenHeader: string;
    /**
     * The downstream session id header.
     */
    downstreamSessionIdHeader: string;
    /**
     * The downstream user info header.
     */
    downstreamUserInfoHeader: string;
    /**
     * The downstream user info JWT header (in case the user info returns a JWT response).
     */
    downstreamUserInfoJwtHeader: string;
    /**
     * Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
     */
    dpopProofLifetime: number;
    /**
     * Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
     */
    dpopUseNonce: boolean;
    /**
     * Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
     */
    enableHsSignatures: boolean;
    /**
     * The end session endpoint. If set it overrides the value in `endSessionEndpoint` returned by the discovery endpoint.
     */
    endSessionEndpoint: string;
    /**
     * Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
     */
    exposeErrorCode: boolean;
    /**
     * JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
     */
    extraJwksUris: string[];
    /**
     * Destroy any active session for the forbidden requests.
     */
    forbiddenDestroySession: boolean;
    /**
     * The error message for the forbidden requests (when not using the redirection).
     */
    forbiddenErrorMessage: string;
    /**
     * Where to redirect the client on forbidden requests.
     */
    forbiddenRedirectUris: string[];
    /**
     * The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    groupsClaims: string[];
    /**
     * The groups (`groupsClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    groupsRequireds: string[];
    /**
     * Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
     */
    hideCredentials: boolean;
    /**
     * The HTTP proxy.
     */
    httpProxy: string;
    /**
     * The HTTP proxy authorization.
     */
    httpProxyAuthorization: string;
    /**
     * The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
     */
    httpVersion: number;
    /**
     * The HTTPS proxy.
     */
    httpsProxy: string;
    /**
     * The HTTPS proxy authorization.
     */
    httpsProxyAuthorization: string;
    /**
     * The name of the parameter used to pass the id token.
     */
    idTokenParamName: string;
    /**
     * Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    idTokenParamTypes: string[];
    /**
     * Skip the token signature verification on certain grants: - `password`: OAuth password grant - `clientCredentials`: OAuth client credentials grant - `authorizationCode`: authorization code flow - `refreshToken`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
     */
    ignoreSignatures: string[];
    /**
     * Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
     */
    introspectJwtTokens: boolean;
    /**
     * The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
     */
    introspectionAccept: string;
    /**
     * Check that the introspection response has an `active` claim with a value of `true`.
     */
    introspectionCheckActive: boolean;
    /**
     * The introspection endpoint. If set it overrides the value in `introspectionEndpoint` returned by the discovery endpoint.
     */
    introspectionEndpoint: string;
    /**
     * The introspection endpoint authentication method: : `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["client*secret*basic", "client*secret*post", "client*secret*jwt", "private*key*jwt", "tls*client*auth", "self*signed*tls*client*auth", "none"]
     */
    introspectionEndpointAuthMethod: string;
    /**
     * Extra headers passed from the client to the introspection endpoint.
     */
    introspectionHeadersClients: string[];
    /**
     * Extra header names passed to the introspection endpoint.
     */
    introspectionHeadersNames: string[];
    /**
     * Extra header values passed to the introspection endpoint.
     */
    introspectionHeadersValues: string[];
    /**
     * Introspection hint parameter value passed to the introspection endpoint.
     */
    introspectionHint: string;
    /**
     * Extra post arguments passed from the client to the introspection endpoint.
     */
    introspectionPostArgsClients: string[];
    /**
     * Extra post argument names passed to the introspection endpoint.
     */
    introspectionPostArgsNames: string[];
    /**
     * Extra post argument values passed to the introspection endpoint.
     */
    introspectionPostArgsValues: string[];
    /**
     * Designate token's parameter name for introspection.
     */
    introspectionTokenParamName: string;
    /**
     * The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
     */
    issuer: string;
    /**
     * The issuers allowed to be present in the tokens (`iss` claim).
     */
    issuersAlloweds: string[];
    /**
     * The claim to match against the JWT session cookie.
     */
    jwtSessionClaim: string;
    /**
     * The name of the JWT session cookie.
     */
    jwtSessionCookie: string;
    /**
     * Use keepalive with the HTTP client.
     */
    keepalive: boolean;
    /**
     * Defines leeway time (in seconds) for `authTime`, `exp`, `iat`, and `nbf` claims
     */
    leeway: number;
    /**
     * What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
     */
    loginAction: string;
    /**
     * Enable login functionality with specified grants.
     */
    loginMethods: string[];
    /**
     * Where to place `loginTokens` when using `redirect` `loginAction`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
     */
    loginRedirectMode: string;
    /**
     * Where to redirect the client when `loginAction` is set to `redirect`.
     */
    loginRedirectUris: string[];
    /**
     * What tokens to include in `response` body or `redirect` query string or fragment: - `idToken`: include id token - `accessToken`: include access token - `refreshToken`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
     */
    loginTokens: string[];
    /**
     * The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
     */
    logoutMethods: string[];
    /**
     * The request body argument that activates the logout.
     */
    logoutPostArg: string;
    /**
     * The request query argument that activates the logout.
     */
    logoutQueryArg: string;
    /**
     * Where to redirect the client after the logout.
     */
    logoutRedirectUris: string[];
    /**
     * Revoke tokens as part of the logout.
     */
    logoutRevoke: boolean;
    /**
     * Revoke the access token as part of the logout. Requires `logoutRevoke` to be set to `true`.
     */
    logoutRevokeAccessToken: boolean;
    /**
     * Revoke the refresh token as part of the logout. Requires `logoutRevoke` to be set to `true`.
     */
    logoutRevokeRefreshToken: boolean;
    /**
     * The request URI suffix that activates the logout.
     */
    logoutUriSuffix: string;
    /**
     * The maximum age (in seconds) compared to the `authTime` claim.
     */
    maxAge: number;
    /**
     * Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsIntrospectionEndpoint: string;
    /**
     * Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsRevocationEndpoint: string;
    /**
     * Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsTokenEndpoint: string;
    /**
     * Do not use proxy with these hosts.
     */
    noProxy: string;
    /**
     * Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    passwordParamTypes: string[];
    /**
     * With this parameter, you can preserve request query arguments even when doing authorization code flow.
     */
    preserveQueryArgs: boolean;
    /**
     * If set to true, only the authMethods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all authMethods will be configurable and PoP checks will be silently skipped for those authMethods that are not compatible with PoP.
     */
    proofOfPossessionAuthMethodsValidation: boolean;
    /**
     * Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
     */
    proofOfPossessionDpop: string;
    /**
     * Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
     */
    proofOfPossessionMtls: string;
    /**
     * The pushed authorization endpoint. If set it overrides the value in `pushedAuthorizationRequestEndpoint` returned by the discovery endpoint.
     */
    pushedAuthorizationRequestEndpoint: string;
    /**
     * The pushed authorization request endpoint authentication method: `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    pushedAuthorizationRequestEndpointAuthMethod: string;
    /**
     * The redirect URI passed to the authorization and token endpoints.
     */
    redirectUris: string[];
    /**
     * Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
     */
    rediscoveryLifetime: number;
    /**
     * The name of the parameter used to pass the refresh token.
     */
    refreshTokenParamName: string;
    /**
     * Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    refreshTokenParamTypes: string[];
    /**
     * Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refreshToken` available.
     */
    refreshTokens: boolean;
    /**
     * Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `codeChallengeMethodsSupported`, and enabled automatically (in case the `codeChallengeMethodsSupported` is missing, the PKCE will not be enabled).
     */
    requireProofKeyForCodeExchange: boolean;
    /**
     * Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `requirePushedAuthorizationRequests` (which defaults to `false`).
     */
    requirePushedAuthorizationRequests: boolean;
    /**
     * Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `requireSignedRequestObject`, and enabled automatically (in case the `requireSignedRequestObject` is missing, the feature will not be enabled).
     */
    requireSignedRequestObject: boolean;
    /**
     * Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
     */
    resolveDistributedClaims: boolean;
    /**
     * Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `formPost`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `formPost` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "formPost", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
     */
    responseMode: string;
    /**
     * The response type passed to the authorization endpoint.
     */
    responseTypes: string[];
    /**
     * Specifies whether to always verify tokens stored in the session.
     */
    reverify: boolean;
    /**
     * The revocation endpoint. If set it overrides the value in `revocationEndpoint` returned by the discovery endpoint.
     */
    revocationEndpoint: string;
    /**
     * The revocation endpoint authentication method: : `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    revocationEndpointAuthMethod: string;
    /**
     * Designate token's parameter name for revocation.
     */
    revocationTokenParamName: string;
    /**
     * The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    rolesClaims: string[];
    /**
     * The roles (`rolesClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    rolesRequireds: string[];
    /**
     * Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
     */
    runOnPreflight: boolean;
    /**
     * The scopes passed to the authorization and token endpoints.
     */
    scopes: string[];
    /**
     * The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    scopesClaims: string[];
    /**
     * The scopes (`scopesClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    scopesRequireds: string[];
    /**
     * Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
     */
    searchUserInfo: boolean;
    /**
     * Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
     */
    sessionAbsoluteTimeout: number;
    /**
     * The session audience, which is the intended target application. For example `"my-application"`.
     */
    sessionAudience: string;
    /**
     * The session cookie Domain flag.
     */
    sessionCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    sessionCookieHttpOnly: boolean;
    /**
     * The session cookie name.
     */
    sessionCookieName: string;
    /**
     * The session cookie Path flag.
     */
    sessionCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    sessionCookieSameSite: string;
    /**
     * Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    sessionCookieSecure: boolean;
    /**
     * When set to `true`, audiences are forced to share the same subject.
     */
    sessionEnforceSameSubject: boolean;
    /**
     * When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
     */
    sessionHashStorageKey: boolean;
    /**
     * When set to `true`, the value of subject is hashed before being stored. Only applies when `sessionStoreMetadata` is enabled.
     */
    sessionHashSubject: boolean;
    /**
     * Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
     */
    sessionIdlingTimeout: number;
    /**
     * The memcached host.
     */
    sessionMemcachedHost: string;
    /**
     * The memcached port.
     */
    sessionMemcachedPort: number;
    /**
     * The memcached session key prefix.
     */
    sessionMemcachedPrefix: string;
    /**
     * The memcached unix socket path.
     */
    sessionMemcachedSocket: string;
    /**
     * The Redis cluster maximum redirects.
     */
    sessionRedisClusterMaxRedirections: number;
    /**
     * The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
     */
    sessionRedisClusterNodes: outputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNode[];
    /**
     * Session redis connection timeout in milliseconds.
     */
    sessionRedisConnectTimeout: number;
    /**
     * The Redis host.
     */
    sessionRedisHost: string;
    /**
     * Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
     */
    sessionRedisPassword: string;
    /**
     * The Redis port.
     */
    sessionRedisPort: number;
    /**
     * The Redis session key prefix.
     */
    sessionRedisPrefix: string;
    /**
     * Session redis read timeout in milliseconds.
     */
    sessionRedisReadTimeout: number;
    /**
     * Session redis send timeout in milliseconds.
     */
    sessionRedisSendTimeout: number;
    /**
     * The SNI used for connecting the Redis server.
     */
    sessionRedisServerName: string;
    /**
     * The Redis unix socket path.
     */
    sessionRedisSocket: string;
    /**
     * Use SSL/TLS for Redis connection.
     */
    sessionRedisSsl: boolean;
    /**
     * Verify identity provider server certificate.
     */
    sessionRedisSslVerify: boolean;
    /**
     * Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    sessionRedisUsername: string;
    /**
     * Enables or disables persistent sessions.
     */
    sessionRemember: boolean;
    /**
     * Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
     */
    sessionRememberAbsoluteTimeout: number;
    /**
     * Persistent session cookie name. Use with the `remember` configuration parameter.
     */
    sessionRememberCookieName: string;
    /**
     * Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
     */
    sessionRememberRollingTimeout: number;
    /**
     * Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
     */
    sessionRequestHeaders: string[];
    /**
     * Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
     */
    sessionResponseHeaders: string[];
    /**
     * Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
     */
    sessionRollingTimeout: number;
    /**
     * The session secret.
     */
    sessionSecret: string;
    /**
     * The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
     */
    sessionStorage: string;
    /**
     * Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
     */
    sessionStoreMetadata: boolean;
    /**
     * Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `luaSslTrustedCertificate`.
     */
    sslVerify: boolean;
    /**
     * Network IO timeout in milliseconds.
     */
    timeout: number;
    /**
     * ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
     */
    tlsClientAuthCertId: string;
    /**
     * Verify identity provider server certificate during mTLS client authentication.
     */
    tlsClientAuthSslVerify: boolean;
    /**
     * Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
     */
    tokenCacheKeyIncludeScope: boolean;
    /**
     * The token endpoint. If set it overrides the value in `tokenEndpoint` returned by the discovery endpoint.
     */
    tokenEndpoint: string;
    /**
     * The token endpoint authentication method: `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    tokenEndpointAuthMethod: string;
    /**
     * The token exchange endpoint.
     */
    tokenExchangeEndpoint: string;
    /**
     * Extra headers passed from the client to the token endpoint.
     */
    tokenHeadersClients: string[];
    /**
     * Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `clientCredentials`: with OAuth client credentials grant - `authorizationCode`: with authorization code flow - `refreshToken` with refresh token grant.
     */
    tokenHeadersGrants: string[];
    /**
     * Extra header names passed to the token endpoint.
     */
    tokenHeadersNames: string[];
    /**
     * Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
     */
    tokenHeadersPrefix: string;
    /**
     * The names of token endpoint response headers to forward to the downstream client.
     */
    tokenHeadersReplays: string[];
    /**
     * Extra header values passed to the token endpoint.
     */
    tokenHeadersValues: string[];
    /**
     * Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
     */
    tokenPostArgsClients: string[];
    /**
     * Extra post argument names passed to the token endpoint.
     */
    tokenPostArgsNames: string[];
    /**
     * Extra post argument values passed to the token endpoint.
     */
    tokenPostArgsValues: string[];
    /**
     * Destroy any active session for the unauthorized requests.
     */
    unauthorizedDestroySession: boolean;
    /**
     * The error message for the unauthorized requests (when not using the redirection).
     */
    unauthorizedErrorMessage: string;
    /**
     * Where to redirect the client on unauthorized requests.
     */
    unauthorizedRedirectUris: string[];
    /**
     * Where to redirect the client when unexpected errors happen with the requests.
     */
    unexpectedRedirectUris: string[];
    /**
     * The upstream access token header.
     */
    upstreamAccessTokenHeader: string;
    /**
     * The upstream access token JWK header.
     */
    upstreamAccessTokenJwkHeader: string;
    /**
     * The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    upstreamHeadersClaims: string[];
    /**
     * The upstream header names for the claim values.
     */
    upstreamHeadersNames: string[];
    /**
     * The upstream id token header.
     */
    upstreamIdTokenHeader: string;
    /**
     * The upstream id token JWK header.
     */
    upstreamIdTokenJwkHeader: string;
    /**
     * The upstream introspection header.
     */
    upstreamIntrospectionHeader: string;
    /**
     * The upstream introspection JWT header.
     */
    upstreamIntrospectionJwtHeader: string;
    /**
     * The upstream refresh token header.
     */
    upstreamRefreshTokenHeader: string;
    /**
     * The upstream session id header.
     */
    upstreamSessionIdHeader: string;
    /**
     * The upstream user info header.
     */
    upstreamUserInfoHeader: string;
    /**
     * The upstream user info JWT header (in case the user info returns a JWT response).
     */
    upstreamUserInfoJwtHeader: string;
    /**
     * The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
     */
    userinfoAccept: string;
    /**
     * The user info endpoint. If set it overrides the value in `userinfoEndpoint` returned by the discovery endpoint.
     */
    userinfoEndpoint: string;
    /**
     * Extra headers passed from the client to the user info endpoint.
     */
    userinfoHeadersClients: string[];
    /**
     * Extra header names passed to the user info endpoint.
     */
    userinfoHeadersNames: string[];
    /**
     * Extra header values passed to the user info endpoint.
     */
    userinfoHeadersValues: string[];
    /**
     * Extra query arguments passed from the client to the user info endpoint.
     */
    userinfoQueryArgsClients: string[];
    /**
     * Extra query argument names passed to the user info endpoint.
     */
    userinfoQueryArgsNames: string[];
    /**
     * Extra query argument values passed to the user info endpoint.
     */
    userinfoQueryArgsValues: string[];
    /**
     * If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
     */
    usingPseudoIssuer: boolean;
    /**
     * Verify tokens for standard claims.
     */
    verifyClaims: boolean;
    /**
     * Verify nonce on authorization code flow.
     */
    verifyNonce: boolean;
    /**
     * Verify plugin configuration against discovery.
     */
    verifyParameters: boolean;
    /**
     * Verify signature of tokens.
     */
    verifySignature: boolean;
}

export interface GatewayPluginOpenidConnectConfigClientJwk {
    alg: string;
    crv: string;
    d: string;
    dp: string;
    dq: string;
    e: string;
    issuer: string;
    k: string;
    keyOps: string[];
    kid: string;
    kty: string;
    n: string;
    oth: string;
    p: string;
    q: string;
    qi: string;
    r: string;
    t: string;
    use: string;
    x: string;
    x5cs: string[];
    x5t: string;
    x5tNumberS256: string;
    x5u: string;
    y: string;
}

export interface GatewayPluginOpenidConnectConfigSessionRedisClusterNode {
    /**
     * A string representing a host name, such as example.com.
     */
    ip: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
}

export interface GatewayPluginOpenidConnectConsumer {
    id: string;
}

export interface GatewayPluginOpenidConnectConsumerGroup {
    id: string;
}

export interface GatewayPluginOpenidConnectRoute {
    id: string;
}

export interface GatewayPluginOpenidConnectService {
    id: string;
}

export interface GatewayPluginOpentelemetryConfig {
    /**
     * The delay, in seconds, between two consecutive batches.
     */
    batchFlushDelay: number;
    /**
     * The number of spans to be sent in a single batch.
     */
    batchSpanCount: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    connectTimeout: number;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    endpoint: string;
    /**
     * must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
     */
    headerType: string;
    /**
     * The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
     */
    headers: {[key: string]: string};
    httpResponseHeaderForTraceid: string;
    propagation: outputs.GatewayPluginOpentelemetryConfigPropagation;
    queue: outputs.GatewayPluginOpentelemetryConfigQueue;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    readTimeout: number;
    resourceAttributes: {[key: string]: string};
    /**
     * Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracingSamplingRate` setting from kong.conf.
     */
    samplingRate: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    sendTimeout: number;
}

export interface GatewayPluginOpentelemetryConfigPropagation {
    /**
     * Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
     */
    clears: string[];
    /**
     * The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. Not Null; must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
     */
    defaultFormat: string;
    /**
     * Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
     */
    extracts: string[];
    /**
     * Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
     */
    injects: string[];
}

export interface GatewayPluginOpentelemetryConfigQueue {
    /**
     * Time in seconds before the initial retry is made for a failing batch.
     */
    initialRetryDelay: number;
    /**
     * Maximum number of entries that can be processed at a time.
     */
    maxBatchSize: number;
    /**
     * Maximum number of bytes that can be waiting on a queue, requires string content.
     */
    maxBytes: number;
    /**
     * Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
     */
    maxCoalescingDelay: number;
    /**
     * Maximum number of entries that can be waiting on the queue.
     */
    maxEntries: number;
    /**
     * Maximum time in seconds between retries, caps exponential backoff.
     */
    maxRetryDelay: number;
    /**
     * Time in seconds before the queue gives up calling a failed handler for a batch.
     */
    maxRetryTime: number;
}

export interface GatewayPluginOpentelemetryConsumer {
    id: string;
}

export interface GatewayPluginOpentelemetryConsumerGroup {
    id: string;
}

export interface GatewayPluginOpentelemetryRoute {
    id: string;
}

export interface GatewayPluginOpentelemetryService {
    id: string;
}

export interface GatewayPluginPostFunctionConfig {
    accesses: string[];
    bodyFilters: string[];
    certificates: string[];
    headerFilters: string[];
    logs: string[];
    rewrites: string[];
    wsClientFrames: string[];
    wsCloses: string[];
    wsHandshakes: string[];
    wsUpstreamFrames: string[];
}

export interface GatewayPluginPostFunctionConsumer {
    id: string;
}

export interface GatewayPluginPostFunctionConsumerGroup {
    id: string;
}

export interface GatewayPluginPostFunctionRoute {
    id: string;
}

export interface GatewayPluginPostFunctionService {
    id: string;
}

export interface GatewayPluginPreFunctionConfig {
    accesses: string[];
    bodyFilters: string[];
    certificates: string[];
    headerFilters: string[];
    logs: string[];
    rewrites: string[];
    wsClientFrames: string[];
    wsCloses: string[];
    wsHandshakes: string[];
    wsUpstreamFrames: string[];
}

export interface GatewayPluginPreFunctionConsumer {
    id: string;
}

export interface GatewayPluginPreFunctionConsumerGroup {
    id: string;
}

export interface GatewayPluginPreFunctionRoute {
    id: string;
}

export interface GatewayPluginPreFunctionService {
    id: string;
}

export interface GatewayPluginPrometheusConfig {
    /**
     * A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidthBytes` and `streamSessionsTotal` metrics will be exported.
     */
    bandwidthMetrics: boolean;
    /**
     * A boolean value that determines if latency metrics should be collected. If enabled, `kongLatencyMs`, `upstreamLatencyMs` and `requestLatencyMs` metrics will be exported.
     */
    latencyMetrics: boolean;
    /**
     * A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kongHttpRequestsTotal` and `kongBandwidthBytes` metrics fill in the consumer label when available.
     */
    perConsumer: boolean;
    /**
     * A boolean value that determines if status code metrics should be collected. If enabled, `httpRequestsTotal`, `streamSessionsTotal` metrics will be exported.
     */
    statusCodeMetrics: boolean;
    /**
     * A boolean value that determines if upstream metrics should be collected. If enabled, `upstreamTargetHealth` metric will be exported.
     */
    upstreamHealthMetrics: boolean;
}

export interface GatewayPluginPrometheusConsumer {
    id: string;
}

export interface GatewayPluginPrometheusConsumerGroup {
    id: string;
}

export interface GatewayPluginPrometheusRoute {
    id: string;
}

export interface GatewayPluginPrometheusService {
    id: string;
}

export interface GatewayPluginProxyCacheConfig {
    /**
     * When enabled, respect the Cache-Control behaviors defined in RFC7234.
     */
    cacheControl: boolean;
    /**
     * TTL, in seconds, of cache entities.
     */
    cacheTtl: number;
    /**
     * Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
     */
    contentTypes: string[];
    ignoreUriCase: boolean;
    memory: outputs.GatewayPluginProxyCacheConfigMemory;
    /**
     * Downstream request methods considered cacheable.
     */
    requestMethods: string[];
    /**
     * Upstream response status code considered cacheable.
     */
    responseCodes: number[];
    /**
     * Caching related diagnostic headers that should be included in cached responses
     */
    responseHeaders: outputs.GatewayPluginProxyCacheConfigResponseHeaders;
    /**
     * Number of seconds to keep resources in the storage backend. This value is independent of `cacheTtl` or resource TTLs defined by Cache-Control behaviors.
     */
    storageTtl: number;
    /**
     * The backing data store in which to hold cache entities. must be one of ["memory"]
     */
    strategy: string;
    /**
     * Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
     */
    varyHeaders: string[];
    /**
     * Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
     */
    varyQueryParams: string[];
}

export interface GatewayPluginProxyCacheConfigMemory {
    /**
     * The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
     */
    dictionaryName: string;
}

export interface GatewayPluginProxyCacheConfigResponseHeaders {
    age: boolean;
    xCacheKey: boolean;
    xCacheStatus: boolean;
}

export interface GatewayPluginProxyCacheConsumer {
    id: string;
}

export interface GatewayPluginProxyCacheConsumerGroup {
    id: string;
}

export interface GatewayPluginProxyCacheRoute {
    id: string;
}

export interface GatewayPluginProxyCacheService {
    id: string;
}

export interface GatewayPluginRateLimitingAdvancedConfig {
    /**
     * List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforceConsumerGroups` is set to `true`.
     */
    consumerGroups: string[];
    /**
     * The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
     */
    dictionaryName: string;
    /**
     * If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
     */
    disablePenalty: boolean;
    /**
     * Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforceConsumerGroups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforceConsumerGroups` to `true` to re-enforce the groups.
     */
    enforceConsumerGroups: boolean;
    /**
     * Set a custom error code to return when the rate limit is exceeded.
     */
    errorCode: number;
    /**
     * Set a custom error message to return when the rate limit is exceeded.
     */
    errorMessage: string;
    /**
     * A string representing an HTTP header name.
     */
    headerName: string;
    /**
     * Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
     */
    hideClientHeaders: boolean;
    /**
     * The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
     */
    identifier: string;
    /**
     * One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
     */
    limits: number[];
    /**
     * The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `syncRate`, `windowSize`, `dictionaryName`, need to be the same.
     */
    namespace: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    path: string;
    redis: outputs.GatewayPluginRateLimitingAdvancedConfigRedis;
    /**
     * The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
     */
    retryAfterJitterMax: number;
    /**
     * The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
     */
    strategy: string;
    /**
     * How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
     */
    syncRate: number;
    /**
     * One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
     */
    windowSizes: number[];
    /**
     * Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
     */
    windowType: string;
}

export interface GatewayPluginRateLimitingAdvancedConfigRedis {
    /**
     * Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
     */
    clusterAddresses: string[];
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    connectTimeout: number;
    /**
     * Database to use for the Redis connection when using the `redis` strategy
     */
    database: number;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalivePoolSize`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalivePoolSize`.
     */
    keepaliveBacklog: number;
    /**
     * The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalivePoolSize` nor `keepaliveBacklog` is specified, no pool is created. If `keepalivePoolSize` isn't specified but `keepaliveBacklog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
     */
    keepalivePoolSize: number;
    /**
     * Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
     */
    password: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    readTimeout: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    sendTimeout: number;
    /**
     * Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
     */
    sentinelAddresses: string[];
    /**
     * Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
     */
    sentinelMaster: string;
    /**
     * Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
     */
    sentinelPassword: string;
    /**
     * Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
     */
    sentinelRole: string;
    /**
     * Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
     */
    sentinelUsername: string;
    /**
     * A string representing an SNI (server name indication) value for TLS.
     */
    serverName: string;
    /**
     * If set to true, uses SSL to connect to Redis.
     */
    ssl: boolean;
    /**
     * If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `luaSslTrustedCertificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `luaSslVerifyDepth` accordingly.
     */
    sslVerify: boolean;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    timeout: number;
    /**
     * Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    username: string;
}

export interface GatewayPluginRateLimitingAdvancedConsumer {
    id: string;
}

export interface GatewayPluginRateLimitingAdvancedConsumerGroup {
    id: string;
}

export interface GatewayPluginRateLimitingAdvancedRoute {
    id: string;
}

export interface GatewayPluginRateLimitingAdvancedService {
    id: string;
}

export interface GatewayPluginRateLimitingConfig {
    /**
     * The number of HTTP requests that can be made per day.
     */
    day: number;
    /**
     * Set a custom error code to return when the rate limit is exceeded.
     */
    errorCode: number;
    /**
     * Set a custom error message to return when the rate limit is exceeded.
     */
    errorMessage: string;
    /**
     * A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
     */
    faultTolerant: boolean;
    /**
     * A string representing an HTTP header name.
     */
    headerName: string;
    /**
     * Optionally hide informative response headers.
     */
    hideClientHeaders: boolean;
    /**
     * The number of HTTP requests that can be made per hour.
     */
    hour: number;
    /**
     * The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
     */
    limitBy: string;
    /**
     * The number of HTTP requests that can be made per minute.
     */
    minute: number;
    /**
     * The number of HTTP requests that can be made per month.
     */
    month: number;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    path: string;
    /**
     * The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
     */
    policy: string;
    /**
     * Redis configuration
     */
    redis: outputs.GatewayPluginRateLimitingConfigRedis;
    /**
     * The number of HTTP requests that can be made per second.
     */
    second: number;
    /**
     * How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
     */
    syncRate: number;
    /**
     * The number of HTTP requests that can be made per year.
     */
    year: number;
}

export interface GatewayPluginRateLimitingConfigRedis {
    /**
     * Database to use for the Redis connection when using the `redis` strategy
     */
    database: number;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
     */
    password: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * A string representing an SNI (server name indication) value for TLS.
     */
    serverName: string;
    /**
     * If set to true, uses SSL to connect to Redis.
     */
    ssl: boolean;
    /**
     * If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `luaSslTrustedCertificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `luaSslVerifyDepth` accordingly.
     */
    sslVerify: boolean;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    timeout: number;
    /**
     * Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    username: string;
}

export interface GatewayPluginRateLimitingConsumer {
    id: string;
}

export interface GatewayPluginRateLimitingConsumerGroup {
    id: string;
}

export interface GatewayPluginRateLimitingRoute {
    id: string;
}

export interface GatewayPluginRateLimitingService {
    id: string;
}

export interface GatewayPluginRequestTerminationConfig {
    /**
     * The raw response body to send. This is mutually exclusive with the `config.message` field.
     */
    body: string;
    /**
     * Content type of the raw response configured with `config.body`.
     */
    contentType: string;
    /**
     * When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
     */
    echo: boolean;
    /**
     * The message to send, if using the default response generator.
     */
    message: string;
    /**
     * The response code to send. Must be an integer between 100 and 599.
     */
    statusCode: number;
    /**
     * A string representing an HTTP header name.
     */
    trigger: string;
}

export interface GatewayPluginRequestTerminationConsumer {
    id: string;
}

export interface GatewayPluginRequestTerminationConsumerGroup {
    id: string;
}

export interface GatewayPluginRequestTerminationRoute {
    id: string;
}

export interface GatewayPluginRequestTerminationService {
    id: string;
}

export interface GatewayPluginRequestTransformerAdvancedConfig {
    add: outputs.GatewayPluginRequestTransformerAdvancedConfigAdd;
    allow: outputs.GatewayPluginRequestTransformerAdvancedConfigAllow;
    append: outputs.GatewayPluginRequestTransformerAdvancedConfigAppend;
    /**
     * Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
     */
    dotsInKeys: boolean;
    /**
     * A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
     */
    httpMethod: string;
    remove: outputs.GatewayPluginRequestTransformerAdvancedConfigRemove;
    rename: outputs.GatewayPluginRequestTransformerAdvancedConfigRename;
    replace: outputs.GatewayPluginRequestTransformerAdvancedConfigReplace;
}

export interface GatewayPluginRequestTransformerAdvancedConfigAdd {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerAdvancedConfigAllow {
    bodies: string[];
}

export interface GatewayPluginRequestTransformerAdvancedConfigAppend {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerAdvancedConfigRemove {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerAdvancedConfigRename {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerAdvancedConfigReplace {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
    uri: string;
}

export interface GatewayPluginRequestTransformerAdvancedConsumer {
    id: string;
}

export interface GatewayPluginRequestTransformerAdvancedConsumerGroup {
    id: string;
}

export interface GatewayPluginRequestTransformerAdvancedRoute {
    id: string;
}

export interface GatewayPluginRequestTransformerAdvancedService {
    id: string;
}

export interface GatewayPluginRequestTransformerConfig {
    add: outputs.GatewayPluginRequestTransformerConfigAdd;
    append: outputs.GatewayPluginRequestTransformerConfigAppend;
    /**
     * A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
     */
    httpMethod: string;
    remove: outputs.GatewayPluginRequestTransformerConfigRemove;
    rename: outputs.GatewayPluginRequestTransformerConfigRename;
    replace: outputs.GatewayPluginRequestTransformerConfigReplace;
}

export interface GatewayPluginRequestTransformerConfigAdd {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerConfigAppend {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerConfigRemove {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerConfigRename {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GatewayPluginRequestTransformerConfigReplace {
    bodies: string[];
    headers: string[];
    querystrings: string[];
    uri: string;
}

export interface GatewayPluginRequestTransformerConsumer {
    id: string;
}

export interface GatewayPluginRequestTransformerConsumerGroup {
    id: string;
}

export interface GatewayPluginRequestTransformerRoute {
    id: string;
}

export interface GatewayPluginRequestTransformerService {
    id: string;
}

export interface GatewayPluginResponseTransformerAdvancedConfig {
    add: outputs.GatewayPluginResponseTransformerAdvancedConfigAdd;
    allow: outputs.GatewayPluginResponseTransformerAdvancedConfigAllow;
    append: outputs.GatewayPluginResponseTransformerAdvancedConfigAppend;
    /**
     * Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
     */
    dotsInKeys: boolean;
    remove: outputs.GatewayPluginResponseTransformerAdvancedConfigRemove;
    rename: outputs.GatewayPluginResponseTransformerAdvancedConfigRename;
    replace: outputs.GatewayPluginResponseTransformerAdvancedConfigReplace;
    transform: outputs.GatewayPluginResponseTransformerAdvancedConfigTransform;
}

export interface GatewayPluginResponseTransformerAdvancedConfigAdd {
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigAllow {
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigAppend {
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigRemove {
    headers: string[];
    ifStatuses: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigRename {
    headers: string[];
    ifStatuses: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigReplace {
    /**
     * String with which to replace the entire response body.
     */
    body: string;
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConfigTransform {
    functions: string[];
    ifStatuses: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerAdvancedConsumer {
    id: string;
}

export interface GatewayPluginResponseTransformerAdvancedConsumerGroup {
    id: string;
}

export interface GatewayPluginResponseTransformerAdvancedRoute {
    id: string;
}

export interface GatewayPluginResponseTransformerAdvancedService {
    id: string;
}

export interface GatewayPluginResponseTransformerConfig {
    add: outputs.GatewayPluginResponseTransformerConfigAdd;
    append: outputs.GatewayPluginResponseTransformerConfigAppend;
    remove: outputs.GatewayPluginResponseTransformerConfigRemove;
    rename: outputs.GatewayPluginResponseTransformerConfigRename;
    replace: outputs.GatewayPluginResponseTransformerConfigReplace;
}

export interface GatewayPluginResponseTransformerConfigAdd {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerConfigAppend {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerConfigRemove {
    headers: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerConfigRename {
    headers: string[];
}

export interface GatewayPluginResponseTransformerConfigReplace {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GatewayPluginResponseTransformerConsumer {
    id: string;
}

export interface GatewayPluginResponseTransformerConsumerGroup {
    id: string;
}

export interface GatewayPluginResponseTransformerRoute {
    id: string;
}

export interface GatewayPluginResponseTransformerService {
    id: string;
}

export interface GatewayPluginSamlConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
     */
    anonymous: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    assertionConsumerPath: string;
    /**
     * The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
     */
    idpCertificate: string;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    idpSsoUrl: string;
    /**
     * The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
     */
    issuer: string;
    /**
     * The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
     */
    nameidFormat: string;
    /**
     * The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
     */
    requestDigestAlgorithm: string;
    /**
     * The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
     */
    requestSignatureAlgorithm: string;
    /**
     * The certificate for signing requests.
     */
    requestSigningCertificate: string;
    /**
     * The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `requestSigningCertificate` parameter must be set as well.
     */
    requestSigningKey: string;
    /**
     * The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
     */
    responseDigestAlgorithm: string;
    /**
     * The private encryption key required to decrypt encrypted assertions.
     */
    responseEncryptionKey: string;
    /**
     * The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
     */
    responseSignatureAlgorithm: string;
    /**
     * The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
     */
    sessionAbsoluteTimeout: number;
    /**
     * The session audience, for example "my-application"
     */
    sessionAudience: string;
    /**
     * The session cookie domain flag.
     */
    sessionCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    sessionCookieHttpOnly: boolean;
    /**
     * The session cookie name.
     */
    sessionCookieName: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    sessionCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    sessionCookieSameSite: string;
    /**
     * The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    sessionCookieSecure: boolean;
    /**
     * When set to `true`, audiences are forced to share the same subject.
     */
    sessionEnforceSameSubject: boolean;
    /**
     * When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
     */
    sessionHashStorageKey: boolean;
    /**
     * When set to `true`, the value of subject is hashed before being stored. Only applies when `sessionStoreMetadata` is enabled.
     */
    sessionHashSubject: boolean;
    /**
     * The session cookie idle time in seconds.
     */
    sessionIdlingTimeout: number;
    /**
     * The memcached host.
     */
    sessionMemcachedHost: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    sessionMemcachedPort: number;
    /**
     * The memcached session key prefix.
     */
    sessionMemcachedPrefix: string;
    /**
     * The memcached unix socket path.
     */
    sessionMemcachedSocket: string;
    /**
     * The Redis cluster maximum redirects.
     */
    sessionRedisClusterMaxRedirections: number;
    /**
     * The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
     */
    sessionRedisClusterNodes: outputs.GatewayPluginSamlConfigSessionRedisClusterNode[];
    /**
     * The Redis connection timeout in milliseconds.
     */
    sessionRedisConnectTimeout: number;
    /**
     * The Redis host IP.
     */
    sessionRedisHost: string;
    /**
     * Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
     */
    sessionRedisPassword: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    sessionRedisPort: number;
    /**
     * The Redis session key prefix.
     */
    sessionRedisPrefix: string;
    /**
     * The Redis read timeout in milliseconds.
     */
    sessionRedisReadTimeout: number;
    /**
     * The Redis send timeout in milliseconds.
     */
    sessionRedisSendTimeout: number;
    /**
     * The SNI used for connecting to the Redis server.
     */
    sessionRedisServerName: string;
    /**
     * The Redis unix socket path.
     */
    sessionRedisSocket: string;
    /**
     * Use SSL/TLS for the Redis connection.
     */
    sessionRedisSsl: boolean;
    /**
     * Verify the Redis server certificate.
     */
    sessionRedisSslVerify: boolean;
    /**
     * Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
     */
    sessionRedisUsername: string;
    /**
     * Enables or disables persistent sessions
     */
    sessionRemember: boolean;
    /**
     * Persistent session absolute timeout in seconds.
     */
    sessionRememberAbsoluteTimeout: number;
    /**
     * Persistent session cookie name
     */
    sessionRememberCookieName: string;
    /**
     * Persistent session rolling timeout in seconds.
     */
    sessionRememberRollingTimeout: number;
    sessionRequestHeaders: string[];
    sessionResponseHeaders: string[];
    /**
     * The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
     */
    sessionRollingTimeout: number;
    /**
     * The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
     */
    sessionSecret: string;
    /**
     * The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
     */
    sessionStorage: string;
    /**
     * Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specificAudience` belonging to a specific subject.
     */
    sessionStoreMetadata: boolean;
    /**
     * Enable signature validation for SAML responses.
     */
    validateAssertionSignature: boolean;
}

export interface GatewayPluginSamlConfigSessionRedisClusterNode {
    /**
     * A string representing a host name, such as example.com.
     */
    ip: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
}

export interface GatewayPluginSamlConsumer {
    id: string;
}

export interface GatewayPluginSamlConsumerGroup {
    id: string;
}

export interface GatewayPluginSamlRoute {
    id: string;
}

export interface GatewayPluginSamlService {
    id: string;
}

export interface GatewayPluginStatsdConfig {
    /**
     * List of status code ranges that are allowed to be logged in metrics.
     */
    allowStatusCodes: string[];
    /**
     * must be one of ["consumer*id", "custom*id", "username"]
     */
    consumerIdentifierDefault: string;
    flushTimeout: number;
    /**
     * The IP address or hostname of StatsD server to send data to.
     */
    host: string;
    hostnameInPrefix: boolean;
    /**
     * List of metrics to be logged.
     */
    metrics: outputs.GatewayPluginStatsdConfigMetric[];
    /**
     * The port of StatsD server to send data to.
     */
    port: number;
    /**
     * String to prefix to each metric's name.
     */
    prefix: string;
    queue: outputs.GatewayPluginStatsdConfigQueue;
    queueSize: number;
    retryCount: number;
    /**
     * must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
     */
    serviceIdentifierDefault: string;
    /**
     * must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
     */
    tagStyle: string;
    udpPacketSize: number;
    useTcp: boolean;
    /**
     * must be one of ["workspace*id", "workspace*name"]
     */
    workspaceIdentifierDefault: string;
}

export interface GatewayPluginStatsdConfigMetric {
    /**
     * Authenticated user detail. must be one of ["consumer*id", "custom*id", "username"]
     */
    consumerIdentifier: string;
    /**
     * StatsD metric’s name. Not Null; must be one of ["kong*latency", "latency", "request*count", "request*per*user", "request*size", "response*size", "status*count", "status*count*per*user", "unique*users", "upstream*latency", "status*count*per*workspace", "status*count*per*user*per*route", "shdict*usage", "cache*datastore*hits*total", "cache*datastore*misses_total"]
     */
    name: string;
    /**
     * Sampling rate
     */
    sampleRate: number;
    /**
     * Service detail. must be one of ["service*id", "service*name", "service*host", "service*name*or*host"]
     */
    serviceIdentifier: string;
    /**
     * Determines what sort of event a metric represents. Not Null; must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
     */
    statType: string;
    /**
     * Workspace detail. must be one of ["workspace*id", "workspace*name"]
     */
    workspaceIdentifier: string;
}

export interface GatewayPluginStatsdConfigQueue {
    /**
     * Time in seconds before the initial retry is made for a failing batch.
     */
    initialRetryDelay: number;
    /**
     * Maximum number of entries that can be processed at a time.
     */
    maxBatchSize: number;
    /**
     * Maximum number of bytes that can be waiting on a queue, requires string content.
     */
    maxBytes: number;
    /**
     * Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
     */
    maxCoalescingDelay: number;
    /**
     * Maximum number of entries that can be waiting on the queue.
     */
    maxEntries: number;
    /**
     * Maximum time in seconds between retries, caps exponential backoff.
     */
    maxRetryDelay: number;
    /**
     * Time in seconds before the queue gives up calling a failed handler for a batch.
     */
    maxRetryTime: number;
}

export interface GatewayPluginStatsdConsumer {
    id: string;
}

export interface GatewayPluginStatsdConsumerGroup {
    id: string;
}

export interface GatewayPluginStatsdRoute {
    id: string;
}

export interface GatewayPluginStatsdService {
    id: string;
}

export interface GatewayRouteDestination {
    ip: string;
    port: number;
}

export interface GatewayRouteService {
    id: string;
}

export interface GatewayRouteSource {
    ip: string;
    port: number;
}

export interface GatewayServiceClientCertificate {
    id: string;
}

export interface GatewaySniCertificate {
    id: string;
}

export interface GatewayTargetUpstream {
    id: string;
}

export interface GatewayUpstreamClientCertificate {
    id: string;
}

export interface GatewayUpstreamHealthchecks {
    active: outputs.GatewayUpstreamHealthchecksActive;
    passive: outputs.GatewayUpstreamHealthchecksPassive;
    threshold: number;
}

export interface GatewayUpstreamHealthchecksActive {
    concurrency: number;
    headers: {[key: string]: string};
    healthy: outputs.GatewayUpstreamHealthchecksActiveHealthy;
    httpPath: string;
    httpsSni: string;
    httpsVerifyCertificate: boolean;
    timeout: number;
    /**
     * must be one of ["tcp", "http", "https", "grpc", "grpcs"]
     */
    type: string;
    unhealthy: outputs.GatewayUpstreamHealthchecksActiveUnhealthy;
}

export interface GatewayUpstreamHealthchecksActiveHealthy {
    httpStatuses: number[];
    interval: number;
    successes: number;
}

export interface GatewayUpstreamHealthchecksActiveUnhealthy {
    httpFailures: number;
    httpStatuses: number[];
    interval: number;
    tcpFailures: number;
    timeouts: number;
}

export interface GatewayUpstreamHealthchecksPassive {
    healthy: outputs.GatewayUpstreamHealthchecksPassiveHealthy;
    /**
     * must be one of ["tcp", "http", "https", "grpc", "grpcs"]
     */
    type: string;
    unhealthy: outputs.GatewayUpstreamHealthchecksPassiveUnhealthy;
}

export interface GatewayUpstreamHealthchecksPassiveHealthy {
    httpStatuses: number[];
    successes: number;
}

export interface GatewayUpstreamHealthchecksPassiveUnhealthy {
    httpFailures: number;
    httpStatuses: number[];
    tcpFailures: number;
    timeouts: number;
}

export interface GetApiProductDocumentMetadata {
}

export interface GetApiProductPortal {
    portalId: string;
    portalName: string;
}

export interface GetApiProductVersionGatewayService {
    /**
     * The identifier of the control plane that the gateway service resides in
     */
    controlPlaneId: string;
    /**
     * The identifier of a gateway service associated with the version of the API product.
     */
    id: string;
    /**
     * This field is deprecated, please use `controlPlaneId` instead. The identifier of the control plane that the gateway service resides in
     */
    runtimeGroupId: string;
}

export interface GetApiProductVersionPortal {
    applicationRegistrationEnabled: boolean;
    authStrategies: outputs.GetApiProductVersionPortalAuthStrategy[];
    autoApproveRegistration: boolean;
    deprecated: boolean;
    portalId: string;
    portalName: string;
    portalProductVersionId: string;
    /**
     * must be one of ["published", "unpublished"]
     */
    publishStatus: string;
}

export interface GetApiProductVersionPortalAuthStrategy {
    id: string;
    name: string;
}

export interface GetApplicationAuthStrategyKeyAuth {
    /**
     * At least one published product version is using this auth strategy.
     */
    active: boolean;
    /**
     * JSON-B object containing the configuration for the Key Auth strategy
     */
    configs: outputs.GetApplicationAuthStrategyKeyAuthConfigs;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     */
    createdAt: string;
    dcrProvider: outputs.GetApplicationAuthStrategyKeyAuthDcrProvider;
    /**
     * The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    /**
     * The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
     */
    name: string;
    /**
     * must be one of ["keyAuth"]
     */
    strategyType: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     */
    updatedAt: string;
}

export interface GetApplicationAuthStrategyKeyAuthConfigs {
    /**
     * The most basic mode to configure an Application Auth Strategy for an API Product Version. 
     * Using this mode will allow developers to generate API keys that will authenticate their application requests. 
     * Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for Key Auth.
     */
    keyAuth: outputs.GetApplicationAuthStrategyKeyAuthConfigsKeyAuth;
}

export interface GetApplicationAuthStrategyKeyAuthConfigsKeyAuth {
    /**
     * The names of the headers containing the API key. You can specify multiple header names.
     */
    keyNames: string[];
}

export interface GetApplicationAuthStrategyKeyAuthDcrProvider {
    /**
     * The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    name: string;
    /**
     * The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
     */
    providerType: string;
}

export interface GetApplicationAuthStrategyOpenidConnect {
    /**
     * At least one published product version is using this auth strategy.
     */
    active: boolean;
    /**
     * JSON-B object containing the configuration for the OIDC strategy
     */
    configs: outputs.GetApplicationAuthStrategyOpenidConnectConfigs;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     */
    createdAt: string;
    dcrProvider: outputs.GetApplicationAuthStrategyOpenidConnectDcrProvider;
    /**
     * The display name of the Auth strategy. This is used to identify the Auth strategy in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    /**
     * The name of the auth strategy. This is used to identify the auth strategy in the Konnect UI.
     */
    name: string;
    /**
     * must be one of ["openidConnect"]
     */
    strategyType: string;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     */
    updatedAt: string;
}

export interface GetApplicationAuthStrategyOpenidConnectConfigs {
    /**
     * A more advanced mode to configure an API Product Version’s Application Auth Strategy. 
     * Using this mode will allow developers to use API credentials issued from an external IdP that will authenticate their application requests. 
     * Once authenticated, an application will be granted access to any Product Version it is registered for that is configured for the same Auth Strategy. 
     * An OIDC strategy may be used in conjunction with a DCR provider to automatically create the IdP application.
     */
    openidConnect: outputs.GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnect;
}

export interface GetApplicationAuthStrategyOpenidConnectConfigsOpenidConnect {
    /**
     * Parsed as JSON.
     */
    additionalProperties: string;
    authMethods: string[];
    credentialClaims: string[];
    issuer: string;
    scopes: string[];
}

export interface GetApplicationAuthStrategyOpenidConnectDcrProvider {
    /**
     * The display name of the DCR provider. This is used to identify the DCR provider in the Portal UI.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    name: string;
    /**
     * The type of DCR provider. Can be one of the following - auth0, azureAd, curity, okta, http. must be one of ["auth0", "azureAd", "curity", "okta", "http"]
     */
    providerType: string;
}

export interface GetCloudGatewayConfigurationDataplaneGroup {
    autoscale: outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscale;
    cloudGatewayNetworkId: string;
    /**
     * An RFC-3339 timestamp representation of data-plane group creation date.
     */
    createdAt: string;
    /**
     * List of egress IP addresses for the network that this data-plane group runs on.
     */
    egressIpAddresses: string[];
    /**
     * ID of the data-plane group that represents a deployment target for a set of data-planes.
     */
    id: string;
    /**
     * List of private IP addresses of the internal load balancer that proxies traffic to this data-plane group.
     */
    privateIpAddresses: string[];
    /**
     * Name of cloud provider. must be one of ["aws"]
     */
    provider: string;
    /**
     * Region ID for cloud provider region.
     */
    region: string;
    /**
     * State of the data-plane group. must be one of ["created", "initializing", "ready", "terminating", "terminated"]
     */
    state: string;
    /**
     * An RFC-3339 timestamp representation of data-plane group update date.
     */
    updatedAt: string;
}

export interface GetCloudGatewayConfigurationDataplaneGroupAutoscale {
    /**
     * Object that describes the autopilot autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleAutopilot: outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot;
    /**
     * Object that describes the static autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleStatic: outputs.GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic;
}

export interface GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot {
    /**
     * Base number of requests per second that the deployment target should support.
     */
    baseRps: number;
    /**
     * must be one of ["autopilot"]
     */
    kind: string;
    /**
     * Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
     */
    maxRps: number;
}

export interface GetCloudGatewayConfigurationDataplaneGroupAutoscaleConfigurationDataPlaneGroupAutoscaleStatic {
    /**
     * Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
     */
    instanceType: string;
    /**
     * must be one of ["static"]
     */
    kind: string;
    /**
     * Number of data-planes the deployment target will contain.
     */
    requestedInstances: number;
}

export interface GetCloudGatewayConfigurationDataplaneGroupConfig {
    autoscale: outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscale;
    cloudGatewayNetworkId: string;
    /**
     * Name of cloud provider. must be one of ["aws"]
     */
    provider: string;
    /**
     * Region ID for cloud provider region.
     */
    region: string;
}

export interface GetCloudGatewayConfigurationDataplaneGroupConfigAutoscale {
    /**
     * Object that describes the autopilot autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleAutopilot: outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot;
    /**
     * Object that describes the static autoscaling strategy.
     */
    configurationDataPlaneGroupAutoscaleStatic: outputs.GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic;
}

export interface GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleAutopilot {
    /**
     * Base number of requests per second that the deployment target should support.
     */
    baseRps: number;
    /**
     * must be one of ["autopilot"]
     */
    kind: string;
    /**
     * Max number of requests per second that the deployment target should support. If not set, this defaults to 10x base_rps.
     */
    maxRps: number;
}

export interface GetCloudGatewayConfigurationDataplaneGroupConfigAutoscaleConfigurationDataPlaneGroupAutoscaleStatic {
    /**
     * Instance type name to indicate capacity. must be one of ["small", "medium", "large"]
     */
    instanceType: string;
    /**
     * must be one of ["static"]
     */
    kind: string;
    /**
     * Number of data-planes the deployment target will contain.
     */
    requestedInstances: number;
}

export interface GetCloudGatewayCustomDomainStateMetadata {
    /**
     * Reason why the custom domain may be in an erroneous state, reported from backing infrastructure.
     */
    reason: string;
    /**
     * Reported status of the custom domain from backing infrastructure.
     */
    reportedStatus: string;
}

export interface GetCloudGatewayNetworkFirewall {
    /**
     * List of allowed CIDR blocks to access a network.
     */
    allowedCidrBlocks: string[];
    /**
     * List of denied CIDR blocks to access a network.
     */
    deniedCidrBlocks: string[];
}

export interface GetCloudGatewayNetworkProviderMetadata {
    subnetIds: string[];
    vpcId: string;
}

export interface GetCloudGatewayProviderAccountListData {
    /**
     * An RFC-3339 timestamp representation of provider account creation date.
     */
    createdAt: string;
    id: string;
    /**
     * Name of cloud provider. must be one of ["aws"]
     */
    provider: string;
    /**
     * ID of the cloud provider account.
     */
    providerAccountId: string;
    /**
     * An RFC-3339 timestamp representation of provider account update date.
     */
    updatedAt: string;
}

export interface GetCloudGatewayProviderAccountListMeta {
    /**
     * Contains pagination query parameters and the total number of objects returned.
     */
    page: outputs.GetCloudGatewayProviderAccountListMetaPage;
}

export interface GetCloudGatewayProviderAccountListMetaPage {
    number: number;
    size: number;
    total: number;
}

export interface GetCloudGatewayTransitGatewayDnsConfig {
    /**
     * Internal domain names to proxy for DNS resolution from the listed remote DNS server IP addresses,
     * for a transit gateway.
     */
    domainProxyLists: string[];
    /**
     * Remote DNS Server IP Addresses to connect to for resolving internal DNS via a transit gateway.
     */
    remoteDnsServerIpAddresses: string[];
}

export interface GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfig {
    awsTransitGatewayAttachmentConfig: outputs.GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig;
}

export interface GetCloudGatewayTransitGatewayTransitGatewayAttachmentConfigAwsTransitGatewayAttachmentConfig {
    /**
     * must be one of ["aws-transit-gateway-attachment"]
     */
    kind: string;
    /**
     * Resource Share ARN to verify request to create transit gateway attachment.
     */
    ramShareArn: string;
    /**
     * AWS Transit Gateway ID to create attachment to.
     */
    transitGatewayId: string;
}

export interface GetGatewayAclConsumer {
    id: string;
}

export interface GetGatewayBasicAuthConsumer {
    id: string;
}

export interface GetGatewayControlPlaneConfig {
    /**
     * Control Plane Endpoint.
     */
    controlPlaneEndpoint: string;
    /**
     * Telemetry Endpoint.
     */
    telemetryEndpoint: string;
}

export interface GetGatewayHmacAuthConsumer {
    id: string;
}

export interface GetGatewayJwtConsumer {
    id: string;
}

export interface GetGatewayKeyAuthConsumer {
    id: string;
}

export interface GetGatewayKeyPem {
    privateKey: string;
    publicKey: string;
}

export interface GetGatewayKeySet {
    id: string;
}

export interface GetGatewayPluginAclConfig {
    /**
     * Arbitrary group names that are allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
     */
    allows: string[];
    /**
     * Arbitrary group names that are not allowed to consume the service or route. One of `config.allow` or `config.deny` must be specified.
     */
    denies: string[];
    /**
     * If enabled (`true`), prevents the `X-Consumer-Groups` header from being sent in the request to the upstream service.
     */
    hideGroupsHeader: boolean;
    includeConsumerGroups: boolean;
}

export interface GetGatewayPluginAclConsumer {
    id: string;
}

export interface GetGatewayPluginAclConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAclRoute {
    id: string;
}

export interface GetGatewayPluginAclService {
    id: string;
}

export interface GetGatewayPluginAiPromptDecoratorConfig {
    prompts: outputs.GetGatewayPluginAiPromptDecoratorConfigPrompts;
}

export interface GetGatewayPluginAiPromptDecoratorConfigPrompts {
    /**
     * Insert chat messages at the end of the chat message array. This array preserves exact order when adding messages.
     */
    appends: outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsAppend[];
    /**
     * Insert chat messages at the beginning of the chat message array. This array preserves exact order when adding messages.
     */
    prepends: outputs.GetGatewayPluginAiPromptDecoratorConfigPromptsPrepend[];
}

export interface GetGatewayPluginAiPromptDecoratorConfigPromptsAppend {
    content: string;
    /**
     * must be one of ["system", "assistant", "user"]
     */
    role: string;
}

export interface GetGatewayPluginAiPromptDecoratorConfigPromptsPrepend {
    content: string;
    /**
     * must be one of ["system", "assistant", "user"]
     */
    role: string;
}

export interface GetGatewayPluginAiPromptDecoratorConsumer {
    id: string;
}

export interface GetGatewayPluginAiPromptDecoratorConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAiPromptDecoratorRoute {
    id: string;
}

export interface GetGatewayPluginAiPromptDecoratorService {
    id: string;
}

export interface GetGatewayPluginAiPromptGuardConfig {
    /**
     * If true, will ignore all previous chat prompts from the conversation history.
     */
    allowAllConversationHistory: boolean;
    /**
     * Array of valid regex patterns, or valid questions from the 'user' role in chat.
     */
    allowPatterns: string[];
    /**
     * Array of invalid regex patterns, or invalid questions from the 'user' role in chat.
     */
    denyPatterns: string[];
}

export interface GetGatewayPluginAiPromptGuardConsumer {
    id: string;
}

export interface GetGatewayPluginAiPromptGuardConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAiPromptGuardRoute {
    id: string;
}

export interface GetGatewayPluginAiPromptGuardService {
    id: string;
}

export interface GetGatewayPluginAiPromptTemplateConfig {
    /**
     * Set true to allow requests that don't call or match any template.
     */
    allowUntemplatedRequests: boolean;
    /**
     * Set true to add the original request to the Kong log plugin(s) output.
     */
    logOriginalRequest: boolean;
    /**
     * Array of templates available to the request context.
     */
    templates: outputs.GetGatewayPluginAiPromptTemplateConfigTemplate[];
}

export interface GetGatewayPluginAiPromptTemplateConfigTemplate {
    /**
     * Unique name for the template, can be called with `{template://NAME}`
     */
    name: string;
    /**
     * Template string for this request, supports mustache-style `{{"{{"}}placeholders{{"}}"}}`
     */
    template: string;
}

export interface GetGatewayPluginAiPromptTemplateConsumer {
    id: string;
}

export interface GetGatewayPluginAiPromptTemplateConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAiPromptTemplateRoute {
    id: string;
}

export interface GetGatewayPluginAiPromptTemplateService {
    id: string;
}

export interface GetGatewayPluginAiProxyConfig {
    auth: outputs.GetGatewayPluginAiProxyConfigAuth;
    logging: outputs.GetGatewayPluginAiProxyConfigLogging;
    model: outputs.GetGatewayPluginAiProxyConfigModel;
    /**
     * Whether to 'optionally allow', 'deny', or 'always' (force) the streaming of answers via server sent events. must be one of ["allow", "deny", "always"]
     */
    responseStreaming: string;
    /**
     * The model's operation implementation, for this provider. Set to `preserve` to pass through without transformation. must be one of ["llm/v1/chat", "llm/v1/completions", "preserve"]
     */
    routeType: string;
}

export interface GetGatewayPluginAiProxyConfigAuth {
    /**
     * If azureUseManagedIdentity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client ID.
     */
    azureClientId: string;
    /**
     * If azureUseManagedIdentity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the client secret.
     */
    azureClientSecret: string;
    /**
     * If azureUseManagedIdentity is set to true, and you need to use a different user-assigned identity for this LLM instance, set the tenant ID.
     */
    azureTenantId: string;
    /**
     * Set true to use the Azure Cloud Managed Identity (or user-assigned identity) to authenticate with Azure-provider models.
     */
    azureUseManagedIdentity: boolean;
    /**
     * If AI model requires authentication via Authorization or API key header, specify its name here.
     */
    headerName: string;
    /**
     * Specify the full auth header value for 'header_name', for example 'Bearer key' or just 'key'.
     */
    headerValue: string;
    /**
     * Specify whether the 'param_name' and 'param_value' options go in a query string, or the POST form/JSON body. must be one of ["query", "body"]
     */
    paramLocation: string;
    /**
     * If AI model requires authentication via query parameter, specify its name here.
     */
    paramName: string;
    /**
     * Specify the full parameter value for 'param_name'.
     */
    paramValue: string;
}

export interface GetGatewayPluginAiProxyConfigLogging {
    /**
     * If enabled, will log the request and response body into the Kong log plugin(s) output.
     */
    logPayloads: boolean;
    /**
     * If enabled and supported by the driver, will add model usage and token metrics into the Kong log plugin(s) output.
     */
    logStatistics: boolean;
}

export interface GetGatewayPluginAiProxyConfigModel {
    /**
     * Model name to execute.
     */
    name: string;
    /**
     * Key/value settings for the model
     */
    options: outputs.GetGatewayPluginAiProxyConfigModelOptions;
    /**
     * AI provider request format - Kong translates requests to and from the specified backend compatible formats. must be one of ["openai", "azure", "anthropic", "cohere", "mistral", "llama2"]
     */
    provider: string;
}

export interface GetGatewayPluginAiProxyConfigModelOptions {
    /**
     * Defines the schema/API version, if using Anthropic provider.
     */
    anthropicVersion: string;
    /**
     * 'api-version' for Azure OpenAI instances.
     */
    azureApiVersion: string;
    /**
     * Deployment ID for Azure OpenAI instances.
     */
    azureDeploymentId: string;
    /**
     * Instance name for Azure OpenAI hosted models.
     */
    azureInstance: string;
    /**
     * If using llama2 provider, select the upstream message format. must be one of ["raw", "openai", "ollama"]
     */
    llama2Format: string;
    /**
     * Defines the max_tokens, if using chat or completion models.
     */
    maxTokens: number;
    /**
     * If using mistral provider, select the upstream message format. must be one of ["openai", "ollama"]
     */
    mistralFormat: string;
    /**
     * Defines the matching temperature, if using chat or completion models.
     */
    temperature: number;
    /**
     * Defines the top-k most likely tokens, if supported.
     */
    topK: number;
    /**
     * Defines the top-p probability mass, if supported.
     */
    topP: number;
    /**
     * Manually specify or override the AI operation path, used when e.g. using the 'preserve' route_type.
     */
    upstreamPath: string;
    /**
     * Manually specify or override the full URL to the AI operation endpoints, when calling (self-)hosted models, or for running via a private endpoint.
     */
    upstreamUrl: string;
}

export interface GetGatewayPluginAiProxyConsumer {
    id: string;
}

export interface GetGatewayPluginAiProxyConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAiProxyRoute {
    id: string;
}

export interface GetGatewayPluginAiProxyService {
    id: string;
}

export interface GetGatewayPluginAwsLambdaConfig {
    /**
     * The target AWS IAM role ARN used to invoke the Lambda function.
     */
    awsAssumeRoleArn: string;
    /**
     * Identifier to select the IMDS protocol version to use: `v1` or `v2`. must be one of ["v1", "v2"]
     */
    awsImdsProtocolVersion: string;
    /**
     * The AWS key credential to be used when invoking the function.
     */
    awsKey: string;
    /**
     * A string representing a host name, such as example.com.
     */
    awsRegion: string;
    /**
     * The identifier of the assumed role session.
     */
    awsRoleSessionName: string;
    /**
     * The AWS secret credential to be used when invoking the function.
     */
    awsSecret: string;
    /**
     * An optional value that defines whether the plugin should wrap requests into the Amazon API gateway.
     */
    awsgatewayCompatible: boolean;
    /**
     * An optional value that Base64-encodes the request body.
     */
    base64EncodeBody: boolean;
    disableHttps: boolean;
    /**
     * An optional value that defines whether the request body is sent in the requestBody field of the JSON-encoded request. If the body arguments can be parsed, they are sent in the separate requestBodyArgs field of the request.
     */
    forwardRequestBody: boolean;
    /**
     * An optional value that defines whether the original HTTP request headers are sent as a map in the requestHeaders field of the JSON-encoded request.
     */
    forwardRequestHeaders: boolean;
    /**
     * An optional value that defines whether the original HTTP request method verb is sent in the requestMethod field of the JSON-encoded request.
     */
    forwardRequestMethod: boolean;
    /**
     * An optional value that defines whether the original HTTP request URI is sent in the requestUri field of the JSON-encoded request.
     */
    forwardRequestUri: boolean;
    /**
     * The AWS Lambda function to invoke. Both function name and function ARN (including partial) are supported.
     */
    functionName: string;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * The InvocationType to use when invoking the function. Available types are RequestResponse, Event, DryRun. must be one of ["RequestResponse", "Event", "DryRun"]
     */
    invocationType: string;
    /**
     * An optional value that defines whether the response format to receive from the Lambda to this format.
     */
    isProxyIntegration: boolean;
    /**
     * An optional value in milliseconds that defines how long an idle connection lives before being closed.
     */
    keepalive: number;
    /**
     * The LogType to use when invoking the function. By default, None and Tail are supported. must be one of ["Tail", "None"]
     */
    logType: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    proxyUrl: string;
    /**
     * The qualifier to use when invoking the function.
     */
    qualifier: string;
    /**
     * An optional value that defines whether Kong should send large bodies that are buffered to disk
     */
    skipLargeBodies: boolean;
    /**
     * An optional timeout in milliseconds when invoking the function.
     */
    timeout: number;
    /**
     * The response status code to use (instead of the default 200, 202, or 204) in the case of an Unhandled Function Error.
     */
    unhandledStatus: number;
}

export interface GetGatewayPluginAwsLambdaConsumer {
    id: string;
}

export interface GetGatewayPluginAwsLambdaConsumerGroup {
    id: string;
}

export interface GetGatewayPluginAwsLambdaRoute {
    id: string;
}

export interface GetGatewayPluginAwsLambdaService {
    id: string;
}

export interface GetGatewayPluginBasicAuthConfig {
    /**
     * An optional string (Consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`. Please note that this value must refer to the Consumer `id` or `username` attribute, and **not** its `customId`.
     */
    anonymous: string;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin will strip the credential from the request (i.e. the `Authorization` header) before proxying it.
     */
    hideCredentials: boolean;
    /**
     * When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
     */
    realm: string;
}

export interface GetGatewayPluginBasicAuthConsumer {
    id: string;
}

export interface GetGatewayPluginBasicAuthConsumerGroup {
    id: string;
}

export interface GetGatewayPluginBasicAuthRoute {
    id: string;
}

export interface GetGatewayPluginBasicAuthService {
    id: string;
}

export interface GetGatewayPluginCorrelationIdConfig {
    /**
     * Whether to echo the header back to downstream (the client).
     */
    echoDownstream: boolean;
    /**
     * The generator to use for the correlation ID. Accepted values are `uuid`, `uuid#counter`, and `tracker`. See Generators. must be one of ["uuid", "uuid#counter", "tracker"]
     */
    generator: string;
    /**
     * The HTTP header name to use for the correlation ID.
     */
    headerName: string;
}

export interface GetGatewayPluginCorrelationIdConsumer {
    id: string;
}

export interface GetGatewayPluginCorrelationIdConsumerGroup {
    id: string;
}

export interface GetGatewayPluginCorrelationIdRoute {
    id: string;
}

export interface GetGatewayPluginCorrelationIdService {
    id: string;
}

export interface GetGatewayPluginCorsConfig {
    /**
     * Flag to determine whether the `Access-Control-Allow-Credentials` header should be sent with `true` as the value.
     */
    credentials: boolean;
    /**
     * Value for the `Access-Control-Expose-Headers` header. If not specified, no custom headers are exposed.
     */
    exposedHeaders: string[];
    /**
     * Value for the `Access-Control-Allow-Headers` header.
     */
    headers: string[];
    /**
     * Indicates how long the results of the preflight request can be cached, in `seconds`.
     */
    maxAge: number;
    /**
     * 'Value for the `Access-Control-Allow-Methods` header. Available options include `GET`, `HEAD`, `PUT`, `PATCH`, `POST`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`. By default, all options are allowed.'
     */
    methods: string[];
    /**
     * List of allowed domains for the `Access-Control-Allow-Origin` header. If you want to allow all origins, add `*` as a single value to this configuration field. The accepted values can either be flat strings or PCRE regexes.
     */
    origins: string[];
    /**
     * A boolean value that instructs the plugin to proxy the `OPTIONS` preflight request to the Upstream service.
     */
    preflightContinue: boolean;
    /**
     * Flag to determine whether the `Access-Control-Allow-Private-Network` header should be sent with `true` as the value.
     */
    privateNetwork: boolean;
}

export interface GetGatewayPluginCorsConsumer {
    id: string;
}

export interface GetGatewayPluginCorsConsumerGroup {
    id: string;
}

export interface GetGatewayPluginCorsRoute {
    id: string;
}

export interface GetGatewayPluginCorsService {
    id: string;
}

export interface GetGatewayPluginExitTransformerConfig {
    functions: string[];
    /**
     * Determines whether to handle unexpected errors by transforming their responses.
     */
    handleUnexpected: boolean;
    /**
     * Determines whether to handle unknown status codes by transforming their responses.
     */
    handleUnknown: boolean;
}

export interface GetGatewayPluginExitTransformerConsumer {
    id: string;
}

export interface GetGatewayPluginExitTransformerConsumerGroup {
    id: string;
}

export interface GetGatewayPluginExitTransformerRoute {
    id: string;
}

export interface GetGatewayPluginExitTransformerService {
    id: string;
}

export interface GetGatewayPluginFileLogConfig {
    /**
     * Lua code as a key-value map
     */
    customFieldsByLua: {[key: string]: string};
    /**
     * The file path of the output log file. The plugin creates the log file if it doesn't exist yet.
     */
    path: string;
    /**
     * Determines whether the log file is closed and reopened on every request.
     */
    reopen: boolean;
}

export interface GetGatewayPluginFileLogConsumer {
    id: string;
}

export interface GetGatewayPluginFileLogConsumerGroup {
    id: string;
}

export interface GetGatewayPluginFileLogRoute {
    id: string;
}

export interface GetGatewayPluginFileLogService {
    id: string;
}

export interface GetGatewayPluginIpRestrictionConfig {
    /**
     * List of IPs or CIDR ranges to allow. One of `config.allow` or `config.deny` must be specified.
     */
    allows: string[];
    /**
     * List of IPs or CIDR ranges to deny. One of `config.allow` or `config.deny` must be specified.
     */
    denies: string[];
    /**
     * The message to send as a response body to rejected requests.
     */
    message: string;
    /**
     * The HTTP status of the requests that will be rejected by the plugin.
     */
    status: number;
}

export interface GetGatewayPluginIpRestrictionConsumer {
    id: string;
}

export interface GetGatewayPluginIpRestrictionConsumerGroup {
    id: string;
}

export interface GetGatewayPluginIpRestrictionRoute {
    id: string;
}

export interface GetGatewayPluginIpRestrictionService {
    id: string;
}

export interface GetGatewayPluginJqConfig {
    requestIfMediaTypes: string[];
    requestJqProgram: string;
    requestJqProgramOptions: outputs.GetGatewayPluginJqConfigRequestJqProgramOptions;
    responseIfMediaTypes: string[];
    responseIfStatusCodes: number[];
    responseJqProgram: string;
    responseJqProgramOptions: outputs.GetGatewayPluginJqConfigResponseJqProgramOptions;
}

export interface GetGatewayPluginJqConfigRequestJqProgramOptions {
    asciiOutput: boolean;
    compactOutput: boolean;
    joinOutput: boolean;
    rawOutput: boolean;
    sortKeys: boolean;
}

export interface GetGatewayPluginJqConfigResponseJqProgramOptions {
    asciiOutput: boolean;
    compactOutput: boolean;
    joinOutput: boolean;
    rawOutput: boolean;
    sortKeys: boolean;
}

export interface GetGatewayPluginJqConsumer {
    id: string;
}

export interface GetGatewayPluginJqConsumerGroup {
    id: string;
}

export interface GetGatewayPluginJqRoute {
    id: string;
}

export interface GetGatewayPluginJqService {
    id: string;
}

export interface GetGatewayPluginJwtConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
     */
    anonymous: string;
    /**
     * A list of registered claims (according to RFC 7519) that Kong can verify as well. Accepted values: one of exp or nbf.
     */
    claimsToVerifies: string[];
    /**
     * A list of cookie names that Kong will inspect to retrieve JWTs.
     */
    cookieNames: string[];
    /**
     * A list of HTTP header names that Kong will inspect to retrieve JWTs.
     */
    headerNames: string[];
    /**
     * The name of the claim in which the key identifying the secret must be passed. The plugin will attempt to read this claim from the JWT payload and the header, in that order.
     */
    keyClaimName: string;
    /**
     * A value between 0 and 31536000 (365 days) limiting the lifetime of the JWT to maximumExpiration seconds in the future.
     */
    maximumExpiration: number;
    /**
     * A boolean value that indicates whether the plugin should run (and try to authenticate) on OPTIONS preflight requests. If set to false, then OPTIONS requests will always be allowed.
     */
    runOnPreflight: boolean;
    /**
     * If true, the plugin assumes the credential’s secret to be base64 encoded. You will need to create a base64-encoded secret for your Consumer, and sign your JWT with the original secret.
     */
    secretIsBase64: boolean;
    /**
     * A list of querystring parameters that Kong will inspect to retrieve JWTs.
     */
    uriParamNames: string[];
}

export interface GetGatewayPluginJwtConsumer {
    id: string;
}

export interface GetGatewayPluginJwtConsumerGroup {
    id: string;
}

export interface GetGatewayPluginJwtRoute {
    id: string;
}

export interface GetGatewayPluginJwtService {
    id: string;
}

export interface GetGatewayPluginJwtSignerConfig {
    /**
     * When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `customId`.
     */
    accessTokenConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
     */
    accessTokenConsumerClaims: string[];
    /**
     * If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
     */
    accessTokenIntrospectionAuthorization: string;
    /**
     * This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
     */
    accessTokenIntrospectionBodyArgs: string;
    /**
     * When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
     */
    accessTokenIntrospectionConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
     */
    accessTokenIntrospectionConsumerClaims: string[];
    /**
     * When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
     */
    accessTokenIntrospectionEndpoint: string;
    /**
     * If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
     */
    accessTokenIntrospectionHint: string;
    /**
     * If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
     */
    accessTokenIntrospectionJwtClaims: string[];
    /**
     * Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
     */
    accessTokenIntrospectionLeeway: number;
    /**
     * Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realmAccess", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
     */
    accessTokenIntrospectionScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
     */
    accessTokenIntrospectionScopesRequireds: string[];
    /**
     * Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
     */
    accessTokenIntrospectionTimeout: number;
    /**
     * The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `originalIss` claim of the newly signed access token.
     */
    accessTokenIssuer: string;
    /**
     * Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
     */
    accessTokenJwksUri: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenJwksUri` is an https uri that requires mTLS Auth.
     */
    accessTokenJwksUriClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `accessTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `accessTokenJwksUriClientUsername`
     */
    accessTokenJwksUriClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `accessTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `accessTokenJwksUriClientPassword`
     */
    accessTokenJwksUriClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `accessTokenJwksUri`. The default value 0 means no auto-rotation.
     */
    accessTokenJwksUriRotatePeriod: number;
    /**
     * The name of the keyset containing signing keys.
     */
    accessTokenKeyset: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenKeyset` is an https uri that requires mTLS Auth.
     */
    accessTokenKeysetClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `accessTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `accessTokenKeysetClientUsername`
     */
    accessTokenKeysetClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `accessTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `accessTokenKeysetClientPassword`
     */
    accessTokenKeysetClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `accessTokenKeyset`. The default value 0 means no auto-rotation.
     */
    accessTokenKeysetRotatePeriod: number;
    /**
     * Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
     */
    accessTokenLeeway: number;
    /**
     * If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
     */
    accessTokenOptional: boolean;
    /**
     * This parameter tells the name of the header where to look for the access token.
     */
    accessTokenRequestHeader: string;
    /**
     * Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
     */
    accessTokenScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
     */
    accessTokenScopesRequireds: string[];
    /**
     * When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
     */
    accessTokenSigningAlgorithm: string;
    /**
     * Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
     */
    accessTokenUpstreamHeader: string;
    /**
     * If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
     */
    accessTokenUpstreamLeeway: number;
    /**
     * Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addAccessTokenClaims: {[key: string]: string};
    /**
     * Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addChannelTokenClaims: {[key: string]: string};
    /**
     * Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    addClaims: {[key: string]: string};
    /**
     * Whether to cache access token introspection results.
     */
    cacheAccessTokenIntrospection: boolean;
    /**
     * Whether to cache channel token introspection results.
     */
    cacheChannelTokenIntrospection: boolean;
    /**
     * When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `customId`.
     */
    channelTokenConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `customId`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
     */
    channelTokenConsumerClaims: string[];
    /**
     * When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
     */
    channelTokenIntrospectionAuthorization: string;
    /**
     * If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
     */
    channelTokenIntrospectionBodyArgs: string;
    /**
     * When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `customId`.
     */
    channelTokenIntrospectionConsumerBies: string[];
    /**
     * When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
     */
    channelTokenIntrospectionConsumerClaims: string[];
    /**
     * When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
     */
    channelTokenIntrospectionEndpoint: string;
    /**
     * If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
     */
    channelTokenIntrospectionHint: string;
    /**
     * If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
     */
    channelTokenIntrospectionJwtClaims: string[];
    /**
     * You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
     */
    channelTokenIntrospectionLeeway: number;
    /**
     * Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
     */
    channelTokenIntrospectionScopesClaims: string[];
    /**
     * Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
     */
    channelTokenIntrospectionScopesRequireds: string[];
    /**
     * Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
     */
    channelTokenIntrospectionTimeout: number;
    /**
     * The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `originalIss` claim of the newly signed channel token.
     */
    channelTokenIssuer: string;
    /**
     * If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
     */
    channelTokenJwksUri: string;
    /**
     * The client certificate that will be used to authenticate Kong if `accessTokenJwksUri` is an https uri that requires mTLS Auth.
     */
    channelTokenJwksUriClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `channelTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `channelTokenJwksUriClientUsername`
     */
    channelTokenJwksUriClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `channelTokenJwksUri` is a uri that requires Basic Auth. Should be configured together with `channelTokenJwksUriClientPassword`
     */
    channelTokenJwksUriClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `channelTokenJwksUri`. The default value 0 means no auto-rotation.
     */
    channelTokenJwksUriRotatePeriod: number;
    /**
     * The name of the keyset containing signing keys.
     */
    channelTokenKeyset: string;
    /**
     * The client certificate that will be used to authenticate Kong if `channelTokenKeyset` is an https uri that requires mTLS Auth.
     */
    channelTokenKeysetClientCertificate: string;
    /**
     * The client password that will be used to authenticate Kong if `channelTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `channelTokenKeysetClientUsername`
     */
    channelTokenKeysetClientPassword: string;
    /**
     * The client username that will be used to authenticate Kong if `channelTokenKeyset` is a uri that requires Basic Auth. Should be configured together with `channelTokenKeysetClientPassword`
     */
    channelTokenKeysetClientUsername: string;
    /**
     * Specify the period (in seconds) to auto-rotate the jwks for `channelTokenKeyset`. The default value 0 means no auto-rotation.
     */
    channelTokenKeysetRotatePeriod: number;
    /**
     * Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
     */
    channelTokenLeeway: number;
    /**
     * If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
     */
    channelTokenOptional: boolean;
    /**
     * This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
     */
    channelTokenRequestHeader: string;
    /**
     * Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
     */
    channelTokenScopesClaims: string[];
    /**
     * Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
     */
    channelTokenScopesRequireds: string[];
    /**
     * When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token. must be one of ["HS256", "HS384", "HS512", "RS256", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512", "EdDSA"]
     */
    channelTokenSigningAlgorithm: string;
    /**
     * This plugin removes the `config.channel_token_request_header` from the request after reading its value.
     */
    channelTokenUpstreamHeader: string;
    /**
     * If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
     */
    channelTokenUpstreamLeeway: number;
    /**
     * If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
     */
    enableAccessTokenIntrospection: boolean;
    /**
     * If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
     */
    enableChannelTokenIntrospection: boolean;
    /**
     * Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
     */
    enableHsSignatures: boolean;
    /**
     * Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
     */
    enableInstrumentation: boolean;
    /**
     * The HTTP header name used to store the original access token.
     */
    originalAccessTokenUpstreamHeader: string;
    /**
     * The HTTP header name used to store the original channel token.
     */
    originalChannelTokenUpstreamHeader: string;
    /**
     * When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
     */
    realm: string;
    /**
     * remove claims. It should be an array, and each element is a claim key string.
     */
    removeAccessTokenClaims: string[];
    /**
     * remove claims. It should be an array, and each element is a claim key string.
     */
    removeChannelTokenClaims: string[];
    /**
     * Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setAccessTokenClaims: {[key: string]: string};
    /**
     * Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setChannelTokenClaims: {[key: string]: string};
    /**
     * Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
     */
    setClaims: {[key: string]: string};
    /**
     * Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
     */
    trustAccessTokenIntrospection: boolean;
    /**
     * Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel_token_introspection_jwt_claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
     */
    trustChannelTokenIntrospection: boolean;
    /**
     * Quickly turn access token expiry verification off and on as needed.
     */
    verifyAccessTokenExpiry: boolean;
    /**
     * Quickly turn access token introspection expiry verification off and on as needed.
     */
    verifyAccessTokenIntrospectionExpiry: boolean;
    /**
     * Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
     */
    verifyAccessTokenIntrospectionScopes: boolean;
    /**
     * Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
     */
    verifyAccessTokenScopes: boolean;
    /**
     * Quickly turn access token signature verification off and on as needed.
     */
    verifyAccessTokenSignature: boolean;
    verifyChannelTokenExpiry: boolean;
    /**
     * Quickly turn on/off the channel token introspection expiry verification.
     */
    verifyChannelTokenIntrospectionExpiry: boolean;
    /**
     * Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
     */
    verifyChannelTokenIntrospectionScopes: boolean;
    /**
     * Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
     */
    verifyChannelTokenScopes: boolean;
    /**
     * Quickly turn on/off the channel token signature verification.
     */
    verifyChannelTokenSignature: boolean;
}

export interface GetGatewayPluginJwtSignerConsumer {
    id: string;
}

export interface GetGatewayPluginJwtSignerConsumerGroup {
    id: string;
}

export interface GetGatewayPluginJwtSignerRoute {
    id: string;
}

export interface GetGatewayPluginJwtSignerService {
    id: string;
}

export interface GetGatewayPluginKeyAuthConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails. If empty (default null), the request will fail with an authentication failure `4xx`.
     */
    anonymous: string;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service. If `true`, the plugin strips the credential from the request.
     */
    hideCredentials: boolean;
    /**
     * If enabled, the plugin reads the request body. Supported MIME types: `application/www-form-urlencoded`, `application/json`, and `multipart/form-data`.
     */
    keyInBody: boolean;
    /**
     * If enabled (default), the plugin reads the request header and tries to find the key in it.
     */
    keyInHeader: boolean;
    /**
     * If enabled (default), the plugin reads the query parameter in the request and tries to find the key in it.
     */
    keyInQuery: boolean;
    /**
     * Describes an array of parameter names where the plugin will look for a key. The key names may only contain [a-z], [A-Z], [0-9], [_] underscore, and [-] hyphen.
     */
    keyNames: string[];
    /**
     * When authentication fails the plugin sends `WWW-Authenticate` header with `realm` attribute value.
     */
    realm: string;
    /**
     * A boolean value that indicates whether the plugin should run (and try to authenticate) on `OPTIONS` preflight requests. If set to `false`, then `OPTIONS` requests are always allowed.
     */
    runOnPreflight: boolean;
}

export interface GetGatewayPluginKeyAuthConsumer {
    id: string;
}

export interface GetGatewayPluginKeyAuthConsumerGroup {
    id: string;
}

export interface GetGatewayPluginKeyAuthRoute {
    id: string;
}

export interface GetGatewayPluginKeyAuthService {
    id: string;
}

export interface GetGatewayPluginOauth2Config {
    /**
     * Accepts HTTPs requests that have already been terminated by a proxy or load balancer.
     */
    acceptHttpIfAlreadyTerminated: boolean;
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer if authentication fails.
     */
    anonymous: string;
    /**
     * The name of the header that is supposed to carry the access token.
     */
    authHeaderName: string;
    /**
     * An optional boolean value to enable the three-legged Authorization Code flow (RFC 6742 Section 4.1).
     */
    enableAuthorizationCode: boolean;
    /**
     * An optional boolean value to enable the Client Credentials Grant flow (RFC 6742 Section 4.4).
     */
    enableClientCredentials: boolean;
    /**
     * An optional boolean value to enable the Implicit Grant flow which allows to provision a token as a result of the authorization process (RFC 6742 Section 4.2).
     */
    enableImplicitGrant: boolean;
    /**
     * An optional boolean value to enable the Resource Owner Password Credentials Grant flow (RFC 6742 Section 4.3).
     */
    enablePasswordGrant: boolean;
    /**
     * An optional boolean value that allows using the same OAuth credentials generated by the plugin with any other service whose OAuth 2.0 plugin configuration also has `config.global_credentials=true`.
     */
    globalCredentials: boolean;
    /**
     * An optional boolean value telling the plugin to show or hide the credential from the upstream service.
     */
    hideCredentials: boolean;
    /**
     * An optional boolean value telling the plugin to require at least one `scope` to be authorized by the end user.
     */
    mandatoryScope: boolean;
    persistentRefreshToken: boolean;
    /**
     * Specifies a mode of how the Proof Key for Code Exchange (PKCE) should be handled by the plugin. must be one of ["none", "lax", "strict"]
     */
    pkce: string;
    /**
     * The unique key the plugin has generated when it has been added to the Service.
     */
    provisionKey: string;
    /**
     * Time-to-live value for data
     */
    refreshTokenTtl: number;
    /**
     * An optional boolean value that indicates whether an OAuth refresh token is reused when refreshing an access token.
     */
    reuseRefreshToken: boolean;
    /**
     * Describes an array of scope names that will be available to the end user. If `mandatoryScope` is set to `true`, then `scopes` are required.
     */
    scopes: string[];
    /**
     * An optional integer value telling the plugin how many seconds a token should last, after which the client will need to refresh the token. Set to `0` to disable the expiration.
     */
    tokenExpiration: number;
}

export interface GetGatewayPluginOauth2Consumer {
    id: string;
}

export interface GetGatewayPluginOauth2ConsumerGroup {
    id: string;
}

export interface GetGatewayPluginOauth2Route {
    id: string;
}

export interface GetGatewayPluginOauth2Service {
    id: string;
}

export interface GetGatewayPluginOpenidConnectConfig {
    /**
     * An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `customId`.
     */
    anonymous: string;
    /**
     * The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    audienceClaims: string[];
    /**
     * The audiences (`audienceClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    audienceRequireds: string[];
    /**
     * The audience passed to the authorization endpoint.
     */
    audiences: string[];
    /**
     * Types of credentials/grants to enable.
     */
    authMethods: string[];
    /**
     * The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    authenticatedGroupsClaims: string[];
    /**
     * The authorization cookie Domain flag.
     */
    authorizationCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    authorizationCookieHttpOnly: boolean;
    /**
     * The authorization cookie name.
     */
    authorizationCookieName: string;
    /**
     * The authorization cookie Path flag.
     */
    authorizationCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    authorizationCookieSameSite: string;
    /**
     * Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    authorizationCookieSecure: boolean;
    /**
     * The authorization endpoint. If set it overrides the value in `authorizationEndpoint` returned by the discovery endpoint.
     */
    authorizationEndpoint: string;
    /**
     * Extra query arguments passed from the client to the authorization endpoint.
     */
    authorizationQueryArgsClients: string[];
    /**
     * Extra query argument names passed to the authorization endpoint.
     */
    authorizationQueryArgsNames: string[];
    /**
     * Extra query argument values passed to the authorization endpoint.
     */
    authorizationQueryArgsValues: string[];
    /**
     * Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
     */
    authorizationRollingTimeout: number;
    /**
     * The name of the cookie in which the bearer token is passed.
     */
    bearerTokenCookieName: string;
    /**
     * Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
     */
    bearerTokenParamTypes: string[];
    /**
     * If `consumerBy` is set to `username`, specify whether `username` can match consumers case-insensitively.
     */
    byUsernameIgnoreCase: boolean;
    /**
     * Cache the introspection endpoint requests.
     */
    cacheIntrospection: boolean;
    /**
     * Cache the token exchange endpoint requests.
     */
    cacheTokenExchange: boolean;
    /**
     * Cache the token endpoint requests.
     */
    cacheTokens: boolean;
    /**
     * Salt used for generating the cache key that is used for caching the token endpoint requests.
     */
    cacheTokensSalt: string;
    /**
     * The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
     */
    cacheTtl: number;
    /**
     * The maximum cache ttl in seconds (enforced).
     */
    cacheTtlMax: number;
    /**
     * The minimum cache ttl in seconds (enforced).
     */
    cacheTtlMin: number;
    /**
     * The negative cache ttl in seconds.
     */
    cacheTtlNeg: number;
    /**
     * The resurrection ttl in seconds.
     */
    cacheTtlResurrect: number;
    /**
     * Cache the user info requests.
     */
    cacheUserInfo: boolean;
    /**
     * The algorithm to use for clientSecretJwt (only HS***) or privateKeyJwt authentication.
     */
    clientAlgs: string[];
    /**
     * The client to use for this request (the selection is made with a request parameter with the same name).
     */
    clientArg: string;
    /**
     * The default OpenID Connect client authentication method is 'client_secret_basic' (using 'Authorization: Basic' header), 'client_secret_post' (credentials in body), 'client_secret_jwt' (signed client assertion in body), 'private_key_jwt' (private key-signed assertion), 'tls_client_auth' (client certificate), 'self_signed_tls_client_auth' (self-signed client certificate), and 'none' (no authentication).
     */
    clientAuths: string[];
    /**
     * Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
     */
    clientCredentialsParamTypes: string[];
    /**
     * The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
     */
    clientIds: string[];
    /**
     * The JWK used for the privateKeyJwt authentication.
     */
    clientJwks: outputs.GetGatewayPluginOpenidConnectConfigClientJwk[];
    /**
     * The client secret.
     */
    clientSecrets: string[];
    /**
     * Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `customId`: try to find the matching Consumer by `customId`.
     */
    consumerBies: string[];
    /**
     * The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    consumerClaims: string[];
    /**
     * Do not terminate the request if consumer mapping fails.
     */
    consumerOptional: boolean;
    /**
     * The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    credentialClaims: string[];
    /**
     * Disable issuing the session cookie with the specified grants.
     */
    disableSessions: string[];
    /**
     * Extra header names passed to the discovery endpoint.
     */
    discoveryHeadersNames: string[];
    /**
     * Extra header values passed to the discovery endpoint.
     */
    discoveryHeadersValues: string[];
    /**
     * Display errors on failure responses.
     */
    displayErrors: boolean;
    /**
     * The allowed values for the `hd` claim.
     */
    domains: string[];
    /**
     * The downstream access token header.
     */
    downstreamAccessTokenHeader: string;
    /**
     * The downstream access token JWK header.
     */
    downstreamAccessTokenJwkHeader: string;
    /**
     * The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    downstreamHeadersClaims: string[];
    /**
     * The downstream header names for the claim values.
     */
    downstreamHeadersNames: string[];
    /**
     * The downstream id token header.
     */
    downstreamIdTokenHeader: string;
    /**
     * The downstream id token JWK header.
     */
    downstreamIdTokenJwkHeader: string;
    /**
     * The downstream introspection header.
     */
    downstreamIntrospectionHeader: string;
    /**
     * The downstream introspection JWT header.
     */
    downstreamIntrospectionJwtHeader: string;
    /**
     * The downstream refresh token header.
     */
    downstreamRefreshTokenHeader: string;
    /**
     * The downstream session id header.
     */
    downstreamSessionIdHeader: string;
    /**
     * The downstream user info header.
     */
    downstreamUserInfoHeader: string;
    /**
     * The downstream user info JWT header (in case the user info returns a JWT response).
     */
    downstreamUserInfoJwtHeader: string;
    /**
     * Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
     */
    dpopProofLifetime: number;
    /**
     * Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
     */
    dpopUseNonce: boolean;
    /**
     * Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
     */
    enableHsSignatures: boolean;
    /**
     * The end session endpoint. If set it overrides the value in `endSessionEndpoint` returned by the discovery endpoint.
     */
    endSessionEndpoint: string;
    /**
     * Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
     */
    exposeErrorCode: boolean;
    /**
     * JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
     */
    extraJwksUris: string[];
    /**
     * Destroy any active session for the forbidden requests.
     */
    forbiddenDestroySession: boolean;
    /**
     * The error message for the forbidden requests (when not using the redirection).
     */
    forbiddenErrorMessage: string;
    /**
     * Where to redirect the client on forbidden requests.
     */
    forbiddenRedirectUris: string[];
    /**
     * The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    groupsClaims: string[];
    /**
     * The groups (`groupsClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    groupsRequireds: string[];
    /**
     * Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
     */
    hideCredentials: boolean;
    /**
     * The HTTP proxy.
     */
    httpProxy: string;
    /**
     * The HTTP proxy authorization.
     */
    httpProxyAuthorization: string;
    /**
     * The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
     */
    httpVersion: number;
    /**
     * The HTTPS proxy.
     */
    httpsProxy: string;
    /**
     * The HTTPS proxy authorization.
     */
    httpsProxyAuthorization: string;
    /**
     * The name of the parameter used to pass the id token.
     */
    idTokenParamName: string;
    /**
     * Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    idTokenParamTypes: string[];
    /**
     * Skip the token signature verification on certain grants: - `password`: OAuth password grant - `clientCredentials`: OAuth client credentials grant - `authorizationCode`: authorization code flow - `refreshToken`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
     */
    ignoreSignatures: string[];
    /**
     * Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
     */
    introspectJwtTokens: boolean;
    /**
     * The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
     */
    introspectionAccept: string;
    /**
     * Check that the introspection response has an `active` claim with a value of `true`.
     */
    introspectionCheckActive: boolean;
    /**
     * The introspection endpoint. If set it overrides the value in `introspectionEndpoint` returned by the discovery endpoint.
     */
    introspectionEndpoint: string;
    /**
     * The introspection endpoint authentication method: : `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    introspectionEndpointAuthMethod: string;
    /**
     * Extra headers passed from the client to the introspection endpoint.
     */
    introspectionHeadersClients: string[];
    /**
     * Extra header names passed to the introspection endpoint.
     */
    introspectionHeadersNames: string[];
    /**
     * Extra header values passed to the introspection endpoint.
     */
    introspectionHeadersValues: string[];
    /**
     * Introspection hint parameter value passed to the introspection endpoint.
     */
    introspectionHint: string;
    /**
     * Extra post arguments passed from the client to the introspection endpoint.
     */
    introspectionPostArgsClients: string[];
    /**
     * Extra post argument names passed to the introspection endpoint.
     */
    introspectionPostArgsNames: string[];
    /**
     * Extra post argument values passed to the introspection endpoint.
     */
    introspectionPostArgsValues: string[];
    /**
     * Designate token's parameter name for introspection.
     */
    introspectionTokenParamName: string;
    /**
     * The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
     */
    issuer: string;
    /**
     * The issuers allowed to be present in the tokens (`iss` claim).
     */
    issuersAlloweds: string[];
    /**
     * The claim to match against the JWT session cookie.
     */
    jwtSessionClaim: string;
    /**
     * The name of the JWT session cookie.
     */
    jwtSessionCookie: string;
    /**
     * Use keepalive with the HTTP client.
     */
    keepalive: boolean;
    /**
     * Defines leeway time (in seconds) for `authTime`, `exp`, `iat`, and `nbf` claims
     */
    leeway: number;
    /**
     * What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
     */
    loginAction: string;
    /**
     * Enable login functionality with specified grants.
     */
    loginMethods: string[];
    /**
     * Where to place `loginTokens` when using `redirect` `loginAction`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
     */
    loginRedirectMode: string;
    /**
     * Where to redirect the client when `loginAction` is set to `redirect`.
     */
    loginRedirectUris: string[];
    /**
     * What tokens to include in `response` body or `redirect` query string or fragment: - `idToken`: include id token - `accessToken`: include access token - `refreshToken`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
     */
    loginTokens: string[];
    /**
     * The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
     */
    logoutMethods: string[];
    /**
     * The request body argument that activates the logout.
     */
    logoutPostArg: string;
    /**
     * The request query argument that activates the logout.
     */
    logoutQueryArg: string;
    /**
     * Where to redirect the client after the logout.
     */
    logoutRedirectUris: string[];
    /**
     * Revoke tokens as part of the logout.
     *
     * For more granular token revocation, you can also adjust the `logoutRevokeAccessToken` and `logoutRevokeRefreshToken` parameters.
     */
    logoutRevoke: boolean;
    /**
     * Revoke the access token as part of the logout. Requires `logoutRevoke` to be set to `true`.
     */
    logoutRevokeAccessToken: boolean;
    /**
     * Revoke the refresh token as part of the logout. Requires `logoutRevoke` to be set to `true`.
     */
    logoutRevokeRefreshToken: boolean;
    /**
     * The request URI suffix that activates the logout.
     */
    logoutUriSuffix: string;
    /**
     * The maximum age (in seconds) compared to the `authTime` claim.
     */
    maxAge: number;
    /**
     * Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsIntrospectionEndpoint: string;
    /**
     * Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsRevocationEndpoint: string;
    /**
     * Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtlsEndpointAliases` returned by the discovery endpoint.
     */
    mtlsTokenEndpoint: string;
    /**
     * Do not use proxy with these hosts.
     */
    noProxy: string;
    /**
     * Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    passwordParamTypes: string[];
    /**
     * With this parameter, you can preserve request query arguments even when doing authorization code flow.
     */
    preserveQueryArgs: boolean;
    /**
     * If set to true, only the authMethods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all authMethods will be configurable and PoP checks will be silently skipped for those authMethods that are not compatible with PoP.
     */
    proofOfPossessionAuthMethodsValidation: boolean;
    /**
     * Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
     */
    proofOfPossessionDpop: string;
    /**
     * Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
     */
    proofOfPossessionMtls: string;
    /**
     * The pushed authorization endpoint. If set it overrides the value in `pushedAuthorizationRequestEndpoint` returned by the discovery endpoint.
     */
    pushedAuthorizationRequestEndpoint: string;
    /**
     * The pushed authorization request endpoint authentication method: `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    pushedAuthorizationRequestEndpointAuthMethod: string;
    /**
     * The redirect URI passed to the authorization and token endpoints.
     */
    redirectUris: string[];
    /**
     * Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
     */
    rediscoveryLifetime: number;
    /**
     * The name of the parameter used to pass the refresh token.
     */
    refreshTokenParamName: string;
    /**
     * Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
     */
    refreshTokenParamTypes: string[];
    /**
     * Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refreshToken` available.
     */
    refreshTokens: boolean;
    /**
     * Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `codeChallengeMethodsSupported`, and enabled automatically (in case the `codeChallengeMethodsSupported` is missing, the PKCE will not be enabled).
     */
    requireProofKeyForCodeExchange: boolean;
    /**
     * Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `requirePushedAuthorizationRequests` (which defaults to `false`).
     */
    requirePushedAuthorizationRequests: boolean;
    /**
     * Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `requireSignedRequestObject`, and enabled automatically (in case the `requireSignedRequestObject` is missing, the feature will not be enabled).
     */
    requireSignedRequestObject: boolean;
    /**
     * Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
     */
    resolveDistributedClaims: boolean;
    /**
     * Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `formPost`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `formPost` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "formPost", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
     */
    responseMode: string;
    /**
     * The response type passed to the authorization endpoint.
     */
    responseTypes: string[];
    /**
     * Specifies whether to always verify tokens stored in the session.
     */
    reverify: boolean;
    /**
     * The revocation endpoint. If set it overrides the value in `revocationEndpoint` returned by the discovery endpoint.
     */
    revocationEndpoint: string;
    /**
     * The revocation endpoint authentication method: : `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    revocationEndpointAuthMethod: string;
    /**
     * Designate token's parameter name for revocation.
     */
    revocationTokenParamName: string;
    /**
     * The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    rolesClaims: string[];
    /**
     * The roles (`rolesClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    rolesRequireds: string[];
    /**
     * Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
     */
    runOnPreflight: boolean;
    /**
     * The scopes passed to the authorization and token endpoints.
     */
    scopes: string[];
    /**
     * The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    scopesClaims: string[];
    /**
     * The scopes (`scopesClaim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
     */
    scopesRequireds: string[];
    /**
     * Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
     */
    searchUserInfo: boolean;
    /**
     * Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
     */
    sessionAbsoluteTimeout: number;
    /**
     * The session audience, which is the intended target application. For example `"my-application"`.
     */
    sessionAudience: string;
    /**
     * The session cookie Domain flag.
     */
    sessionCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    sessionCookieHttpOnly: boolean;
    /**
     * The session cookie name.
     */
    sessionCookieName: string;
    /**
     * The session cookie Path flag.
     */
    sessionCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    sessionCookieSameSite: string;
    /**
     * Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    sessionCookieSecure: boolean;
    /**
     * When set to `true`, audiences are forced to share the same subject.
     */
    sessionEnforceSameSubject: boolean;
    /**
     * When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
     */
    sessionHashStorageKey: boolean;
    /**
     * When set to `true`, the value of subject is hashed before being stored. Only applies when `sessionStoreMetadata` is enabled.
     */
    sessionHashSubject: boolean;
    /**
     * Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
     */
    sessionIdlingTimeout: number;
    /**
     * The memcached host.
     */
    sessionMemcachedHost: string;
    /**
     * The memcached port.
     */
    sessionMemcachedPort: number;
    /**
     * The memcached session key prefix.
     */
    sessionMemcachedPrefix: string;
    /**
     * The memcached unix socket path.
     */
    sessionMemcachedSocket: string;
    /**
     * The Redis cluster maximum redirects.
     */
    sessionRedisClusterMaxRedirections: number;
    /**
     * The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
     */
    sessionRedisClusterNodes: outputs.GetGatewayPluginOpenidConnectConfigSessionRedisClusterNode[];
    /**
     * Session redis connection timeout in milliseconds.
     */
    sessionRedisConnectTimeout: number;
    /**
     * The Redis host.
     */
    sessionRedisHost: string;
    /**
     * Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
     */
    sessionRedisPassword: string;
    /**
     * The Redis port.
     */
    sessionRedisPort: number;
    /**
     * The Redis session key prefix.
     */
    sessionRedisPrefix: string;
    /**
     * Session redis read timeout in milliseconds.
     */
    sessionRedisReadTimeout: number;
    /**
     * Session redis send timeout in milliseconds.
     */
    sessionRedisSendTimeout: number;
    /**
     * The SNI used for connecting the Redis server.
     */
    sessionRedisServerName: string;
    /**
     * The Redis unix socket path.
     */
    sessionRedisSocket: string;
    /**
     * Use SSL/TLS for Redis connection.
     */
    sessionRedisSsl: boolean;
    /**
     * Verify identity provider server certificate.
     */
    sessionRedisSslVerify: boolean;
    /**
     * Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    sessionRedisUsername: string;
    /**
     * Enables or disables persistent sessions.
     */
    sessionRemember: boolean;
    /**
     * Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
     */
    sessionRememberAbsoluteTimeout: number;
    /**
     * Persistent session cookie name. Use with the `remember` configuration parameter.
     */
    sessionRememberCookieName: string;
    /**
     * Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
     */
    sessionRememberRollingTimeout: number;
    /**
     * Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
     */
    sessionRequestHeaders: string[];
    /**
     * Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
     */
    sessionResponseHeaders: string[];
    /**
     * Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
     */
    sessionRollingTimeout: number;
    /**
     * The session secret.
     */
    sessionSecret: string;
    /**
     * The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
     */
    sessionStorage: string;
    /**
     * Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
     */
    sessionStoreMetadata: boolean;
    /**
     * Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `luaSslTrustedCertificate`.
     */
    sslVerify: boolean;
    /**
     * Network IO timeout in milliseconds.
     */
    timeout: number;
    /**
     * ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
     */
    tlsClientAuthCertId: string;
    /**
     * Verify identity provider server certificate during mTLS client authentication.
     */
    tlsClientAuthSslVerify: boolean;
    /**
     * Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
     */
    tokenCacheKeyIncludeScope: boolean;
    /**
     * The token endpoint. If set it overrides the value in `tokenEndpoint` returned by the discovery endpoint.
     */
    tokenEndpoint: string;
    /**
     * The token endpoint authentication method: `clientSecretBasic`, `clientSecretPost`, `clientSecretJwt`, `privateKeyJwt`, `tlsClientAuth`, `selfSignedTlsClientAuth`, or `none`: do not authenticate. must be one of ["clientSecretBasic", "clientSecretPost", "clientSecretJwt", "privateKeyJwt", "tlsClientAuth", "selfSignedTlsClientAuth", "none"]
     */
    tokenEndpointAuthMethod: string;
    /**
     * The token exchange endpoint.
     */
    tokenExchangeEndpoint: string;
    /**
     * Extra headers passed from the client to the token endpoint.
     */
    tokenHeadersClients: string[];
    /**
     * Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `clientCredentials`: with OAuth client credentials grant - `authorizationCode`: with authorization code flow - `refreshToken` with refresh token grant.
     */
    tokenHeadersGrants: string[];
    /**
     * Extra header names passed to the token endpoint.
     */
    tokenHeadersNames: string[];
    /**
     * Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
     */
    tokenHeadersPrefix: string;
    /**
     * The names of token endpoint response headers to forward to the downstream client.
     */
    tokenHeadersReplays: string[];
    /**
     * Extra header values passed to the token endpoint.
     */
    tokenHeadersValues: string[];
    /**
     * Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
     */
    tokenPostArgsClients: string[];
    /**
     * Extra post argument names passed to the token endpoint.
     */
    tokenPostArgsNames: string[];
    /**
     * Extra post argument values passed to the token endpoint.
     */
    tokenPostArgsValues: string[];
    /**
     * Destroy any active session for the unauthorized requests.
     */
    unauthorizedDestroySession: boolean;
    /**
     * The error message for the unauthorized requests (when not using the redirection).
     */
    unauthorizedErrorMessage: string;
    /**
     * Where to redirect the client on unauthorized requests.
     */
    unauthorizedRedirectUris: string[];
    /**
     * Where to redirect the client when unexpected errors happen with the requests.
     */
    unexpectedRedirectUris: string[];
    /**
     * The upstream access token header.
     */
    upstreamAccessTokenHeader: string;
    /**
     * The upstream access token JWK header.
     */
    upstreamAccessTokenJwkHeader: string;
    /**
     * The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
     */
    upstreamHeadersClaims: string[];
    /**
     * The upstream header names for the claim values.
     */
    upstreamHeadersNames: string[];
    /**
     * The upstream id token header.
     */
    upstreamIdTokenHeader: string;
    /**
     * The upstream id token JWK header.
     */
    upstreamIdTokenJwkHeader: string;
    /**
     * The upstream introspection header.
     */
    upstreamIntrospectionHeader: string;
    /**
     * The upstream introspection JWT header.
     */
    upstreamIntrospectionJwtHeader: string;
    /**
     * The upstream refresh token header.
     */
    upstreamRefreshTokenHeader: string;
    /**
     * The upstream session id header.
     */
    upstreamSessionIdHeader: string;
    /**
     * The upstream user info header.
     */
    upstreamUserInfoHeader: string;
    /**
     * The upstream user info JWT header (in case the user info returns a JWT response).
     */
    upstreamUserInfoJwtHeader: string;
    /**
     * The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
     */
    userinfoAccept: string;
    /**
     * The user info endpoint. If set it overrides the value in `userinfoEndpoint` returned by the discovery endpoint.
     */
    userinfoEndpoint: string;
    /**
     * Extra headers passed from the client to the user info endpoint.
     */
    userinfoHeadersClients: string[];
    /**
     * Extra header names passed to the user info endpoint.
     */
    userinfoHeadersNames: string[];
    /**
     * Extra header values passed to the user info endpoint.
     */
    userinfoHeadersValues: string[];
    /**
     * Extra query arguments passed from the client to the user info endpoint.
     */
    userinfoQueryArgsClients: string[];
    /**
     * Extra query argument names passed to the user info endpoint.
     */
    userinfoQueryArgsNames: string[];
    /**
     * Extra query argument values passed to the user info endpoint.
     */
    userinfoQueryArgsValues: string[];
    /**
     * If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
     */
    usingPseudoIssuer: boolean;
    /**
     * Verify tokens for standard claims.
     */
    verifyClaims: boolean;
    /**
     * Verify nonce on authorization code flow.
     */
    verifyNonce: boolean;
    /**
     * Verify plugin configuration against discovery.
     */
    verifyParameters: boolean;
    /**
     * Verify signature of tokens.
     */
    verifySignature: boolean;
}

export interface GetGatewayPluginOpenidConnectConfigClientJwk {
    alg: string;
    crv: string;
    d: string;
    dp: string;
    dq: string;
    e: string;
    issuer: string;
    k: string;
    keyOps: string[];
    kid: string;
    kty: string;
    n: string;
    oth: string;
    p: string;
    q: string;
    qi: string;
    r: string;
    t: string;
    use: string;
    x: string;
    x5cs: string[];
    x5t: string;
    x5tNumberS256: string;
    x5u: string;
    y: string;
}

export interface GetGatewayPluginOpenidConnectConfigSessionRedisClusterNode {
    /**
     * A string representing a host name, such as example.com.
     */
    ip: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
}

export interface GetGatewayPluginOpenidConnectConsumer {
    id: string;
}

export interface GetGatewayPluginOpenidConnectConsumerGroup {
    id: string;
}

export interface GetGatewayPluginOpenidConnectRoute {
    id: string;
}

export interface GetGatewayPluginOpenidConnectService {
    id: string;
}

export interface GetGatewayPluginOpentelemetryConfig {
    /**
     * The delay, in seconds, between two consecutive batches.
     */
    batchFlushDelay: number;
    /**
     * The number of spans to be sent in a single batch.
     */
    batchSpanCount: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    connectTimeout: number;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    endpoint: string;
    /**
     * must be one of ["preserve", "ignore", "b3", "b3-single", "w3c", "jaeger", "ot", "aws", "gcp", "datadog"]
     */
    headerType: string;
    /**
     * The custom headers to be added in the HTTP request sent to the OTLP server. This setting is useful for adding the authentication headers (token) for the APM backend.
     */
    headers: {[key: string]: string};
    httpResponseHeaderForTraceid: string;
    propagation: outputs.GetGatewayPluginOpentelemetryConfigPropagation;
    queue: outputs.GetGatewayPluginOpentelemetryConfigQueue;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    readTimeout: number;
    resourceAttributes: {[key: string]: string};
    /**
     * Tracing sampling rate for configuring the probability-based sampler. When set, this value supersedes the global `tracingSamplingRate` setting from kong.conf.
     */
    samplingRate: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    sendTimeout: number;
}

export interface GetGatewayPluginOpentelemetryConfigPropagation {
    /**
     * Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
     */
    clears: string[];
    /**
     * The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`. must be one of ["b3", "gcp", "b3-single", "jaeger", "aws", "ot", "w3c", "datadog"]
     */
    defaultFormat: string;
    /**
     * Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
     */
    extracts: string[];
    /**
     * Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
     */
    injects: string[];
}

export interface GetGatewayPluginOpentelemetryConfigQueue {
    /**
     * Time in seconds before the initial retry is made for a failing batch.
     */
    initialRetryDelay: number;
    /**
     * Maximum number of entries that can be processed at a time.
     */
    maxBatchSize: number;
    /**
     * Maximum number of bytes that can be waiting on a queue, requires string content.
     */
    maxBytes: number;
    /**
     * Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
     */
    maxCoalescingDelay: number;
    /**
     * Maximum number of entries that can be waiting on the queue.
     */
    maxEntries: number;
    /**
     * Maximum time in seconds between retries, caps exponential backoff.
     */
    maxRetryDelay: number;
    /**
     * Time in seconds before the queue gives up calling a failed handler for a batch.
     */
    maxRetryTime: number;
}

export interface GetGatewayPluginOpentelemetryConsumer {
    id: string;
}

export interface GetGatewayPluginOpentelemetryConsumerGroup {
    id: string;
}

export interface GetGatewayPluginOpentelemetryRoute {
    id: string;
}

export interface GetGatewayPluginOpentelemetryService {
    id: string;
}

export interface GetGatewayPluginPostFunctionConfig {
    accesses: string[];
    bodyFilters: string[];
    certificates: string[];
    headerFilters: string[];
    logs: string[];
    rewrites: string[];
    wsClientFrames: string[];
    wsCloses: string[];
    wsHandshakes: string[];
    wsUpstreamFrames: string[];
}

export interface GetGatewayPluginPostFunctionConsumer {
    id: string;
}

export interface GetGatewayPluginPostFunctionConsumerGroup {
    id: string;
}

export interface GetGatewayPluginPostFunctionRoute {
    id: string;
}

export interface GetGatewayPluginPostFunctionService {
    id: string;
}

export interface GetGatewayPluginPreFunctionConfig {
    accesses: string[];
    bodyFilters: string[];
    certificates: string[];
    headerFilters: string[];
    logs: string[];
    rewrites: string[];
    wsClientFrames: string[];
    wsCloses: string[];
    wsHandshakes: string[];
    wsUpstreamFrames: string[];
}

export interface GetGatewayPluginPreFunctionConsumer {
    id: string;
}

export interface GetGatewayPluginPreFunctionConsumerGroup {
    id: string;
}

export interface GetGatewayPluginPreFunctionRoute {
    id: string;
}

export interface GetGatewayPluginPreFunctionService {
    id: string;
}

export interface GetGatewayPluginPrometheusConfig {
    /**
     * A boolean value that determines if bandwidth metrics should be collected. If enabled, `bandwidthBytes` and `streamSessionsTotal` metrics will be exported.
     */
    bandwidthMetrics: boolean;
    /**
     * A boolean value that determines if latency metrics should be collected. If enabled, `kongLatencyMs`, `upstreamLatencyMs` and `requestLatencyMs` metrics will be exported.
     */
    latencyMetrics: boolean;
    /**
     * A boolean value that determines if per-consumer metrics should be collected. If enabled, the `kongHttpRequestsTotal` and `kongBandwidthBytes` metrics fill in the consumer label when available.
     */
    perConsumer: boolean;
    /**
     * A boolean value that determines if status code metrics should be collected. If enabled, `httpRequestsTotal`, `streamSessionsTotal` metrics will be exported.
     */
    statusCodeMetrics: boolean;
    /**
     * A boolean value that determines if upstream metrics should be collected. If enabled, `upstreamTargetHealth` metric will be exported.
     */
    upstreamHealthMetrics: boolean;
}

export interface GetGatewayPluginPrometheusConsumer {
    id: string;
}

export interface GetGatewayPluginPrometheusConsumerGroup {
    id: string;
}

export interface GetGatewayPluginPrometheusRoute {
    id: string;
}

export interface GetGatewayPluginPrometheusService {
    id: string;
}

export interface GetGatewayPluginProxyCacheConfig {
    /**
     * When enabled, respect the Cache-Control behaviors defined in RFC7234.
     */
    cacheControl: boolean;
    /**
     * TTL, in seconds, of cache entities.
     */
    cacheTtl: number;
    /**
     * Upstream response content types considered cacheable. The plugin performs an **exact match** against each specified value.
     */
    contentTypes: string[];
    ignoreUriCase: boolean;
    memory: outputs.GetGatewayPluginProxyCacheConfigMemory;
    /**
     * Downstream request methods considered cacheable.
     */
    requestMethods: string[];
    /**
     * Upstream response status code considered cacheable.
     */
    responseCodes: number[];
    /**
     * Caching related diagnostic headers that should be included in cached responses
     */
    responseHeaders: outputs.GetGatewayPluginProxyCacheConfigResponseHeaders;
    /**
     * Number of seconds to keep resources in the storage backend. This value is independent of `cacheTtl` or resource TTLs defined by Cache-Control behaviors.
     */
    storageTtl: number;
    /**
     * The backing data store in which to hold cache entities. must be one of ["memory"]
     */
    strategy: string;
    /**
     * Relevant headers considered for the cache key. If undefined, none of the headers are taken into consideration.
     */
    varyHeaders: string[];
    /**
     * Relevant query parameters considered for the cache key. If undefined, all params are taken into consideration.
     */
    varyQueryParams: string[];
}

export interface GetGatewayPluginProxyCacheConfigMemory {
    /**
     * The name of the shared dictionary in which to hold cache entities when the memory strategy is selected. Note that this dictionary currently must be defined manually in the Kong Nginx template.
     */
    dictionaryName: string;
}

export interface GetGatewayPluginProxyCacheConfigResponseHeaders {
    age: boolean;
    xCacheKey: boolean;
    xCacheStatus: boolean;
}

export interface GetGatewayPluginProxyCacheConsumer {
    id: string;
}

export interface GetGatewayPluginProxyCacheConsumerGroup {
    id: string;
}

export interface GetGatewayPluginProxyCacheRoute {
    id: string;
}

export interface GetGatewayPluginProxyCacheService {
    id: string;
}

export interface GetGatewayPluginRateLimitingAdvancedConfig {
    /**
     * List of consumer groups allowed to override the rate limiting settings for the given Route or Service. Required if `enforceConsumerGroups` is set to `true`.
     */
    consumerGroups: string[];
    /**
     * The shared dictionary where counters are stored. When the plugin is configured to synchronize counter data externally (that is `config.strategy` is `cluster` or `redis` and `config.sync_rate` isn't `-1`), this dictionary serves as a buffer to populate counters in the data store on each synchronization cycle.
     */
    dictionaryName: string;
    /**
     * If set to `true`, this doesn't count denied requests (status = `429`). If set to `false`, all requests, including denied ones, are counted. This parameter only affects the `sliding` window_type.
     */
    disablePenalty: boolean;
    /**
     * Determines if consumer groups are allowed to override the rate limiting settings for the given Route or Service. Flipping `enforceConsumerGroups` from `true` to `false` disables the group override, but does not clear the list of consumer groups. You can then flip `enforceConsumerGroups` to `true` to re-enforce the groups.
     */
    enforceConsumerGroups: boolean;
    /**
     * Set a custom error code to return when the rate limit is exceeded.
     */
    errorCode: number;
    /**
     * Set a custom error message to return when the rate limit is exceeded.
     */
    errorMessage: string;
    /**
     * A string representing an HTTP header name.
     */
    headerName: string;
    /**
     * Optionally hide informative response headers that would otherwise provide information about the current status of limits and counters.
     */
    hideClientHeaders: boolean;
    /**
     * The type of identifier used to generate the rate limit key. Defines the scope used to increment the rate limiting counters. Can be `ip`, `credential`, `consumer`, `service`, `header`, `path` or `consumer-group`. must be one of ["ip", "credential", "consumer", "service", "header", "path", "consumer-group"]
     */
    identifier: string;
    /**
     * One or more requests-per-window limits to apply. There must be a matching number of window limits and sizes specified.
     */
    limits: number[];
    /**
     * The rate limiting library namespace to use for this plugin instance. Counter data and sync configuration is isolated in each namespace. NOTE: For the plugin instances sharing the same namespace, all the configurations that are required for synchronizing counters, e.g. `strategy`, `redis`, `syncRate`, `windowSize`, `dictionaryName`, need to be the same.
     */
    namespace: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    path: string;
    redis: outputs.GetGatewayPluginRateLimitingAdvancedConfigRedis;
    /**
     * The upper bound of a jitter (random delay) in seconds to be added to the `Retry-After` header of denied requests (status = `429`) in order to prevent all the clients from coming back at the same time. The lower bound of the jitter is `0`; in this case, the `Retry-After` header is equal to the `RateLimit-Reset` header.
     */
    retryAfterJitterMax: number;
    /**
     * The rate-limiting strategy to use for retrieving and incrementing the limits. Available values are: `local` and `cluster`. must be one of ["cluster", "redis", "local"]
     */
    strategy: string;
    /**
     * How often to sync counter data to the central data store. A value of 0 results in synchronous behavior; a value of -1 ignores sync behavior entirely and only stores counters in node memory. A value greater than 0 will sync the counters in the specified number of seconds. The minimum allowed interval is 0.02 seconds (20ms).
     */
    syncRate: number;
    /**
     * One or more window sizes to apply a limit to (defined in seconds). There must be a matching number of window limits and sizes specified.
     */
    windowSizes: number[];
    /**
     * Sets the time window type to either `sliding` (default) or `fixed`. Sliding windows apply the rate limiting logic while taking into account previous hit rates (from the window that immediately precedes the current) using a dynamic weight. Fixed windows consist of buckets that are statically assigned to a definitive time range, each request is mapped to only one fixed window based on its timestamp and will affect only that window's counters. must be one of ["fixed", "sliding"]
     */
    windowType: string;
}

export interface GetGatewayPluginRateLimitingAdvancedConfigRedis {
    /**
     * Cluster addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Cluster. Each string element must be a hostname. The minimum length of the array is 1 element.
     */
    clusterAddresses: string[];
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    connectTimeout: number;
    /**
     * Database to use for the Redis connection when using the `redis` strategy
     */
    database: number;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * Limits the total number of opened connections for a pool. If the connection pool is full, connection queues above the limit go into the backlog queue. If the backlog queue is full, subsequent connect operations fail and return `nil`. Queued operations (subject to set timeouts) resume once the number of connections in the pool is less than `keepalivePoolSize`. If latency is high or throughput is low, try increasing this value. Empirically, this value is larger than `keepalivePoolSize`.
     */
    keepaliveBacklog: number;
    /**
     * The size limit for every cosocket connection pool associated with every remote server, per worker process. If neither `keepalivePoolSize` nor `keepaliveBacklog` is specified, no pool is created. If `keepalivePoolSize` isn't specified but `keepaliveBacklog` is specified, then the pool uses the default value. Try to increase (e.g. 512) this value if latency is high or throughput is low.
     */
    keepalivePoolSize: number;
    /**
     * Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
     */
    password: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    readTimeout: number;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    sendTimeout: number;
    /**
     * Sentinel addresses to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. Each string element must be a hostname. The minimum length of the array is 1 element.
     */
    sentinelAddresses: string[];
    /**
     * Sentinel master to use for Redis connections. Defining this value implies using Redis Sentinel.
     */
    sentinelMaster: string;
    /**
     * Sentinel password to authenticate with a Redis Sentinel instance. If undefined, no AUTH commands are sent to Redis Sentinels.
     */
    sentinelPassword: string;
    /**
     * Sentinel role to use for Redis connections when the `redis` strategy is defined. Defining this value implies using Redis Sentinel. must be one of ["master", "slave", "any"]
     */
    sentinelRole: string;
    /**
     * Sentinel username to authenticate with a Redis Sentinel instance. If undefined, ACL authentication won't be performed. This requires Redis v6.2.0+.
     */
    sentinelUsername: string;
    /**
     * A string representing an SNI (server name indication) value for TLS.
     */
    serverName: string;
    /**
     * If set to true, uses SSL to connect to Redis.
     */
    ssl: boolean;
    /**
     * If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `luaSslTrustedCertificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `luaSslVerifyDepth` accordingly.
     */
    sslVerify: boolean;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    timeout: number;
    /**
     * Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    username: string;
}

export interface GetGatewayPluginRateLimitingAdvancedConsumer {
    id: string;
}

export interface GetGatewayPluginRateLimitingAdvancedConsumerGroup {
    id: string;
}

export interface GetGatewayPluginRateLimitingAdvancedRoute {
    id: string;
}

export interface GetGatewayPluginRateLimitingAdvancedService {
    id: string;
}

export interface GetGatewayPluginRateLimitingConfig {
    /**
     * The number of HTTP requests that can be made per day.
     */
    day: number;
    /**
     * Set a custom error code to return when the rate limit is exceeded.
     */
    errorCode: number;
    /**
     * Set a custom error message to return when the rate limit is exceeded.
     */
    errorMessage: string;
    /**
     * A boolean value that determines if the requests should be proxied even if Kong has troubles connecting a third-party data store. If `true`, requests will be proxied anyway, effectively disabling the rate-limiting function until the data store is working again. If `false`, then the clients will see `500` errors.
     */
    faultTolerant: boolean;
    /**
     * A string representing an HTTP header name.
     */
    headerName: string;
    /**
     * Optionally hide informative response headers.
     */
    hideClientHeaders: boolean;
    /**
     * The number of HTTP requests that can be made per hour.
     */
    hour: number;
    /**
     * The entity that is used when aggregating the limits. must be one of ["consumer", "credential", "ip", "service", "header", "path", "consumer-group"]
     */
    limitBy: string;
    /**
     * The number of HTTP requests that can be made per minute.
     */
    minute: number;
    /**
     * The number of HTTP requests that can be made per month.
     */
    month: number;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    path: string;
    /**
     * The rate-limiting policies to use for retrieving and incrementing the limits. must be one of ["local", "cluster", "redis"]
     */
    policy: string;
    /**
     * Redis configuration
     */
    redis: outputs.GetGatewayPluginRateLimitingConfigRedis;
    /**
     * The number of HTTP requests that can be made per second.
     */
    second: number;
    /**
     * How often to sync counter data to the central data store. A value of -1 results in synchronous behavior.
     */
    syncRate: number;
    /**
     * The number of HTTP requests that can be made per year.
     */
    year: number;
}

export interface GetGatewayPluginRateLimitingConfigRedis {
    /**
     * Database to use for the Redis connection when using the `redis` strategy
     */
    database: number;
    /**
     * A string representing a host name, such as example.com.
     */
    host: string;
    /**
     * Password to use for Redis connections. If undefined, no AUTH commands are sent to Redis.
     */
    password: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
    /**
     * A string representing an SNI (server name indication) value for TLS.
     */
    serverName: string;
    /**
     * If set to true, uses SSL to connect to Redis.
     */
    ssl: boolean;
    /**
     * If set to true, verifies the validity of the server SSL certificate. If setting this parameter, also configure `luaSslTrustedCertificate` in `kong.conf` to specify the CA (or server) certificate used by your Redis server. You may also need to configure `luaSslVerifyDepth` accordingly.
     */
    sslVerify: boolean;
    /**
     * An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
     */
    timeout: number;
    /**
     * Username to use for Redis connections. If undefined, ACL authentication won't be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
     */
    username: string;
}

export interface GetGatewayPluginRateLimitingConsumer {
    id: string;
}

export interface GetGatewayPluginRateLimitingConsumerGroup {
    id: string;
}

export interface GetGatewayPluginRateLimitingRoute {
    id: string;
}

export interface GetGatewayPluginRateLimitingService {
    id: string;
}

export interface GetGatewayPluginRequestTerminationConfig {
    /**
     * The raw response body to send. This is mutually exclusive with the `config.message` field.
     */
    body: string;
    /**
     * Content type of the raw response configured with `config.body`.
     */
    contentType: string;
    /**
     * When set, the plugin will echo a copy of the request back to the client. The main usecase for this is debugging. It can be combined with `trigger` in order to debug requests on live systems without disturbing real traffic.
     */
    echo: boolean;
    /**
     * The message to send, if using the default response generator.
     */
    message: string;
    /**
     * The response code to send. Must be an integer between 100 and 599.
     */
    statusCode: number;
    /**
     * A string representing an HTTP header name.
     */
    trigger: string;
}

export interface GetGatewayPluginRequestTerminationConsumer {
    id: string;
}

export interface GetGatewayPluginRequestTerminationConsumerGroup {
    id: string;
}

export interface GetGatewayPluginRequestTerminationRoute {
    id: string;
}

export interface GetGatewayPluginRequestTerminationService {
    id: string;
}

export interface GetGatewayPluginRequestTransformerAdvancedConfig {
    add: outputs.GetGatewayPluginRequestTransformerAdvancedConfigAdd;
    allow: outputs.GetGatewayPluginRequestTransformerAdvancedConfigAllow;
    append: outputs.GetGatewayPluginRequestTransformerAdvancedConfigAppend;
    /**
     * Specify whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects.  See Arrays and nested objects.
     */
    dotsInKeys: boolean;
    /**
     * A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
     */
    httpMethod: string;
    remove: outputs.GetGatewayPluginRequestTransformerAdvancedConfigRemove;
    rename: outputs.GetGatewayPluginRequestTransformerAdvancedConfigRename;
    replace: outputs.GetGatewayPluginRequestTransformerAdvancedConfigReplace;
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigAdd {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigAllow {
    bodies: string[];
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigAppend {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigRemove {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigRename {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerAdvancedConfigReplace {
    bodies: string[];
    headers: string[];
    jsonTypes: string[];
    querystrings: string[];
    uri: string;
}

export interface GetGatewayPluginRequestTransformerAdvancedConsumer {
    id: string;
}

export interface GetGatewayPluginRequestTransformerAdvancedConsumerGroup {
    id: string;
}

export interface GetGatewayPluginRequestTransformerAdvancedRoute {
    id: string;
}

export interface GetGatewayPluginRequestTransformerAdvancedService {
    id: string;
}

export interface GetGatewayPluginRequestTransformerConfig {
    add: outputs.GetGatewayPluginRequestTransformerConfigAdd;
    append: outputs.GetGatewayPluginRequestTransformerConfigAppend;
    /**
     * A string representing an HTTP method, such as GET, POST, PUT, or DELETE. The string must contain only uppercase letters.
     */
    httpMethod: string;
    remove: outputs.GetGatewayPluginRequestTransformerConfigRemove;
    rename: outputs.GetGatewayPluginRequestTransformerConfigRename;
    replace: outputs.GetGatewayPluginRequestTransformerConfigReplace;
}

export interface GetGatewayPluginRequestTransformerConfigAdd {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerConfigAppend {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerConfigRemove {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerConfigRename {
    bodies: string[];
    headers: string[];
    querystrings: string[];
}

export interface GetGatewayPluginRequestTransformerConfigReplace {
    bodies: string[];
    headers: string[];
    querystrings: string[];
    uri: string;
}

export interface GetGatewayPluginRequestTransformerConsumer {
    id: string;
}

export interface GetGatewayPluginRequestTransformerConsumerGroup {
    id: string;
}

export interface GetGatewayPluginRequestTransformerRoute {
    id: string;
}

export interface GetGatewayPluginRequestTransformerService {
    id: string;
}

export interface GetGatewayPluginResponseTransformerAdvancedConfig {
    add: outputs.GetGatewayPluginResponseTransformerAdvancedConfigAdd;
    allow: outputs.GetGatewayPluginResponseTransformerAdvancedConfigAllow;
    append: outputs.GetGatewayPluginResponseTransformerAdvancedConfigAppend;
    /**
     * Whether dots (for example, `customers.info.phone`) should be treated as part of a property name or used to descend into nested JSON objects..
     */
    dotsInKeys: boolean;
    remove: outputs.GetGatewayPluginResponseTransformerAdvancedConfigRemove;
    rename: outputs.GetGatewayPluginResponseTransformerAdvancedConfigRename;
    replace: outputs.GetGatewayPluginResponseTransformerAdvancedConfigReplace;
    transform: outputs.GetGatewayPluginResponseTransformerAdvancedConfigTransform;
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigAdd {
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigAllow {
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigAppend {
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigRemove {
    headers: string[];
    ifStatuses: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigRename {
    headers: string[];
    ifStatuses: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigReplace {
    /**
     * String with which to replace the entire response body.
     */
    body: string;
    headers: string[];
    ifStatuses: string[];
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConfigTransform {
    functions: string[];
    ifStatuses: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerAdvancedConsumer {
    id: string;
}

export interface GetGatewayPluginResponseTransformerAdvancedConsumerGroup {
    id: string;
}

export interface GetGatewayPluginResponseTransformerAdvancedRoute {
    id: string;
}

export interface GetGatewayPluginResponseTransformerAdvancedService {
    id: string;
}

export interface GetGatewayPluginResponseTransformerConfig {
    add: outputs.GetGatewayPluginResponseTransformerConfigAdd;
    append: outputs.GetGatewayPluginResponseTransformerConfigAppend;
    remove: outputs.GetGatewayPluginResponseTransformerConfigRemove;
    rename: outputs.GetGatewayPluginResponseTransformerConfigRename;
    replace: outputs.GetGatewayPluginResponseTransformerConfigReplace;
}

export interface GetGatewayPluginResponseTransformerConfigAdd {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerConfigAppend {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerConfigRemove {
    headers: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerConfigRename {
    headers: string[];
}

export interface GetGatewayPluginResponseTransformerConfigReplace {
    headers: string[];
    /**
     * List of JSON type names. Specify the types of the JSON values returned when appending
     * JSON properties. Each string element can be one of: boolean, number, or string.
     */
    jsonTypes: string[];
    jsons: string[];
}

export interface GetGatewayPluginResponseTransformerConsumer {
    id: string;
}

export interface GetGatewayPluginResponseTransformerConsumerGroup {
    id: string;
}

export interface GetGatewayPluginResponseTransformerRoute {
    id: string;
}

export interface GetGatewayPluginResponseTransformerService {
    id: string;
}

export interface GetGatewayPluginSamlConfig {
    /**
     * An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
     */
    anonymous: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    assertionConsumerPath: string;
    /**
     * The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
     */
    idpCertificate: string;
    /**
     * A string representing a URL, such as https://example.com/path/to/resource?q=search.
     */
    idpSsoUrl: string;
    /**
     * The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
     */
    issuer: string;
    /**
     * The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
     */
    nameidFormat: string;
    /**
     * The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
     */
    requestDigestAlgorithm: string;
    /**
     * The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
     */
    requestSignatureAlgorithm: string;
    /**
     * The certificate for signing requests.
     */
    requestSigningCertificate: string;
    /**
     * The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `requestSigningCertificate` parameter must be set as well.
     */
    requestSigningKey: string;
    /**
     * The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
     */
    responseDigestAlgorithm: string;
    /**
     * The private encryption key required to decrypt encrypted assertions.
     */
    responseEncryptionKey: string;
    /**
     * The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
     */
    responseSignatureAlgorithm: string;
    /**
     * The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
     */
    sessionAbsoluteTimeout: number;
    /**
     * The session audience, for example "my-application"
     */
    sessionAudience: string;
    /**
     * The session cookie domain flag.
     */
    sessionCookieDomain: string;
    /**
     * Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
     */
    sessionCookieHttpOnly: boolean;
    /**
     * The session cookie name.
     */
    sessionCookieName: string;
    /**
     * A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
     */
    sessionCookiePath: string;
    /**
     * Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
     */
    sessionCookieSameSite: string;
    /**
     * The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
     */
    sessionCookieSecure: boolean;
    /**
     * When set to `true`, audiences are forced to share the same subject.
     */
    sessionEnforceSameSubject: boolean;
    /**
     * When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
     */
    sessionHashStorageKey: boolean;
    /**
     * When set to `true`, the value of subject is hashed before being stored. Only applies when `sessionStoreMetadata` is enabled.
     */
    sessionHashSubject: boolean;
    /**
     * The session cookie idle time in seconds.
     */
    sessionIdlingTimeout: number;
    /**
     * The memcached host.
     */
    sessionMemcachedHost: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    sessionMemcachedPort: number;
    /**
     * The memcached session key prefix.
     */
    sessionMemcachedPrefix: string;
    /**
     * The memcached unix socket path.
     */
    sessionMemcachedSocket: string;
    /**
     * The Redis cluster maximum redirects.
     */
    sessionRedisClusterMaxRedirections: number;
    /**
     * The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
     */
    sessionRedisClusterNodes: outputs.GetGatewayPluginSamlConfigSessionRedisClusterNode[];
    /**
     * The Redis connection timeout in milliseconds.
     */
    sessionRedisConnectTimeout: number;
    /**
     * The Redis host IP.
     */
    sessionRedisHost: string;
    /**
     * Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
     */
    sessionRedisPassword: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    sessionRedisPort: number;
    /**
     * The Redis session key prefix.
     */
    sessionRedisPrefix: string;
    /**
     * The Redis read timeout in milliseconds.
     */
    sessionRedisReadTimeout: number;
    /**
     * The Redis send timeout in milliseconds.
     */
    sessionRedisSendTimeout: number;
    /**
     * The SNI used for connecting to the Redis server.
     */
    sessionRedisServerName: string;
    /**
     * The Redis unix socket path.
     */
    sessionRedisSocket: string;
    /**
     * Use SSL/TLS for the Redis connection.
     */
    sessionRedisSsl: boolean;
    /**
     * Verify the Redis server certificate.
     */
    sessionRedisSslVerify: boolean;
    /**
     * Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
     */
    sessionRedisUsername: string;
    /**
     * Enables or disables persistent sessions
     */
    sessionRemember: boolean;
    /**
     * Persistent session absolute timeout in seconds.
     */
    sessionRememberAbsoluteTimeout: number;
    /**
     * Persistent session cookie name
     */
    sessionRememberCookieName: string;
    /**
     * Persistent session rolling timeout in seconds.
     */
    sessionRememberRollingTimeout: number;
    sessionRequestHeaders: string[];
    sessionResponseHeaders: string[];
    /**
     * The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
     */
    sessionRollingTimeout: number;
    /**
     * The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
     */
    sessionSecret: string;
    /**
     * The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
     */
    sessionStorage: string;
    /**
     * Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specificAudience` belonging to a specific subject.
     */
    sessionStoreMetadata: boolean;
    /**
     * Enable signature validation for SAML responses.
     */
    validateAssertionSignature: boolean;
}

export interface GetGatewayPluginSamlConfigSessionRedisClusterNode {
    /**
     * A string representing a host name, such as example.com.
     */
    ip: string;
    /**
     * An integer representing a port number between 0 and 65535, inclusive.
     */
    port: number;
}

export interface GetGatewayPluginSamlConsumer {
    id: string;
}

export interface GetGatewayPluginSamlConsumerGroup {
    id: string;
}

export interface GetGatewayPluginSamlRoute {
    id: string;
}

export interface GetGatewayPluginSamlService {
    id: string;
}

export interface GetGatewayPluginStatsdConfig {
    /**
     * List of status code ranges that are allowed to be logged in metrics.
     */
    allowStatusCodes: string[];
    /**
     * must be one of ["consumerId", "customId", "username"]
     */
    consumerIdentifierDefault: string;
    flushTimeout: number;
    /**
     * The IP address or hostname of StatsD server to send data to.
     */
    host: string;
    hostnameInPrefix: boolean;
    /**
     * List of metrics to be logged.
     */
    metrics: outputs.GetGatewayPluginStatsdConfigMetric[];
    /**
     * The port of StatsD server to send data to.
     */
    port: number;
    /**
     * String to prefix to each metric's name.
     */
    prefix: string;
    queue: outputs.GetGatewayPluginStatsdConfigQueue;
    queueSize: number;
    retryCount: number;
    /**
     * must be one of ["serviceId", "serviceName", "serviceHost", "serviceNameOrHost"]
     */
    serviceIdentifierDefault: string;
    /**
     * must be one of ["dogstatsd", "influxdb", "librato", "signalfx"]
     */
    tagStyle: string;
    udpPacketSize: number;
    useTcp: boolean;
    /**
     * must be one of ["workspaceId", "workspaceName"]
     */
    workspaceIdentifierDefault: string;
}

export interface GetGatewayPluginStatsdConfigMetric {
    /**
     * Authenticated user detail. must be one of ["consumerId", "customId", "username"]
     */
    consumerIdentifier: string;
    /**
     * StatsD metric’s name. must be one of ["kongLatency", "latency", "requestCount", "requestPerUser", "requestSize", "responseSize", "statusCount", "statusCountPerUser", "uniqueUsers", "upstreamLatency", "statusCountPerWorkspace", "statusCountPerUserPerRoute", "shdictUsage", "cacheDatastoreHitsTotal", "cacheDatastoreMissesTotal"]
     */
    name: string;
    /**
     * Sampling rate
     */
    sampleRate: number;
    /**
     * Service detail. must be one of ["serviceId", "serviceName", "serviceHost", "serviceNameOrHost"]
     */
    serviceIdentifier: string;
    /**
     * Determines what sort of event a metric represents. must be one of ["counter", "gauge", "histogram", "meter", "set", "timer"]
     */
    statType: string;
    /**
     * Workspace detail. must be one of ["workspaceId", "workspaceName"]
     */
    workspaceIdentifier: string;
}

export interface GetGatewayPluginStatsdConfigQueue {
    /**
     * Time in seconds before the initial retry is made for a failing batch.
     */
    initialRetryDelay: number;
    /**
     * Maximum number of entries that can be processed at a time.
     */
    maxBatchSize: number;
    /**
     * Maximum number of bytes that can be waiting on a queue, requires string content.
     */
    maxBytes: number;
    /**
     * Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
     */
    maxCoalescingDelay: number;
    /**
     * Maximum number of entries that can be waiting on the queue.
     */
    maxEntries: number;
    /**
     * Maximum time in seconds between retries, caps exponential backoff.
     */
    maxRetryDelay: number;
    /**
     * Time in seconds before the queue gives up calling a failed handler for a batch.
     */
    maxRetryTime: number;
}

export interface GetGatewayPluginStatsdConsumer {
    id: string;
}

export interface GetGatewayPluginStatsdConsumerGroup {
    id: string;
}

export interface GetGatewayPluginStatsdRoute {
    id: string;
}

export interface GetGatewayPluginStatsdService {
    id: string;
}

export interface GetGatewayRouteDestination {
    ip: string;
    port: number;
}

export interface GetGatewayRouteService {
    id: string;
}

export interface GetGatewayRouteSource {
    ip: string;
    port: number;
}

export interface GetGatewayServiceClientCertificate {
    id: string;
}

export interface GetGatewaySniCertificate {
    id: string;
}

export interface GetGatewayTargetUpstream {
    id: string;
}

export interface GetGatewayUpstreamClientCertificate {
    id: string;
}

export interface GetGatewayUpstreamHealthchecks {
    active: outputs.GetGatewayUpstreamHealthchecksActive;
    passive: outputs.GetGatewayUpstreamHealthchecksPassive;
    threshold: number;
}

export interface GetGatewayUpstreamHealthchecksActive {
    concurrency: number;
    headers: {[key: string]: string};
    healthy: outputs.GetGatewayUpstreamHealthchecksActiveHealthy;
    httpPath: string;
    httpsSni: string;
    httpsVerifyCertificate: boolean;
    timeout: number;
    /**
     * must be one of ["tcp", "http", "https", "grpc", "grpcs"]
     */
    type: string;
    unhealthy: outputs.GetGatewayUpstreamHealthchecksActiveUnhealthy;
}

export interface GetGatewayUpstreamHealthchecksActiveHealthy {
    httpStatuses: number[];
    interval: number;
    successes: number;
}

export interface GetGatewayUpstreamHealthchecksActiveUnhealthy {
    httpFailures: number;
    httpStatuses: number[];
    interval: number;
    tcpFailures: number;
    timeouts: number;
}

export interface GetGatewayUpstreamHealthchecksPassive {
    healthy: outputs.GetGatewayUpstreamHealthchecksPassiveHealthy;
    /**
     * must be one of ["tcp", "http", "https", "grpc", "grpcs"]
     */
    type: string;
    unhealthy: outputs.GetGatewayUpstreamHealthchecksPassiveUnhealthy;
}

export interface GetGatewayUpstreamHealthchecksPassiveHealthy {
    httpStatuses: number[];
    successes: number;
}

export interface GetGatewayUpstreamHealthchecksPassiveUnhealthy {
    httpFailures: number;
    httpStatuses: number[];
    tcpFailures: number;
    timeouts: number;
}

export interface GetPortalAppearanceCustomFonts {
    /**
     * The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    base: string;
    /**
     * The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    code: string;
    /**
     * The name of the font to render in the browser. must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    headings: string;
}

export interface GetPortalAppearanceCustomTheme {
    colors: outputs.GetPortalAppearanceCustomThemeColors;
}

export interface GetPortalAppearanceCustomThemeColors {
    button: outputs.GetPortalAppearanceCustomThemeColorsButton;
    section: outputs.GetPortalAppearanceCustomThemeColorsSection;
    text: outputs.GetPortalAppearanceCustomThemeColorsText;
}

export interface GetPortalAppearanceCustomThemeColorsButton {
    primaryFill: outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryFill;
    primaryText: outputs.GetPortalAppearanceCustomThemeColorsButtonPrimaryText;
}

export interface GetPortalAppearanceCustomThemeColorsButtonPrimaryFill {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsButtonPrimaryText {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSection {
    accent: outputs.GetPortalAppearanceCustomThemeColorsSectionAccent;
    body: outputs.GetPortalAppearanceCustomThemeColorsSectionBody;
    footer: outputs.GetPortalAppearanceCustomThemeColorsSectionFooter;
    header: outputs.GetPortalAppearanceCustomThemeColorsSectionHeader;
    hero: outputs.GetPortalAppearanceCustomThemeColorsSectionHero;
    stroke: outputs.GetPortalAppearanceCustomThemeColorsSectionStroke;
    tertiary: outputs.GetPortalAppearanceCustomThemeColorsSectionTertiary;
}

export interface GetPortalAppearanceCustomThemeColorsSectionAccent {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionBody {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionFooter {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionHeader {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionHero {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionStroke {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsSectionTertiary {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsText {
    accent: outputs.GetPortalAppearanceCustomThemeColorsTextAccent;
    footer: outputs.GetPortalAppearanceCustomThemeColorsTextFooter;
    header: outputs.GetPortalAppearanceCustomThemeColorsTextHeader;
    headings: outputs.GetPortalAppearanceCustomThemeColorsTextHeadings;
    hero: outputs.GetPortalAppearanceCustomThemeColorsTextHero;
    link: outputs.GetPortalAppearanceCustomThemeColorsTextLink;
    primary: outputs.GetPortalAppearanceCustomThemeColorsTextPrimary;
    secondary: outputs.GetPortalAppearanceCustomThemeColorsTextSecondary;
}

export interface GetPortalAppearanceCustomThemeColorsTextAccent {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextFooter {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextHeader {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextHeadings {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextHero {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextLink {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextPrimary {
    description: string;
    value: string;
}

export interface GetPortalAppearanceCustomThemeColorsTextSecondary {
    description: string;
    value: string;
}

export interface GetPortalAppearanceImages {
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
     */
    catalogCover: outputs.GetPortalAppearanceImagesCatalogCover;
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
     */
    favicon: outputs.GetPortalAppearanceImagesFavicon;
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs.
     */
    logo: outputs.GetPortalAppearanceImagesLogo;
}

export interface GetPortalAppearanceImagesCatalogCover {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
     */
    data: string;
    filename: string;
}

export interface GetPortalAppearanceImagesFavicon {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
     */
    data: string;
    filename: string;
}

export interface GetPortalAppearanceImagesLogo {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,<BASE64_IMAGE_DATA>
     */
    data: string;
    filename: string;
}

export interface GetPortalAppearanceText {
    catalog: outputs.GetPortalAppearanceTextCatalog;
}

export interface GetPortalAppearanceTextCatalog {
    primaryHeader: string;
    welcomeMessage: string;
}

export interface GetPortalAuthOidcConfig {
    /**
     * Mappings from a portal developer atribute to an Identity Provider claim.
     */
    claimMappings: outputs.GetPortalAuthOidcConfigClaimMappings;
    clientId: string;
    issuer: string;
    scopes: string[];
}

export interface GetPortalAuthOidcConfigClaimMappings {
    email: string;
    groups: string;
    name: string;
}

export interface GetPortalListData {
    /**
     * Number of applications created in the portal.
     */
    applicationCount: number;
    /**
     * Whether the requests from applications to register for products will be automatically approved, or if they will be set to pending until approved by an admin.
     */
    autoApproveApplications: boolean;
    /**
     * Whether the developer account registrations will be automatically approved, or if they will be set to pending until approved by an admin.
     */
    autoApproveDevelopers: boolean;
    /**
     * An ISO-8601 timestamp representation of entity creation date.
     */
    createdAt: string;
    /**
     * The custom domain to access a self-hosted customized developer portal client. If this is set, the Konnect-hosted portal client will no longer be available. `customDomain` must be also set for this value to be set. See https://github.com/Kong/konnect-portal for information on how to get started deploying and customizing your own Konnect portal.
     */
    customClientDomain: string;
    /**
     * The custom domain to access the developer portal. A CNAME for the portal's default domain must be able to be set for the custom domain for it to be valid. After setting a valid CNAME, an SSL/TLS certificate will be automatically manged for the custom domain, and traffic will be able to use the custom domain to route to the portal's web client and API.
     */
    customDomain: string;
    /**
     * Default strategy ID applied on applications for the portal
     */
    defaultApplicationAuthStrategyId: string;
    /**
     * The domain assigned to the portal by Konnect. This is the default place to access the portal and its API if not using a `customDomain``.
     */
    defaultDomain: string;
    /**
     * The description of the portal.
     */
    description: string;
    /**
     * Number of developers using the portal.
     */
    developerCount: number;
    /**
     * The display name of the portal. This value will be the portal's `name` in Portal API.
     */
    displayName: string;
    /**
     * Contains a unique identifier used for this resource.
     */
    id: string;
    /**
     * Whether the portal catalog can be accessed publicly without any developer authentication. Developer accounts and applications cannot be created if the portal is public.
     */
    isPublic: boolean;
    /**
     * Labels store metadata of an entity that can be used for filtering an entity list or for searching across entity types. 
     *
     * Keys must be of length 1-63 characters, and cannot start with "kong", "konnect", "mesh", "kic", or "_".
     */
    labels: {[key: string]: string};
    /**
     * The name of the portal, used to distinguish it from other portals. Name must be unique.
     */
    name: string;
    /**
     * Number of api products published to the portal
     */
    publishedProductCount: number;
    /**
     * Whether the portal resources are protected by Role Based Access Control (RBAC). If enabled, developers view or register for products until unless assigned to teams with access to view and consume specific products.
     */
    rbacEnabled: boolean;
    /**
     * An ISO-8601 timestamp representation of entity update date.
     */
    updatedAt: string;
}

export interface GetPortalListMeta {
    /**
     * Contains pagination query parameters and the total number of objects returned.
     */
    page: outputs.GetPortalListMetaPage;
}

export interface GetPortalListMetaPage {
    number: number;
    size: number;
    total: number;
}

export interface GetPortalProductVersionAuthStrategy {
    /**
     * Client Credential Auth strategy that the application uses.
     */
    clientCredentials: outputs.GetPortalProductVersionAuthStrategyClientCredentials;
    /**
     * KeyAuth Auth strategy that the application uses.
     */
    keyAuth: outputs.GetPortalProductVersionAuthStrategyKeyAuth;
}

export interface GetPortalProductVersionAuthStrategyClientCredentials {
    authMethods: string[];
    /**
     * must be one of ["clientCredentials", "selfManagedClientCredentials"]
     */
    credentialType: string;
    /**
     * The Application Auth Strategy ID.
     */
    id: string;
    name: string;
}

export interface GetPortalProductVersionAuthStrategyKeyAuth {
    /**
     * must be one of ["keyAuth"]
     */
    credentialType: string;
    /**
     * The Application Auth Strategy ID.
     */
    id: string;
    name: string;
}

export interface GetServerlessCloudGatewayControlPlane {
    /**
     * ID of the serverless cloud gateway CP.
     */
    id: string;
    /**
     * The prefix of the serverless cloud gateway CP.
     */
    prefix: string;
    /**
     * The control plane region. must be one of ["us", "eu", "au"]
     */
    region: string;
}

export interface PortalAppearanceCustomFonts {
    /**
     * The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    base: string;
    /**
     * The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    code: string;
    /**
     * The name of the font to render in the browser. Not Null; must be one of ["Roboto", "Inter", "Open Sans", "Lato", "Slabo 27px", "Slabo 13px", "Oswald", "Source Sans Pro", "Montserrat", "Raleway", "PT Sans", "Lora", "Roboto Mono", "Inconsolata", "Source Code Pro", "PT Mono", "Ubuntu Mono", "IBM Plex Mono"]
     */
    headings: string;
}

export interface PortalAppearanceCustomTheme {
    /**
     * Not Null
     */
    colors: outputs.PortalAppearanceCustomThemeColors;
}

export interface PortalAppearanceCustomThemeColors {
    /**
     * Not Null
     */
    button: outputs.PortalAppearanceCustomThemeColorsButton;
    /**
     * Not Null
     */
    section: outputs.PortalAppearanceCustomThemeColorsSection;
    /**
     * Not Null
     */
    text: outputs.PortalAppearanceCustomThemeColorsText;
}

export interface PortalAppearanceCustomThemeColorsButton {
    /**
     * Not Null
     */
    primaryFill: outputs.PortalAppearanceCustomThemeColorsButtonPrimaryFill;
    /**
     * Not Null
     */
    primaryText: outputs.PortalAppearanceCustomThemeColorsButtonPrimaryText;
}

export interface PortalAppearanceCustomThemeColorsButtonPrimaryFill {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsButtonPrimaryText {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSection {
    /**
     * Not Null
     */
    accent: outputs.PortalAppearanceCustomThemeColorsSectionAccent;
    /**
     * Not Null
     */
    body: outputs.PortalAppearanceCustomThemeColorsSectionBody;
    /**
     * Not Null
     */
    footer: outputs.PortalAppearanceCustomThemeColorsSectionFooter;
    /**
     * Not Null
     */
    header: outputs.PortalAppearanceCustomThemeColorsSectionHeader;
    /**
     * Not Null
     */
    hero: outputs.PortalAppearanceCustomThemeColorsSectionHero;
    /**
     * Not Null
     */
    stroke: outputs.PortalAppearanceCustomThemeColorsSectionStroke;
    /**
     * Not Null
     */
    tertiary: outputs.PortalAppearanceCustomThemeColorsSectionTertiary;
}

export interface PortalAppearanceCustomThemeColorsSectionAccent {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionBody {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionFooter {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionHeader {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionHero {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionStroke {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsSectionTertiary {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsText {
    /**
     * Not Null
     */
    accent: outputs.PortalAppearanceCustomThemeColorsTextAccent;
    /**
     * Not Null
     */
    footer: outputs.PortalAppearanceCustomThemeColorsTextFooter;
    /**
     * Not Null
     */
    header: outputs.PortalAppearanceCustomThemeColorsTextHeader;
    /**
     * Not Null
     */
    headings: outputs.PortalAppearanceCustomThemeColorsTextHeadings;
    /**
     * Not Null
     */
    hero: outputs.PortalAppearanceCustomThemeColorsTextHero;
    /**
     * Not Null
     */
    link: outputs.PortalAppearanceCustomThemeColorsTextLink;
    /**
     * Not Null
     */
    primary: outputs.PortalAppearanceCustomThemeColorsTextPrimary;
    /**
     * Not Null
     */
    secondary: outputs.PortalAppearanceCustomThemeColorsTextSecondary;
}

export interface PortalAppearanceCustomThemeColorsTextAccent {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextFooter {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextHeader {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextHeadings {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextHero {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextLink {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextPrimary {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceCustomThemeColorsTextSecondary {
    description: string;
    /**
     * Not Null
     */
    value: string;
}

export interface PortalAppearanceImages {
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data*URLs.
     */
    catalogCover: outputs.PortalAppearanceImagesCatalogCover;
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
     */
    favicon: outputs.PortalAppearanceImagesFavicon;
    /**
     * The image data to upload, along with an optional filename. Images must be a data URL with binary image data in base 64 format. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics*of*HTTP/Data_URLs.
     */
    logo: outputs.PortalAppearanceImagesLogo;
}

export interface PortalAppearanceImagesCatalogCover {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\n\n. Not Null
     */
    data: string;
    filename: string;
}

export interface PortalAppearanceImagesFavicon {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\n\n. Not Null
     */
    data: string;
    filename: string;
}

export interface PortalAppearanceImagesLogo {
    /**
     * must be a data URL with base64 image data, e.g., data:image/jpeg;base64,\n\n. Not Null
     */
    data: string;
    filename: string;
}

export interface PortalAppearanceText {
    /**
     * Not Null
     */
    catalog: outputs.PortalAppearanceTextCatalog;
}

export interface PortalAppearanceTextCatalog {
    /**
     * Not Null
     */
    primaryHeader: string;
    /**
     * Not Null
     */
    welcomeMessage: string;
}

export interface PortalAuthOidcClaimMappings {
    email?: string;
    groups?: string;
    name?: string;
}

export interface PortalAuthOidcConfig {
    /**
     * Mappings from a portal developer atribute to an Identity Provider claim.
     */
    claimMappings: outputs.PortalAuthOidcConfigClaimMappings;
    clientId: string;
    issuer: string;
    scopes: string[];
}

export interface PortalAuthOidcConfigClaimMappings {
    email: string;
    groups: string;
    name: string;
}

export interface PortalProductVersionAuthStrategy {
    /**
     * Client Credential Auth strategy that the application uses.
     */
    clientCredentials: outputs.PortalProductVersionAuthStrategyClientCredentials;
    /**
     * KeyAuth Auth strategy that the application uses.
     */
    keyAuth: outputs.PortalProductVersionAuthStrategyKeyAuth;
}

export interface PortalProductVersionAuthStrategyClientCredentials {
    authMethods: string[];
    /**
     * must be one of ["client*credentials", "self*managed*client*credentials"]
     */
    credentialType: string;
    /**
     * The Application Auth Strategy ID.
     */
    id: string;
    name: string;
}

export interface PortalProductVersionAuthStrategyKeyAuth {
    /**
     * must be one of ["keyAuth"]
     */
    credentialType: string;
    /**
     * The Application Auth Strategy ID.
     */
    id: string;
    name: string;
}

export interface ServerlessCloudGatewayControlPlane {
    /**
     * ID of the serverless cloud gateway CP. Requires replacement if changed.
     */
    id: string;
    /**
     * The prefix of the serverless cloud gateway CP. Requires replacement if changed.
     */
    prefix: string;
    /**
     * The control plane region. Requires replacement if changed. ; must be one of ["us", "eu", "au"]
     */
    region: string;
}

