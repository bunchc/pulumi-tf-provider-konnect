// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package konnect

import (
	"context"
	"reflect"

	"errors"
	"github.com/bunchc/pulumi-tf-provider-konnect/sdk/go/konnect/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// GatewayCertificate Resource
type GatewayCertificate struct {
	pulumi.CustomResourceState

	// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert pulumi.StringOutput `pulumi:"cert"`
	// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	CertAlt pulumi.StringOutput `pulumi:"certAlt"`
	// The UUID of your control plane. This variable is available in the Konnect manager.
	ControlPlaneId pulumi.StringOutput `pulumi:"controlPlaneId"`
	// Unix epoch when the resource was created.
	CreatedAt pulumi.IntOutput `pulumi:"createdAt"`
	// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key pulumi.StringOutput `pulumi:"key"`
	// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt pulumi.StringOutput `pulumi:"keyAlt"`
	// An optional set of strings associated with the Certificate for grouping and filtering.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt pulumi.IntOutput `pulumi:"updatedAt"`
}

// NewGatewayCertificate registers a new resource with the given unique name, arguments, and options.
func NewGatewayCertificate(ctx *pulumi.Context,
	name string, args *GatewayCertificateArgs, opts ...pulumi.ResourceOption) (*GatewayCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ControlPlaneId == nil {
		return nil, errors.New("invalid value for required argument 'ControlPlaneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GatewayCertificate
	err := ctx.RegisterResource("konnect:index/gatewayCertificate:GatewayCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGatewayCertificate gets an existing GatewayCertificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGatewayCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GatewayCertificateState, opts ...pulumi.ResourceOption) (*GatewayCertificate, error) {
	var resource GatewayCertificate
	err := ctx.ReadResource("konnect:index/gatewayCertificate:GatewayCertificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GatewayCertificate resources.
type gatewayCertificateState struct {
	// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert *string `pulumi:"cert"`
	// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	CertAlt *string `pulumi:"certAlt"`
	// The UUID of your control plane. This variable is available in the Konnect manager.
	ControlPlaneId *string `pulumi:"controlPlaneId"`
	// Unix epoch when the resource was created.
	CreatedAt *int `pulumi:"createdAt"`
	// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key *string `pulumi:"key"`
	// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt *string `pulumi:"keyAlt"`
	// An optional set of strings associated with the Certificate for grouping and filtering.
	Tags []string `pulumi:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int `pulumi:"updatedAt"`
}

type GatewayCertificateState struct {
	// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert pulumi.StringPtrInput
	// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	CertAlt pulumi.StringPtrInput
	// The UUID of your control plane. This variable is available in the Konnect manager.
	ControlPlaneId pulumi.StringPtrInput
	// Unix epoch when the resource was created.
	CreatedAt pulumi.IntPtrInput
	// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key pulumi.StringPtrInput
	// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt pulumi.StringPtrInput
	// An optional set of strings associated with the Certificate for grouping and filtering.
	Tags pulumi.StringArrayInput
	// Unix epoch when the resource was last updated.
	UpdatedAt pulumi.IntPtrInput
}

func (GatewayCertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*gatewayCertificateState)(nil)).Elem()
}

type gatewayCertificateArgs struct {
	// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert *string `pulumi:"cert"`
	// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	CertAlt *string `pulumi:"certAlt"`
	// The UUID of your control plane. This variable is available in the Konnect manager.
	ControlPlaneId string `pulumi:"controlPlaneId"`
	// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key *string `pulumi:"key"`
	// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt *string `pulumi:"keyAlt"`
	// An optional set of strings associated with the Certificate for grouping and filtering.
	Tags []string `pulumi:"tags"`
}

// The set of arguments for constructing a GatewayCertificate resource.
type GatewayCertificateArgs struct {
	// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert pulumi.StringPtrInput
	// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	CertAlt pulumi.StringPtrInput
	// The UUID of your control plane. This variable is available in the Konnect manager.
	ControlPlaneId pulumi.StringInput
	// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key pulumi.StringPtrInput
	// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt pulumi.StringPtrInput
	// An optional set of strings associated with the Certificate for grouping and filtering.
	Tags pulumi.StringArrayInput
}

func (GatewayCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*gatewayCertificateArgs)(nil)).Elem()
}

type GatewayCertificateInput interface {
	pulumi.Input

	ToGatewayCertificateOutput() GatewayCertificateOutput
	ToGatewayCertificateOutputWithContext(ctx context.Context) GatewayCertificateOutput
}

func (*GatewayCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayCertificate)(nil)).Elem()
}

func (i *GatewayCertificate) ToGatewayCertificateOutput() GatewayCertificateOutput {
	return i.ToGatewayCertificateOutputWithContext(context.Background())
}

func (i *GatewayCertificate) ToGatewayCertificateOutputWithContext(ctx context.Context) GatewayCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayCertificateOutput)
}

// GatewayCertificateArrayInput is an input type that accepts GatewayCertificateArray and GatewayCertificateArrayOutput values.
// You can construct a concrete instance of `GatewayCertificateArrayInput` via:
//
//	GatewayCertificateArray{ GatewayCertificateArgs{...} }
type GatewayCertificateArrayInput interface {
	pulumi.Input

	ToGatewayCertificateArrayOutput() GatewayCertificateArrayOutput
	ToGatewayCertificateArrayOutputWithContext(context.Context) GatewayCertificateArrayOutput
}

type GatewayCertificateArray []GatewayCertificateInput

func (GatewayCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GatewayCertificate)(nil)).Elem()
}

func (i GatewayCertificateArray) ToGatewayCertificateArrayOutput() GatewayCertificateArrayOutput {
	return i.ToGatewayCertificateArrayOutputWithContext(context.Background())
}

func (i GatewayCertificateArray) ToGatewayCertificateArrayOutputWithContext(ctx context.Context) GatewayCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayCertificateArrayOutput)
}

// GatewayCertificateMapInput is an input type that accepts GatewayCertificateMap and GatewayCertificateMapOutput values.
// You can construct a concrete instance of `GatewayCertificateMapInput` via:
//
//	GatewayCertificateMap{ "key": GatewayCertificateArgs{...} }
type GatewayCertificateMapInput interface {
	pulumi.Input

	ToGatewayCertificateMapOutput() GatewayCertificateMapOutput
	ToGatewayCertificateMapOutputWithContext(context.Context) GatewayCertificateMapOutput
}

type GatewayCertificateMap map[string]GatewayCertificateInput

func (GatewayCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GatewayCertificate)(nil)).Elem()
}

func (i GatewayCertificateMap) ToGatewayCertificateMapOutput() GatewayCertificateMapOutput {
	return i.ToGatewayCertificateMapOutputWithContext(context.Background())
}

func (i GatewayCertificateMap) ToGatewayCertificateMapOutputWithContext(ctx context.Context) GatewayCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayCertificateMapOutput)
}

type GatewayCertificateOutput struct{ *pulumi.OutputState }

func (GatewayCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayCertificate)(nil)).Elem()
}

func (o GatewayCertificateOutput) ToGatewayCertificateOutput() GatewayCertificateOutput {
	return o
}

func (o GatewayCertificateOutput) ToGatewayCertificateOutputWithContext(ctx context.Context) GatewayCertificateOutput {
	return o
}

// PEM-encoded public certificate chain of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
func (o GatewayCertificateOutput) Cert() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringOutput { return v.Cert }).(pulumi.StringOutput)
}

// PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
func (o GatewayCertificateOutput) CertAlt() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringOutput { return v.CertAlt }).(pulumi.StringOutput)
}

// The UUID of your control plane. This variable is available in the Konnect manager.
func (o GatewayCertificateOutput) ControlPlaneId() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringOutput { return v.ControlPlaneId }).(pulumi.StringOutput)
}

// Unix epoch when the resource was created.
func (o GatewayCertificateOutput) CreatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.IntOutput { return v.CreatedAt }).(pulumi.IntOutput)
}

// PEM-encoded private key of the SSL key pair. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
func (o GatewayCertificateOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is *referenceable*, which means it can be securely stored as a [secret](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](https://www.terraform.io/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
func (o GatewayCertificateOutput) KeyAlt() pulumi.StringOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringOutput { return v.KeyAlt }).(pulumi.StringOutput)
}

// An optional set of strings associated with the Certificate for grouping and filtering.
func (o GatewayCertificateOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Unix epoch when the resource was last updated.
func (o GatewayCertificateOutput) UpdatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *GatewayCertificate) pulumi.IntOutput { return v.UpdatedAt }).(pulumi.IntOutput)
}

type GatewayCertificateArrayOutput struct{ *pulumi.OutputState }

func (GatewayCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GatewayCertificate)(nil)).Elem()
}

func (o GatewayCertificateArrayOutput) ToGatewayCertificateArrayOutput() GatewayCertificateArrayOutput {
	return o
}

func (o GatewayCertificateArrayOutput) ToGatewayCertificateArrayOutputWithContext(ctx context.Context) GatewayCertificateArrayOutput {
	return o
}

func (o GatewayCertificateArrayOutput) Index(i pulumi.IntInput) GatewayCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GatewayCertificate {
		return vs[0].([]*GatewayCertificate)[vs[1].(int)]
	}).(GatewayCertificateOutput)
}

type GatewayCertificateMapOutput struct{ *pulumi.OutputState }

func (GatewayCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GatewayCertificate)(nil)).Elem()
}

func (o GatewayCertificateMapOutput) ToGatewayCertificateMapOutput() GatewayCertificateMapOutput {
	return o
}

func (o GatewayCertificateMapOutput) ToGatewayCertificateMapOutputWithContext(ctx context.Context) GatewayCertificateMapOutput {
	return o
}

func (o GatewayCertificateMapOutput) MapIndex(k pulumi.StringInput) GatewayCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GatewayCertificate {
		return vs[0].(map[string]*GatewayCertificate)[vs[1].(string)]
	}).(GatewayCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayCertificateInput)(nil)).Elem(), &GatewayCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayCertificateArrayInput)(nil)).Elem(), GatewayCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayCertificateMapInput)(nil)).Elem(), GatewayCertificateMap{})
	pulumi.RegisterOutputType(GatewayCertificateOutput{})
	pulumi.RegisterOutputType(GatewayCertificateArrayOutput{})
	pulumi.RegisterOutputType(GatewayCertificateMapOutput{})
}
