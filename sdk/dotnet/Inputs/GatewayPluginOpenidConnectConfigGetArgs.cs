// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Konnect.Inputs
{

    public sealed class GatewayPluginOpenidConnectConfigGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
        /// </summary>
        [Input("anonymous")]
        public Input<string>? Anonymous { get; set; }

        [Input("audienceClaims")]
        private InputList<string>? _audienceClaims;

        /// <summary>
        /// The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> AudienceClaims
        {
            get => _audienceClaims ?? (_audienceClaims = new InputList<string>());
            set => _audienceClaims = value;
        }

        [Input("audienceRequireds")]
        private InputList<string>? _audienceRequireds;

        /// <summary>
        /// The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        /// </summary>
        public InputList<string> AudienceRequireds
        {
            get => _audienceRequireds ?? (_audienceRequireds = new InputList<string>());
            set => _audienceRequireds = value;
        }

        [Input("audiences")]
        private InputList<string>? _audiences;

        /// <summary>
        /// The audience passed to the authorization endpoint.
        /// </summary>
        public InputList<string> Audiences
        {
            get => _audiences ?? (_audiences = new InputList<string>());
            set => _audiences = value;
        }

        [Input("authMethods")]
        private InputList<string>? _authMethods;

        /// <summary>
        /// Types of credentials/grants to enable.
        /// </summary>
        public InputList<string> AuthMethods
        {
            get => _authMethods ?? (_authMethods = new InputList<string>());
            set => _authMethods = value;
        }

        [Input("authenticatedGroupsClaims")]
        private InputList<string>? _authenticatedGroupsClaims;

        /// <summary>
        /// The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> AuthenticatedGroupsClaims
        {
            get => _authenticatedGroupsClaims ?? (_authenticatedGroupsClaims = new InputList<string>());
            set => _authenticatedGroupsClaims = value;
        }

        /// <summary>
        /// The authorization cookie Domain flag.
        /// </summary>
        [Input("authorizationCookieDomain")]
        public Input<string>? AuthorizationCookieDomain { get; set; }

        /// <summary>
        /// Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        /// </summary>
        [Input("authorizationCookieHttpOnly")]
        public Input<bool>? AuthorizationCookieHttpOnly { get; set; }

        /// <summary>
        /// The authorization cookie name.
        /// </summary>
        [Input("authorizationCookieName")]
        public Input<string>? AuthorizationCookieName { get; set; }

        /// <summary>
        /// The authorization cookie Path flag.
        /// </summary>
        [Input("authorizationCookiePath")]
        public Input<string>? AuthorizationCookiePath { get; set; }

        /// <summary>
        /// Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        /// </summary>
        [Input("authorizationCookieSameSite")]
        public Input<string>? AuthorizationCookieSameSite { get; set; }

        /// <summary>
        /// Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        /// </summary>
        [Input("authorizationCookieSecure")]
        public Input<bool>? AuthorizationCookieSecure { get; set; }

        /// <summary>
        /// The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("authorizationEndpoint")]
        public Input<string>? AuthorizationEndpoint { get; set; }

        [Input("authorizationQueryArgsClients")]
        private InputList<string>? _authorizationQueryArgsClients;

        /// <summary>
        /// Extra query arguments passed from the client to the authorization endpoint.
        /// </summary>
        public InputList<string> AuthorizationQueryArgsClients
        {
            get => _authorizationQueryArgsClients ?? (_authorizationQueryArgsClients = new InputList<string>());
            set => _authorizationQueryArgsClients = value;
        }

        [Input("authorizationQueryArgsNames")]
        private InputList<string>? _authorizationQueryArgsNames;

        /// <summary>
        /// Extra query argument names passed to the authorization endpoint.
        /// </summary>
        public InputList<string> AuthorizationQueryArgsNames
        {
            get => _authorizationQueryArgsNames ?? (_authorizationQueryArgsNames = new InputList<string>());
            set => _authorizationQueryArgsNames = value;
        }

        [Input("authorizationQueryArgsValues")]
        private InputList<string>? _authorizationQueryArgsValues;

        /// <summary>
        /// Extra query argument values passed to the authorization endpoint.
        /// </summary>
        public InputList<string> AuthorizationQueryArgsValues
        {
            get => _authorizationQueryArgsValues ?? (_authorizationQueryArgsValues = new InputList<string>());
            set => _authorizationQueryArgsValues = value;
        }

        /// <summary>
        /// Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        /// </summary>
        [Input("authorizationRollingTimeout")]
        public Input<double>? AuthorizationRollingTimeout { get; set; }

        /// <summary>
        /// The name of the cookie in which the bearer token is passed.
        /// </summary>
        [Input("bearerTokenCookieName")]
        public Input<string>? BearerTokenCookieName { get; set; }

        [Input("bearerTokenParamTypes")]
        private InputList<string>? _bearerTokenParamTypes;

        /// <summary>
        /// Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
        /// </summary>
        public InputList<string> BearerTokenParamTypes
        {
            get => _bearerTokenParamTypes ?? (_bearerTokenParamTypes = new InputList<string>());
            set => _bearerTokenParamTypes = value;
        }

        /// <summary>
        /// If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
        /// </summary>
        [Input("byUsernameIgnoreCase")]
        public Input<bool>? ByUsernameIgnoreCase { get; set; }

        /// <summary>
        /// Cache the introspection endpoint requests.
        /// </summary>
        [Input("cacheIntrospection")]
        public Input<bool>? CacheIntrospection { get; set; }

        /// <summary>
        /// Cache the token exchange endpoint requests.
        /// </summary>
        [Input("cacheTokenExchange")]
        public Input<bool>? CacheTokenExchange { get; set; }

        /// <summary>
        /// Cache the token endpoint requests.
        /// </summary>
        [Input("cacheTokens")]
        public Input<bool>? CacheTokens { get; set; }

        /// <summary>
        /// Salt used for generating the cache key that is used for caching the token endpoint requests.
        /// </summary>
        [Input("cacheTokensSalt")]
        public Input<string>? CacheTokensSalt { get; set; }

        /// <summary>
        /// The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
        /// </summary>
        [Input("cacheTtl")]
        public Input<double>? CacheTtl { get; set; }

        /// <summary>
        /// The maximum cache ttl in seconds (enforced).
        /// </summary>
        [Input("cacheTtlMax")]
        public Input<double>? CacheTtlMax { get; set; }

        /// <summary>
        /// The minimum cache ttl in seconds (enforced).
        /// </summary>
        [Input("cacheTtlMin")]
        public Input<double>? CacheTtlMin { get; set; }

        /// <summary>
        /// The negative cache ttl in seconds.
        /// </summary>
        [Input("cacheTtlNeg")]
        public Input<double>? CacheTtlNeg { get; set; }

        /// <summary>
        /// The resurrection ttl in seconds.
        /// </summary>
        [Input("cacheTtlResurrect")]
        public Input<double>? CacheTtlResurrect { get; set; }

        /// <summary>
        /// Cache the user info requests.
        /// </summary>
        [Input("cacheUserInfo")]
        public Input<bool>? CacheUserInfo { get; set; }

        [Input("clientAlgs")]
        private InputList<string>? _clientAlgs;

        /// <summary>
        /// The algorithm to use for client*secret*jwt (only HS***) or private*key*jwt authentication.
        /// </summary>
        public InputList<string> ClientAlgs
        {
            get => _clientAlgs ?? (_clientAlgs = new InputList<string>());
            set => _clientAlgs = value;
        }

        /// <summary>
        /// The client to use for this request (the selection is made with a request parameter with the same name).
        /// </summary>
        [Input("clientArg")]
        public Input<string>? ClientArg { get; set; }

        [Input("clientAuths")]
        private InputList<string>? _clientAuths;

        /// <summary>
        /// The default OpenID Connect client authentication method is 'client*secret*basic' (using 'Authorization: Basic' header), 'client*secret*post' (credentials in body), 'client*secret*jwt' (signed client assertion in body), 'private*key*jwt' (private key-signed assertion), 'tls*client*auth' (client certificate), 'self*signed*tls*client*auth' (self-signed client certificate), and 'none' (no authentication).
        /// </summary>
        public InputList<string> ClientAuths
        {
            get => _clientAuths ?? (_clientAuths = new InputList<string>());
            set => _clientAuths = value;
        }

        [Input("clientCredentialsParamTypes")]
        private InputList<string>? _clientCredentialsParamTypes;

        /// <summary>
        /// Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
        /// </summary>
        public InputList<string> ClientCredentialsParamTypes
        {
            get => _clientCredentialsParamTypes ?? (_clientCredentialsParamTypes = new InputList<string>());
            set => _clientCredentialsParamTypes = value;
        }

        [Input("clientIds")]
        private InputList<string>? _clientIds;

        /// <summary>
        /// The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
        /// </summary>
        public InputList<string> ClientIds
        {
            get => _clientIds ?? (_clientIds = new InputList<string>());
            set => _clientIds = value;
        }

        [Input("clientJwks")]
        private InputList<Inputs.GatewayPluginOpenidConnectConfigClientJwkGetArgs>? _clientJwks;

        /// <summary>
        /// The JWK used for the private*key*jwt authentication.
        /// </summary>
        public InputList<Inputs.GatewayPluginOpenidConnectConfigClientJwkGetArgs> ClientJwks
        {
            get => _clientJwks ?? (_clientJwks = new InputList<Inputs.GatewayPluginOpenidConnectConfigClientJwkGetArgs>());
            set => _clientJwks = value;
        }

        [Input("clientSecrets")]
        private InputList<string>? _clientSecrets;

        /// <summary>
        /// The client secret.
        /// </summary>
        public InputList<string> ClientSecrets
        {
            get => _clientSecrets ?? (_clientSecrets = new InputList<string>());
            set => _clientSecrets = value;
        }

        [Input("consumerBies")]
        private InputList<string>? _consumerBies;

        /// <summary>
        /// Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
        /// </summary>
        public InputList<string> ConsumerBies
        {
            get => _consumerBies ?? (_consumerBies = new InputList<string>());
            set => _consumerBies = value;
        }

        [Input("consumerClaims")]
        private InputList<string>? _consumerClaims;

        /// <summary>
        /// The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> ConsumerClaims
        {
            get => _consumerClaims ?? (_consumerClaims = new InputList<string>());
            set => _consumerClaims = value;
        }

        /// <summary>
        /// Do not terminate the request if consumer mapping fails.
        /// </summary>
        [Input("consumerOptional")]
        public Input<bool>? ConsumerOptional { get; set; }

        [Input("credentialClaims")]
        private InputList<string>? _credentialClaims;

        /// <summary>
        /// The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> CredentialClaims
        {
            get => _credentialClaims ?? (_credentialClaims = new InputList<string>());
            set => _credentialClaims = value;
        }

        [Input("disableSessions")]
        private InputList<string>? _disableSessions;

        /// <summary>
        /// Disable issuing the session cookie with the specified grants.
        /// </summary>
        public InputList<string> DisableSessions
        {
            get => _disableSessions ?? (_disableSessions = new InputList<string>());
            set => _disableSessions = value;
        }

        [Input("discoveryHeadersNames")]
        private InputList<string>? _discoveryHeadersNames;

        /// <summary>
        /// Extra header names passed to the discovery endpoint.
        /// </summary>
        public InputList<string> DiscoveryHeadersNames
        {
            get => _discoveryHeadersNames ?? (_discoveryHeadersNames = new InputList<string>());
            set => _discoveryHeadersNames = value;
        }

        [Input("discoveryHeadersValues")]
        private InputList<string>? _discoveryHeadersValues;

        /// <summary>
        /// Extra header values passed to the discovery endpoint.
        /// </summary>
        public InputList<string> DiscoveryHeadersValues
        {
            get => _discoveryHeadersValues ?? (_discoveryHeadersValues = new InputList<string>());
            set => _discoveryHeadersValues = value;
        }

        /// <summary>
        /// Display errors on failure responses.
        /// </summary>
        [Input("displayErrors")]
        public Input<bool>? DisplayErrors { get; set; }

        [Input("domains")]
        private InputList<string>? _domains;

        /// <summary>
        /// The allowed values for the `hd` claim.
        /// </summary>
        public InputList<string> Domains
        {
            get => _domains ?? (_domains = new InputList<string>());
            set => _domains = value;
        }

        /// <summary>
        /// The downstream access token header.
        /// </summary>
        [Input("downstreamAccessTokenHeader")]
        public Input<string>? DownstreamAccessTokenHeader { get; set; }

        /// <summary>
        /// The downstream access token JWK header.
        /// </summary>
        [Input("downstreamAccessTokenJwkHeader")]
        public Input<string>? DownstreamAccessTokenJwkHeader { get; set; }

        [Input("downstreamHeadersClaims")]
        private InputList<string>? _downstreamHeadersClaims;

        /// <summary>
        /// The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> DownstreamHeadersClaims
        {
            get => _downstreamHeadersClaims ?? (_downstreamHeadersClaims = new InputList<string>());
            set => _downstreamHeadersClaims = value;
        }

        [Input("downstreamHeadersNames")]
        private InputList<string>? _downstreamHeadersNames;

        /// <summary>
        /// The downstream header names for the claim values.
        /// </summary>
        public InputList<string> DownstreamHeadersNames
        {
            get => _downstreamHeadersNames ?? (_downstreamHeadersNames = new InputList<string>());
            set => _downstreamHeadersNames = value;
        }

        /// <summary>
        /// The downstream id token header.
        /// </summary>
        [Input("downstreamIdTokenHeader")]
        public Input<string>? DownstreamIdTokenHeader { get; set; }

        /// <summary>
        /// The downstream id token JWK header.
        /// </summary>
        [Input("downstreamIdTokenJwkHeader")]
        public Input<string>? DownstreamIdTokenJwkHeader { get; set; }

        /// <summary>
        /// The downstream introspection header.
        /// </summary>
        [Input("downstreamIntrospectionHeader")]
        public Input<string>? DownstreamIntrospectionHeader { get; set; }

        /// <summary>
        /// The downstream introspection JWT header.
        /// </summary>
        [Input("downstreamIntrospectionJwtHeader")]
        public Input<string>? DownstreamIntrospectionJwtHeader { get; set; }

        /// <summary>
        /// The downstream refresh token header.
        /// </summary>
        [Input("downstreamRefreshTokenHeader")]
        public Input<string>? DownstreamRefreshTokenHeader { get; set; }

        /// <summary>
        /// The downstream session id header.
        /// </summary>
        [Input("downstreamSessionIdHeader")]
        public Input<string>? DownstreamSessionIdHeader { get; set; }

        /// <summary>
        /// The downstream user info header.
        /// </summary>
        [Input("downstreamUserInfoHeader")]
        public Input<string>? DownstreamUserInfoHeader { get; set; }

        /// <summary>
        /// The downstream user info JWT header (in case the user info returns a JWT response).
        /// </summary>
        [Input("downstreamUserInfoJwtHeader")]
        public Input<string>? DownstreamUserInfoJwtHeader { get; set; }

        /// <summary>
        /// Specifies the lifetime in seconds of the DPoP proof. It determines how long the same proof can be used after creation. The creation time is determined by the nonce creation time if a nonce is used, and the iat claim otherwise.
        /// </summary>
        [Input("dpopProofLifetime")]
        public Input<double>? DpopProofLifetime { get; set; }

        /// <summary>
        /// Specifies whether to challenge the client with a nonce value for DPoP proof. When enabled it will also be used to calculate the DPoP proof lifetime.
        /// </summary>
        [Input("dpopUseNonce")]
        public Input<bool>? DpopUseNonce { get; set; }

        /// <summary>
        /// Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
        /// </summary>
        [Input("enableHsSignatures")]
        public Input<bool>? EnableHsSignatures { get; set; }

        /// <summary>
        /// The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("endSessionEndpoint")]
        public Input<string>? EndSessionEndpoint { get; set; }

        /// <summary>
        /// Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
        /// </summary>
        [Input("exposeErrorCode")]
        public Input<bool>? ExposeErrorCode { get; set; }

        [Input("extraJwksUris")]
        private InputList<string>? _extraJwksUris;

        /// <summary>
        /// JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
        /// </summary>
        public InputList<string> ExtraJwksUris
        {
            get => _extraJwksUris ?? (_extraJwksUris = new InputList<string>());
            set => _extraJwksUris = value;
        }

        /// <summary>
        /// Destroy any active session for the forbidden requests.
        /// </summary>
        [Input("forbiddenDestroySession")]
        public Input<bool>? ForbiddenDestroySession { get; set; }

        /// <summary>
        /// The error message for the forbidden requests (when not using the redirection).
        /// </summary>
        [Input("forbiddenErrorMessage")]
        public Input<string>? ForbiddenErrorMessage { get; set; }

        [Input("forbiddenRedirectUris")]
        private InputList<string>? _forbiddenRedirectUris;

        /// <summary>
        /// Where to redirect the client on forbidden requests.
        /// </summary>
        public InputList<string> ForbiddenRedirectUris
        {
            get => _forbiddenRedirectUris ?? (_forbiddenRedirectUris = new InputList<string>());
            set => _forbiddenRedirectUris = value;
        }

        [Input("groupsClaims")]
        private InputList<string>? _groupsClaims;

        /// <summary>
        /// The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> GroupsClaims
        {
            get => _groupsClaims ?? (_groupsClaims = new InputList<string>());
            set => _groupsClaims = value;
        }

        [Input("groupsRequireds")]
        private InputList<string>? _groupsRequireds;

        /// <summary>
        /// The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        /// </summary>
        public InputList<string> GroupsRequireds
        {
            get => _groupsRequireds ?? (_groupsRequireds = new InputList<string>());
            set => _groupsRequireds = value;
        }

        /// <summary>
        /// Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
        /// </summary>
        [Input("hideCredentials")]
        public Input<bool>? HideCredentials { get; set; }

        /// <summary>
        /// The HTTP proxy.
        /// </summary>
        [Input("httpProxy")]
        public Input<string>? HttpProxy { get; set; }

        /// <summary>
        /// The HTTP proxy authorization.
        /// </summary>
        [Input("httpProxyAuthorization")]
        public Input<string>? HttpProxyAuthorization { get; set; }

        /// <summary>
        /// The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
        /// </summary>
        [Input("httpVersion")]
        public Input<double>? HttpVersion { get; set; }

        /// <summary>
        /// The HTTPS proxy.
        /// </summary>
        [Input("httpsProxy")]
        public Input<string>? HttpsProxy { get; set; }

        /// <summary>
        /// The HTTPS proxy authorization.
        /// </summary>
        [Input("httpsProxyAuthorization")]
        public Input<string>? HttpsProxyAuthorization { get; set; }

        /// <summary>
        /// The name of the parameter used to pass the id token.
        /// </summary>
        [Input("idTokenParamName")]
        public Input<string>? IdTokenParamName { get; set; }

        [Input("idTokenParamTypes")]
        private InputList<string>? _idTokenParamTypes;

        /// <summary>
        /// Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        /// </summary>
        public InputList<string> IdTokenParamTypes
        {
            get => _idTokenParamTypes ?? (_idTokenParamTypes = new InputList<string>());
            set => _idTokenParamTypes = value;
        }

        [Input("ignoreSignatures")]
        private InputList<string>? _ignoreSignatures;

        /// <summary>
        /// Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
        /// </summary>
        public InputList<string> IgnoreSignatures
        {
            get => _ignoreSignatures ?? (_ignoreSignatures = new InputList<string>());
            set => _ignoreSignatures = value;
        }

        /// <summary>
        /// Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
        /// </summary>
        [Input("introspectJwtTokens")]
        public Input<bool>? IntrospectJwtTokens { get; set; }

        /// <summary>
        /// The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/token-introspection+jwt", "application/jwt"]
        /// </summary>
        [Input("introspectionAccept")]
        public Input<string>? IntrospectionAccept { get; set; }

        /// <summary>
        /// Check that the introspection response has an `active` claim with a value of `true`.
        /// </summary>
        [Input("introspectionCheckActive")]
        public Input<bool>? IntrospectionCheckActive { get; set; }

        /// <summary>
        /// The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("introspectionEndpoint")]
        public Input<string>? IntrospectionEndpoint { get; set; }

        /// <summary>
        /// The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client*secret*basic", "client*secret*post", "client*secret*jwt", "private*key*jwt", "tls*client*auth", "self*signed*tls*client*auth", "none"]
        /// </summary>
        [Input("introspectionEndpointAuthMethod")]
        public Input<string>? IntrospectionEndpointAuthMethod { get; set; }

        [Input("introspectionHeadersClients")]
        private InputList<string>? _introspectionHeadersClients;

        /// <summary>
        /// Extra headers passed from the client to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionHeadersClients
        {
            get => _introspectionHeadersClients ?? (_introspectionHeadersClients = new InputList<string>());
            set => _introspectionHeadersClients = value;
        }

        [Input("introspectionHeadersNames")]
        private InputList<string>? _introspectionHeadersNames;

        /// <summary>
        /// Extra header names passed to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionHeadersNames
        {
            get => _introspectionHeadersNames ?? (_introspectionHeadersNames = new InputList<string>());
            set => _introspectionHeadersNames = value;
        }

        [Input("introspectionHeadersValues")]
        private InputList<string>? _introspectionHeadersValues;

        /// <summary>
        /// Extra header values passed to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionHeadersValues
        {
            get => _introspectionHeadersValues ?? (_introspectionHeadersValues = new InputList<string>());
            set => _introspectionHeadersValues = value;
        }

        /// <summary>
        /// Introspection hint parameter value passed to the introspection endpoint.
        /// </summary>
        [Input("introspectionHint")]
        public Input<string>? IntrospectionHint { get; set; }

        [Input("introspectionPostArgsClients")]
        private InputList<string>? _introspectionPostArgsClients;

        /// <summary>
        /// Extra post arguments passed from the client to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionPostArgsClients
        {
            get => _introspectionPostArgsClients ?? (_introspectionPostArgsClients = new InputList<string>());
            set => _introspectionPostArgsClients = value;
        }

        [Input("introspectionPostArgsNames")]
        private InputList<string>? _introspectionPostArgsNames;

        /// <summary>
        /// Extra post argument names passed to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionPostArgsNames
        {
            get => _introspectionPostArgsNames ?? (_introspectionPostArgsNames = new InputList<string>());
            set => _introspectionPostArgsNames = value;
        }

        [Input("introspectionPostArgsValues")]
        private InputList<string>? _introspectionPostArgsValues;

        /// <summary>
        /// Extra post argument values passed to the introspection endpoint.
        /// </summary>
        public InputList<string> IntrospectionPostArgsValues
        {
            get => _introspectionPostArgsValues ?? (_introspectionPostArgsValues = new InputList<string>());
            set => _introspectionPostArgsValues = value;
        }

        /// <summary>
        /// Designate token's parameter name for introspection.
        /// </summary>
        [Input("introspectionTokenParamName")]
        public Input<string>? IntrospectionTokenParamName { get; set; }

        /// <summary>
        /// The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
        /// </summary>
        [Input("issuer")]
        public Input<string>? Issuer { get; set; }

        [Input("issuersAlloweds")]
        private InputList<string>? _issuersAlloweds;

        /// <summary>
        /// The issuers allowed to be present in the tokens (`iss` claim).
        /// </summary>
        public InputList<string> IssuersAlloweds
        {
            get => _issuersAlloweds ?? (_issuersAlloweds = new InputList<string>());
            set => _issuersAlloweds = value;
        }

        /// <summary>
        /// The claim to match against the JWT session cookie.
        /// </summary>
        [Input("jwtSessionClaim")]
        public Input<string>? JwtSessionClaim { get; set; }

        /// <summary>
        /// The name of the JWT session cookie.
        /// </summary>
        [Input("jwtSessionCookie")]
        public Input<string>? JwtSessionCookie { get; set; }

        /// <summary>
        /// Use keepalive with the HTTP client.
        /// </summary>
        [Input("keepalive")]
        public Input<bool>? Keepalive { get; set; }

        /// <summary>
        /// Defines leeway time (in seconds) for `auth_time`, `exp`, `iat`, and `nbf` claims
        /// </summary>
        [Input("leeway")]
        public Input<double>? Leeway { get; set; }

        /// <summary>
        /// What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location. must be one of ["upstream", "response", "redirect"]
        /// </summary>
        [Input("loginAction")]
        public Input<string>? LoginAction { get; set; }

        [Input("loginMethods")]
        private InputList<string>? _loginMethods;

        /// <summary>
        /// Enable login functionality with specified grants.
        /// </summary>
        public InputList<string> LoginMethods
        {
            get => _loginMethods ?? (_loginMethods = new InputList<string>());
            set => _loginMethods = value;
        }

        /// <summary>
        /// Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers). must be one of ["query", "fragment"]
        /// </summary>
        [Input("loginRedirectMode")]
        public Input<string>? LoginRedirectMode { get; set; }

        [Input("loginRedirectUris")]
        private InputList<string>? _loginRedirectUris;

        /// <summary>
        /// Where to redirect the client when `login_action` is set to `redirect`.
        /// </summary>
        public InputList<string> LoginRedirectUris
        {
            get => _loginRedirectUris ?? (_loginRedirectUris = new InputList<string>());
            set => _loginRedirectUris = value;
        }

        [Input("loginTokens")]
        private InputList<string>? _loginTokens;

        /// <summary>
        /// What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
        /// </summary>
        public InputList<string> LoginTokens
        {
            get => _loginTokens ?? (_loginTokens = new InputList<string>());
            set => _loginTokens = value;
        }

        [Input("logoutMethods")]
        private InputList<string>? _logoutMethods;

        /// <summary>
        /// The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
        /// </summary>
        public InputList<string> LogoutMethods
        {
            get => _logoutMethods ?? (_logoutMethods = new InputList<string>());
            set => _logoutMethods = value;
        }

        /// <summary>
        /// The request body argument that activates the logout.
        /// </summary>
        [Input("logoutPostArg")]
        public Input<string>? LogoutPostArg { get; set; }

        /// <summary>
        /// The request query argument that activates the logout.
        /// </summary>
        [Input("logoutQueryArg")]
        public Input<string>? LogoutQueryArg { get; set; }

        [Input("logoutRedirectUris")]
        private InputList<string>? _logoutRedirectUris;

        /// <summary>
        /// Where to redirect the client after the logout.
        /// </summary>
        public InputList<string> LogoutRedirectUris
        {
            get => _logoutRedirectUris ?? (_logoutRedirectUris = new InputList<string>());
            set => _logoutRedirectUris = value;
        }

        /// <summary>
        /// Revoke tokens as part of the logout.
        /// </summary>
        [Input("logoutRevoke")]
        public Input<bool>? LogoutRevoke { get; set; }

        /// <summary>
        /// Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
        /// </summary>
        [Input("logoutRevokeAccessToken")]
        public Input<bool>? LogoutRevokeAccessToken { get; set; }

        /// <summary>
        /// Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
        /// </summary>
        [Input("logoutRevokeRefreshToken")]
        public Input<bool>? LogoutRevokeRefreshToken { get; set; }

        /// <summary>
        /// The request URI suffix that activates the logout.
        /// </summary>
        [Input("logoutUriSuffix")]
        public Input<string>? LogoutUriSuffix { get; set; }

        /// <summary>
        /// The maximum age (in seconds) compared to the `auth_time` claim.
        /// </summary>
        [Input("maxAge")]
        public Input<double>? MaxAge { get; set; }

        /// <summary>
        /// Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        /// </summary>
        [Input("mtlsIntrospectionEndpoint")]
        public Input<string>? MtlsIntrospectionEndpoint { get; set; }

        /// <summary>
        /// Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        /// </summary>
        [Input("mtlsRevocationEndpoint")]
        public Input<string>? MtlsRevocationEndpoint { get; set; }

        /// <summary>
        /// Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
        /// </summary>
        [Input("mtlsTokenEndpoint")]
        public Input<string>? MtlsTokenEndpoint { get; set; }

        /// <summary>
        /// Do not use proxy with these hosts.
        /// </summary>
        [Input("noProxy")]
        public Input<string>? NoProxy { get; set; }

        [Input("passwordParamTypes")]
        private InputList<string>? _passwordParamTypes;

        /// <summary>
        /// Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        /// </summary>
        public InputList<string> PasswordParamTypes
        {
            get => _passwordParamTypes ?? (_passwordParamTypes = new InputList<string>());
            set => _passwordParamTypes = value;
        }

        /// <summary>
        /// With this parameter, you can preserve request query arguments even when doing authorization code flow.
        /// </summary>
        [Input("preserveQueryArgs")]
        public Input<bool>? PreserveQueryArgs { get; set; }

        /// <summary>
        /// If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
        /// </summary>
        [Input("proofOfPossessionAuthMethodsValidation")]
        public Input<bool>? ProofOfPossessionAuthMethodsValidation { get; set; }

        /// <summary>
        /// Enable Demonstrating Proof-of-Possession (DPoP). If set to strict, all request are verified despite the presence of the DPoP key claim (cnf.jkt). If set to optional, only tokens bound with DPoP's key are verified with the proof. must be one of ["off", "strict", "optional"]
        /// </summary>
        [Input("proofOfPossessionDpop")]
        public Input<string>? ProofOfPossessionDpop { get; set; }

        /// <summary>
        /// Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401. must be one of ["off", "strict", "optional"]
        /// </summary>
        [Input("proofOfPossessionMtls")]
        public Input<string>? ProofOfPossessionMtls { get; set; }

        /// <summary>
        /// The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("pushedAuthorizationRequestEndpoint")]
        public Input<string>? PushedAuthorizationRequestEndpoint { get; set; }

        /// <summary>
        /// The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        /// </summary>
        [Input("pushedAuthorizationRequestEndpointAuthMethod")]
        public Input<string>? PushedAuthorizationRequestEndpointAuthMethod { get; set; }

        [Input("redirectUris")]
        private InputList<string>? _redirectUris;

        /// <summary>
        /// The redirect URI passed to the authorization and token endpoints.
        /// </summary>
        public InputList<string> RedirectUris
        {
            get => _redirectUris ?? (_redirectUris = new InputList<string>());
            set => _redirectUris = value;
        }

        /// <summary>
        /// Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
        /// </summary>
        [Input("rediscoveryLifetime")]
        public Input<double>? RediscoveryLifetime { get; set; }

        /// <summary>
        /// The name of the parameter used to pass the refresh token.
        /// </summary>
        [Input("refreshTokenParamName")]
        public Input<string>? RefreshTokenParamName { get; set; }

        [Input("refreshTokenParamTypes")]
        private InputList<string>? _refreshTokenParamTypes;

        /// <summary>
        /// Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
        /// </summary>
        public InputList<string> RefreshTokenParamTypes
        {
            get => _refreshTokenParamTypes ?? (_refreshTokenParamTypes = new InputList<string>());
            set => _refreshTokenParamTypes = value;
        }

        /// <summary>
        /// Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
        /// </summary>
        [Input("refreshTokens")]
        public Input<bool>? RefreshTokens { get; set; }

        /// <summary>
        /// Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
        /// </summary>
        [Input("requireProofKeyForCodeExchange")]
        public Input<bool>? RequireProofKeyForCodeExchange { get; set; }

        /// <summary>
        /// Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
        /// </summary>
        [Input("requirePushedAuthorizationRequests")]
        public Input<bool>? RequirePushedAuthorizationRequests { get; set; }

        /// <summary>
        /// Forcibly enable or disable the usage of signed request object on authorization or pushed authorization endpoint. When not set the value is determined through the discovery using the value of `require_signed_request_object`, and enabled automatically (in case the `require_signed_request_object` is missing, the feature will not be enabled).
        /// </summary>
        [Input("requireSignedRequestObject")]
        public Input<bool>? RequireSignedRequestObject { get; set; }

        /// <summary>
        /// Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
        /// </summary>
        [Input("resolveDistributedClaims")]
        public Input<bool>? ResolveDistributedClaims { get; set; }

        /// <summary>
        /// Response mode passed to the authorization endpoint: - `query`: for parameters in query string - `form_post`: for parameters in request body - `fragment`: for parameters in uri fragment (rarely useful as the plugin itself cannot read it) - `query.jwt`, `form_post.jwt`, `fragment.jwt`: similar to `query`, `form_post` and `fragment` but the parameters are encoded in a JWT - `jwt`: shortcut that indicates the default encoding for the requested response type. must be one of ["query", "form_post", "fragment", "query.jwt", "form_post.jwt", "fragment.jwt", "jwt"]
        /// </summary>
        [Input("responseMode")]
        public Input<string>? ResponseMode { get; set; }

        [Input("responseTypes")]
        private InputList<string>? _responseTypes;

        /// <summary>
        /// The response type passed to the authorization endpoint.
        /// </summary>
        public InputList<string> ResponseTypes
        {
            get => _responseTypes ?? (_responseTypes = new InputList<string>());
            set => _responseTypes = value;
        }

        /// <summary>
        /// Specifies whether to always verify tokens stored in the session.
        /// </summary>
        [Input("reverify")]
        public Input<bool>? Reverify { get; set; }

        /// <summary>
        /// The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("revocationEndpoint")]
        public Input<string>? RevocationEndpoint { get; set; }

        /// <summary>
        /// The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        /// </summary>
        [Input("revocationEndpointAuthMethod")]
        public Input<string>? RevocationEndpointAuthMethod { get; set; }

        /// <summary>
        /// Designate token's parameter name for revocation.
        /// </summary>
        [Input("revocationTokenParamName")]
        public Input<string>? RevocationTokenParamName { get; set; }

        [Input("rolesClaims")]
        private InputList<string>? _rolesClaims;

        /// <summary>
        /// The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> RolesClaims
        {
            get => _rolesClaims ?? (_rolesClaims = new InputList<string>());
            set => _rolesClaims = value;
        }

        [Input("rolesRequireds")]
        private InputList<string>? _rolesRequireds;

        /// <summary>
        /// The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        /// </summary>
        public InputList<string> RolesRequireds
        {
            get => _rolesRequireds ?? (_rolesRequireds = new InputList<string>());
            set => _rolesRequireds = value;
        }

        /// <summary>
        /// Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
        /// </summary>
        [Input("runOnPreflight")]
        public Input<bool>? RunOnPreflight { get; set; }

        [Input("scopes")]
        private InputList<string>? _scopes;

        /// <summary>
        /// The scopes passed to the authorization and token endpoints.
        /// </summary>
        public InputList<string> Scopes
        {
            get => _scopes ?? (_scopes = new InputList<string>());
            set => _scopes = value;
        }

        [Input("scopesClaims")]
        private InputList<string>? _scopesClaims;

        /// <summary>
        /// The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> ScopesClaims
        {
            get => _scopesClaims ?? (_scopesClaims = new InputList<string>());
            set => _scopesClaims = value;
        }

        [Input("scopesRequireds")]
        private InputList<string>? _scopesRequireds;

        /// <summary>
        /// The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
        /// </summary>
        public InputList<string> ScopesRequireds
        {
            get => _scopesRequireds ?? (_scopesRequireds = new InputList<string>());
            set => _scopesRequireds = value;
        }

        /// <summary>
        /// Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
        /// </summary>
        [Input("searchUserInfo")]
        public Input<bool>? SearchUserInfo { get; set; }

        /// <summary>
        /// Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        /// </summary>
        [Input("sessionAbsoluteTimeout")]
        public Input<double>? SessionAbsoluteTimeout { get; set; }

        /// <summary>
        /// The session audience, which is the intended target application. For example `"my-application"`.
        /// </summary>
        [Input("sessionAudience")]
        public Input<string>? SessionAudience { get; set; }

        /// <summary>
        /// The session cookie Domain flag.
        /// </summary>
        [Input("sessionCookieDomain")]
        public Input<string>? SessionCookieDomain { get; set; }

        /// <summary>
        /// Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        /// </summary>
        [Input("sessionCookieHttpOnly")]
        public Input<bool>? SessionCookieHttpOnly { get; set; }

        /// <summary>
        /// The session cookie name.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// The session cookie Path flag.
        /// </summary>
        [Input("sessionCookiePath")]
        public Input<string>? SessionCookiePath { get; set; }

        /// <summary>
        /// Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        /// </summary>
        [Input("sessionCookieSameSite")]
        public Input<string>? SessionCookieSameSite { get; set; }

        /// <summary>
        /// Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        /// </summary>
        [Input("sessionCookieSecure")]
        public Input<bool>? SessionCookieSecure { get; set; }

        /// <summary>
        /// When set to `true`, audiences are forced to share the same subject.
        /// </summary>
        [Input("sessionEnforceSameSubject")]
        public Input<bool>? SessionEnforceSameSubject { get; set; }

        /// <summary>
        /// When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        /// </summary>
        [Input("sessionHashStorageKey")]
        public Input<bool>? SessionHashStorageKey { get; set; }

        /// <summary>
        /// When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        /// </summary>
        [Input("sessionHashSubject")]
        public Input<bool>? SessionHashSubject { get; set; }

        /// <summary>
        /// Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
        /// </summary>
        [Input("sessionIdlingTimeout")]
        public Input<double>? SessionIdlingTimeout { get; set; }

        /// <summary>
        /// The memcached host.
        /// </summary>
        [Input("sessionMemcachedHost")]
        public Input<string>? SessionMemcachedHost { get; set; }

        /// <summary>
        /// The memcached port.
        /// </summary>
        [Input("sessionMemcachedPort")]
        public Input<int>? SessionMemcachedPort { get; set; }

        /// <summary>
        /// The memcached session key prefix.
        /// </summary>
        [Input("sessionMemcachedPrefix")]
        public Input<string>? SessionMemcachedPrefix { get; set; }

        /// <summary>
        /// The memcached unix socket path.
        /// </summary>
        [Input("sessionMemcachedSocket")]
        public Input<string>? SessionMemcachedSocket { get; set; }

        /// <summary>
        /// The Redis cluster maximum redirects.
        /// </summary>
        [Input("sessionRedisClusterMaxRedirections")]
        public Input<int>? SessionRedisClusterMaxRedirections { get; set; }

        [Input("sessionRedisClusterNodes")]
        private InputList<Inputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNodeGetArgs>? _sessionRedisClusterNodes;

        /// <summary>
        /// The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        /// </summary>
        public InputList<Inputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNodeGetArgs> SessionRedisClusterNodes
        {
            get => _sessionRedisClusterNodes ?? (_sessionRedisClusterNodes = new InputList<Inputs.GatewayPluginOpenidConnectConfigSessionRedisClusterNodeGetArgs>());
            set => _sessionRedisClusterNodes = value;
        }

        /// <summary>
        /// Session redis connection timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisConnectTimeout")]
        public Input<int>? SessionRedisConnectTimeout { get; set; }

        /// <summary>
        /// The Redis host.
        /// </summary>
        [Input("sessionRedisHost")]
        public Input<string>? SessionRedisHost { get; set; }

        /// <summary>
        /// Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
        /// </summary>
        [Input("sessionRedisPassword")]
        public Input<string>? SessionRedisPassword { get; set; }

        /// <summary>
        /// The Redis port.
        /// </summary>
        [Input("sessionRedisPort")]
        public Input<int>? SessionRedisPort { get; set; }

        /// <summary>
        /// The Redis session key prefix.
        /// </summary>
        [Input("sessionRedisPrefix")]
        public Input<string>? SessionRedisPrefix { get; set; }

        /// <summary>
        /// Session redis read timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisReadTimeout")]
        public Input<int>? SessionRedisReadTimeout { get; set; }

        /// <summary>
        /// Session redis send timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisSendTimeout")]
        public Input<int>? SessionRedisSendTimeout { get; set; }

        /// <summary>
        /// The SNI used for connecting the Redis server.
        /// </summary>
        [Input("sessionRedisServerName")]
        public Input<string>? SessionRedisServerName { get; set; }

        /// <summary>
        /// The Redis unix socket path.
        /// </summary>
        [Input("sessionRedisSocket")]
        public Input<string>? SessionRedisSocket { get; set; }

        /// <summary>
        /// Use SSL/TLS for Redis connection.
        /// </summary>
        [Input("sessionRedisSsl")]
        public Input<bool>? SessionRedisSsl { get; set; }

        /// <summary>
        /// Verify identity provider server certificate.
        /// </summary>
        [Input("sessionRedisSslVerify")]
        public Input<bool>? SessionRedisSslVerify { get; set; }

        /// <summary>
        /// Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
        /// </summary>
        [Input("sessionRedisUsername")]
        public Input<string>? SessionRedisUsername { get; set; }

        /// <summary>
        /// Enables or disables persistent sessions.
        /// </summary>
        [Input("sessionRemember")]
        public Input<bool>? SessionRemember { get; set; }

        /// <summary>
        /// Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
        /// </summary>
        [Input("sessionRememberAbsoluteTimeout")]
        public Input<double>? SessionRememberAbsoluteTimeout { get; set; }

        /// <summary>
        /// Persistent session cookie name. Use with the `remember` configuration parameter.
        /// </summary>
        [Input("sessionRememberCookieName")]
        public Input<string>? SessionRememberCookieName { get; set; }

        /// <summary>
        /// Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
        /// </summary>
        [Input("sessionRememberRollingTimeout")]
        public Input<double>? SessionRememberRollingTimeout { get; set; }

        [Input("sessionRequestHeaders")]
        private InputList<string>? _sessionRequestHeaders;

        /// <summary>
        /// Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
        /// </summary>
        public InputList<string> SessionRequestHeaders
        {
            get => _sessionRequestHeaders ?? (_sessionRequestHeaders = new InputList<string>());
            set => _sessionRequestHeaders = value;
        }

        [Input("sessionResponseHeaders")]
        private InputList<string>? _sessionResponseHeaders;

        /// <summary>
        /// Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
        /// </summary>
        public InputList<string> SessionResponseHeaders
        {
            get => _sessionResponseHeaders ?? (_sessionResponseHeaders = new InputList<string>());
            set => _sessionResponseHeaders = value;
        }

        /// <summary>
        /// Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
        /// </summary>
        [Input("sessionRollingTimeout")]
        public Input<double>? SessionRollingTimeout { get; set; }

        /// <summary>
        /// The session secret.
        /// </summary>
        [Input("sessionSecret")]
        public Input<string>? SessionSecret { get; set; }

        /// <summary>
        /// The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        /// </summary>
        [Input("sessionStorage")]
        public Input<string>? SessionStorage { get; set; }

        /// <summary>
        /// Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
        /// </summary>
        [Input("sessionStoreMetadata")]
        public Input<bool>? SessionStoreMetadata { get; set; }

        /// <summary>
        /// Verify identity provider server certificate. If set to `true`, the plugin uses the CA certificate set in the `kong.conf` config parameter `lua_ssl_trusted_certificate`.
        /// </summary>
        [Input("sslVerify")]
        public Input<bool>? SslVerify { get; set; }

        /// <summary>
        /// Network IO timeout in milliseconds.
        /// </summary>
        [Input("timeout")]
        public Input<double>? Timeout { get; set; }

        /// <summary>
        /// ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
        /// </summary>
        [Input("tlsClientAuthCertId")]
        public Input<string>? TlsClientAuthCertId { get; set; }

        /// <summary>
        /// Verify identity provider server certificate during mTLS client authentication.
        /// </summary>
        [Input("tlsClientAuthSslVerify")]
        public Input<bool>? TlsClientAuthSslVerify { get; set; }

        /// <summary>
        /// Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
        /// </summary>
        [Input("tokenCacheKeyIncludeScope")]
        public Input<bool>? TokenCacheKeyIncludeScope { get; set; }

        /// <summary>
        /// The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("tokenEndpoint")]
        public Input<string>? TokenEndpoint { get; set; }

        /// <summary>
        /// The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate. must be one of ["client_secret_basic", "client_secret_post", "client_secret_jwt", "private_key_jwt", "tls_client_auth", "self_signed_tls_client_auth", "none"]
        /// </summary>
        [Input("tokenEndpointAuthMethod")]
        public Input<string>? TokenEndpointAuthMethod { get; set; }

        /// <summary>
        /// The token exchange endpoint.
        /// </summary>
        [Input("tokenExchangeEndpoint")]
        public Input<string>? TokenExchangeEndpoint { get; set; }

        [Input("tokenHeadersClients")]
        private InputList<string>? _tokenHeadersClients;

        /// <summary>
        /// Extra headers passed from the client to the token endpoint.
        /// </summary>
        public InputList<string> TokenHeadersClients
        {
            get => _tokenHeadersClients ?? (_tokenHeadersClients = new InputList<string>());
            set => _tokenHeadersClients = value;
        }

        [Input("tokenHeadersGrants")]
        private InputList<string>? _tokenHeadersGrants;

        /// <summary>
        /// Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
        /// </summary>
        public InputList<string> TokenHeadersGrants
        {
            get => _tokenHeadersGrants ?? (_tokenHeadersGrants = new InputList<string>());
            set => _tokenHeadersGrants = value;
        }

        [Input("tokenHeadersNames")]
        private InputList<string>? _tokenHeadersNames;

        /// <summary>
        /// Extra header names passed to the token endpoint.
        /// </summary>
        public InputList<string> TokenHeadersNames
        {
            get => _tokenHeadersNames ?? (_tokenHeadersNames = new InputList<string>());
            set => _tokenHeadersNames = value;
        }

        /// <summary>
        /// Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
        /// </summary>
        [Input("tokenHeadersPrefix")]
        public Input<string>? TokenHeadersPrefix { get; set; }

        [Input("tokenHeadersReplays")]
        private InputList<string>? _tokenHeadersReplays;

        /// <summary>
        /// The names of token endpoint response headers to forward to the downstream client.
        /// </summary>
        public InputList<string> TokenHeadersReplays
        {
            get => _tokenHeadersReplays ?? (_tokenHeadersReplays = new InputList<string>());
            set => _tokenHeadersReplays = value;
        }

        [Input("tokenHeadersValues")]
        private InputList<string>? _tokenHeadersValues;

        /// <summary>
        /// Extra header values passed to the token endpoint.
        /// </summary>
        public InputList<string> TokenHeadersValues
        {
            get => _tokenHeadersValues ?? (_tokenHeadersValues = new InputList<string>());
            set => _tokenHeadersValues = value;
        }

        [Input("tokenPostArgsClients")]
        private InputList<string>? _tokenPostArgsClients;

        /// <summary>
        /// Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Request Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
        /// </summary>
        public InputList<string> TokenPostArgsClients
        {
            get => _tokenPostArgsClients ?? (_tokenPostArgsClients = new InputList<string>());
            set => _tokenPostArgsClients = value;
        }

        [Input("tokenPostArgsNames")]
        private InputList<string>? _tokenPostArgsNames;

        /// <summary>
        /// Extra post argument names passed to the token endpoint.
        /// </summary>
        public InputList<string> TokenPostArgsNames
        {
            get => _tokenPostArgsNames ?? (_tokenPostArgsNames = new InputList<string>());
            set => _tokenPostArgsNames = value;
        }

        [Input("tokenPostArgsValues")]
        private InputList<string>? _tokenPostArgsValues;

        /// <summary>
        /// Extra post argument values passed to the token endpoint.
        /// </summary>
        public InputList<string> TokenPostArgsValues
        {
            get => _tokenPostArgsValues ?? (_tokenPostArgsValues = new InputList<string>());
            set => _tokenPostArgsValues = value;
        }

        /// <summary>
        /// Destroy any active session for the unauthorized requests.
        /// </summary>
        [Input("unauthorizedDestroySession")]
        public Input<bool>? UnauthorizedDestroySession { get; set; }

        /// <summary>
        /// The error message for the unauthorized requests (when not using the redirection).
        /// </summary>
        [Input("unauthorizedErrorMessage")]
        public Input<string>? UnauthorizedErrorMessage { get; set; }

        [Input("unauthorizedRedirectUris")]
        private InputList<string>? _unauthorizedRedirectUris;

        /// <summary>
        /// Where to redirect the client on unauthorized requests.
        /// </summary>
        public InputList<string> UnauthorizedRedirectUris
        {
            get => _unauthorizedRedirectUris ?? (_unauthorizedRedirectUris = new InputList<string>());
            set => _unauthorizedRedirectUris = value;
        }

        [Input("unexpectedRedirectUris")]
        private InputList<string>? _unexpectedRedirectUris;

        /// <summary>
        /// Where to redirect the client when unexpected errors happen with the requests.
        /// </summary>
        public InputList<string> UnexpectedRedirectUris
        {
            get => _unexpectedRedirectUris ?? (_unexpectedRedirectUris = new InputList<string>());
            set => _unexpectedRedirectUris = value;
        }

        /// <summary>
        /// The upstream access token header.
        /// </summary>
        [Input("upstreamAccessTokenHeader")]
        public Input<string>? UpstreamAccessTokenHeader { get; set; }

        /// <summary>
        /// The upstream access token JWK header.
        /// </summary>
        [Input("upstreamAccessTokenJwkHeader")]
        public Input<string>? UpstreamAccessTokenJwkHeader { get; set; }

        [Input("upstreamHeadersClaims")]
        private InputList<string>? _upstreamHeadersClaims;

        /// <summary>
        /// The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
        /// </summary>
        public InputList<string> UpstreamHeadersClaims
        {
            get => _upstreamHeadersClaims ?? (_upstreamHeadersClaims = new InputList<string>());
            set => _upstreamHeadersClaims = value;
        }

        [Input("upstreamHeadersNames")]
        private InputList<string>? _upstreamHeadersNames;

        /// <summary>
        /// The upstream header names for the claim values.
        /// </summary>
        public InputList<string> UpstreamHeadersNames
        {
            get => _upstreamHeadersNames ?? (_upstreamHeadersNames = new InputList<string>());
            set => _upstreamHeadersNames = value;
        }

        /// <summary>
        /// The upstream id token header.
        /// </summary>
        [Input("upstreamIdTokenHeader")]
        public Input<string>? UpstreamIdTokenHeader { get; set; }

        /// <summary>
        /// The upstream id token JWK header.
        /// </summary>
        [Input("upstreamIdTokenJwkHeader")]
        public Input<string>? UpstreamIdTokenJwkHeader { get; set; }

        /// <summary>
        /// The upstream introspection header.
        /// </summary>
        [Input("upstreamIntrospectionHeader")]
        public Input<string>? UpstreamIntrospectionHeader { get; set; }

        /// <summary>
        /// The upstream introspection JWT header.
        /// </summary>
        [Input("upstreamIntrospectionJwtHeader")]
        public Input<string>? UpstreamIntrospectionJwtHeader { get; set; }

        /// <summary>
        /// The upstream refresh token header.
        /// </summary>
        [Input("upstreamRefreshTokenHeader")]
        public Input<string>? UpstreamRefreshTokenHeader { get; set; }

        /// <summary>
        /// The upstream session id header.
        /// </summary>
        [Input("upstreamSessionIdHeader")]
        public Input<string>? UpstreamSessionIdHeader { get; set; }

        /// <summary>
        /// The upstream user info header.
        /// </summary>
        [Input("upstreamUserInfoHeader")]
        public Input<string>? UpstreamUserInfoHeader { get; set; }

        /// <summary>
        /// The upstream user info JWT header (in case the user info returns a JWT response).
        /// </summary>
        [Input("upstreamUserInfoJwtHeader")]
        public Input<string>? UpstreamUserInfoJwtHeader { get; set; }

        /// <summary>
        /// The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document). must be one of ["application/json", "application/jwt"]
        /// </summary>
        [Input("userinfoAccept")]
        public Input<string>? UserinfoAccept { get; set; }

        /// <summary>
        /// The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
        /// </summary>
        [Input("userinfoEndpoint")]
        public Input<string>? UserinfoEndpoint { get; set; }

        [Input("userinfoHeadersClients")]
        private InputList<string>? _userinfoHeadersClients;

        /// <summary>
        /// Extra headers passed from the client to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoHeadersClients
        {
            get => _userinfoHeadersClients ?? (_userinfoHeadersClients = new InputList<string>());
            set => _userinfoHeadersClients = value;
        }

        [Input("userinfoHeadersNames")]
        private InputList<string>? _userinfoHeadersNames;

        /// <summary>
        /// Extra header names passed to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoHeadersNames
        {
            get => _userinfoHeadersNames ?? (_userinfoHeadersNames = new InputList<string>());
            set => _userinfoHeadersNames = value;
        }

        [Input("userinfoHeadersValues")]
        private InputList<string>? _userinfoHeadersValues;

        /// <summary>
        /// Extra header values passed to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoHeadersValues
        {
            get => _userinfoHeadersValues ?? (_userinfoHeadersValues = new InputList<string>());
            set => _userinfoHeadersValues = value;
        }

        [Input("userinfoQueryArgsClients")]
        private InputList<string>? _userinfoQueryArgsClients;

        /// <summary>
        /// Extra query arguments passed from the client to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoQueryArgsClients
        {
            get => _userinfoQueryArgsClients ?? (_userinfoQueryArgsClients = new InputList<string>());
            set => _userinfoQueryArgsClients = value;
        }

        [Input("userinfoQueryArgsNames")]
        private InputList<string>? _userinfoQueryArgsNames;

        /// <summary>
        /// Extra query argument names passed to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoQueryArgsNames
        {
            get => _userinfoQueryArgsNames ?? (_userinfoQueryArgsNames = new InputList<string>());
            set => _userinfoQueryArgsNames = value;
        }

        [Input("userinfoQueryArgsValues")]
        private InputList<string>? _userinfoQueryArgsValues;

        /// <summary>
        /// Extra query argument values passed to the user info endpoint.
        /// </summary>
        public InputList<string> UserinfoQueryArgsValues
        {
            get => _userinfoQueryArgsValues ?? (_userinfoQueryArgsValues = new InputList<string>());
            set => _userinfoQueryArgsValues = value;
        }

        /// <summary>
        /// If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
        /// </summary>
        [Input("usingPseudoIssuer")]
        public Input<bool>? UsingPseudoIssuer { get; set; }

        /// <summary>
        /// Verify tokens for standard claims.
        /// </summary>
        [Input("verifyClaims")]
        public Input<bool>? VerifyClaims { get; set; }

        /// <summary>
        /// Verify nonce on authorization code flow.
        /// </summary>
        [Input("verifyNonce")]
        public Input<bool>? VerifyNonce { get; set; }

        /// <summary>
        /// Verify plugin configuration against discovery.
        /// </summary>
        [Input("verifyParameters")]
        public Input<bool>? VerifyParameters { get; set; }

        /// <summary>
        /// Verify signature of tokens.
        /// </summary>
        [Input("verifySignature")]
        public Input<bool>? VerifySignature { get; set; }

        public GatewayPluginOpenidConnectConfigGetArgs()
        {
        }
        public static new GatewayPluginOpenidConnectConfigGetArgs Empty => new GatewayPluginOpenidConnectConfigGetArgs();
    }
}
