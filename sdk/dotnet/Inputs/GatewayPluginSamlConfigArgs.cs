// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Konnect.Inputs
{

    public sealed class GatewayPluginSamlConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// An optional string (consumer UUID or username) value to use as an “anonymous” consumer. If not set, a Kong Consumer must exist for the SAML IdP user credentials, mapping the username format to the Kong Consumer username.
        /// </summary>
        [Input("anonymous")]
        public Input<string>? Anonymous { get; set; }

        /// <summary>
        /// A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        /// </summary>
        [Input("assertionConsumerPath")]
        public Input<string>? AssertionConsumerPath { get; set; }

        /// <summary>
        /// The public certificate provided by the IdP. This is used to validate responses from the IdP.  Only include the contents of the certificate. Do not include the header (`BEGIN CERTIFICATE`) and footer (`END CERTIFICATE`) lines.
        /// </summary>
        [Input("idpCertificate")]
        public Input<string>? IdpCertificate { get; set; }

        /// <summary>
        /// A string representing a URL, such as https://example.com/path/to/resource?q=search.
        /// </summary>
        [Input("idpSsoUrl")]
        public Input<string>? IdpSsoUrl { get; set; }

        /// <summary>
        /// The unique identifier of the IdP application. Formatted as a URL containing information about the IdP so the SP can validate that the SAML assertions it receives are issued from the correct IdP.
        /// </summary>
        [Input("issuer")]
        public Input<string>? Issuer { get; set; }

        /// <summary>
        /// The requested `NameId` format. Options available are: - `Unspecified` - `EmailAddress` - `Persistent` - `Transient`. must be one of ["Unspecified", "EmailAddress", "Persistent", "Transient"]
        /// </summary>
        [Input("nameidFormat")]
        public Input<string>? NameidFormat { get; set; }

        /// <summary>
        /// The digest algorithm for Authn requests: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        /// </summary>
        [Input("requestDigestAlgorithm")]
        public Input<string>? RequestDigestAlgorithm { get; set; }

        /// <summary>
        /// The signature algorithm for signing Authn requests. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        /// </summary>
        [Input("requestSignatureAlgorithm")]
        public Input<string>? RequestSignatureAlgorithm { get; set; }

        /// <summary>
        /// The certificate for signing requests.
        /// </summary>
        [Input("requestSigningCertificate")]
        public Input<string>? RequestSigningCertificate { get; set; }

        /// <summary>
        /// The private key for signing requests.  If this parameter is set, requests sent to the IdP are signed.  The `request_signing_certificate` parameter must be set as well.
        /// </summary>
        [Input("requestSigningKey")]
        public Input<string>? RequestSigningKey { get; set; }

        /// <summary>
        /// The algorithm for verifying digest in SAML responses: - `SHA256` - `SHA1`. must be one of ["SHA256", "SHA1"]
        /// </summary>
        [Input("responseDigestAlgorithm")]
        public Input<string>? ResponseDigestAlgorithm { get; set; }

        /// <summary>
        /// The private encryption key required to decrypt encrypted assertions.
        /// </summary>
        [Input("responseEncryptionKey")]
        public Input<string>? ResponseEncryptionKey { get; set; }

        /// <summary>
        /// The algorithm for validating signatures in SAML responses. Options available are: - `SHA256` - `SHA384` - `SHA512`. must be one of ["SHA256", "SHA384", "SHA512"]
        /// </summary>
        [Input("responseSignatureAlgorithm")]
        public Input<string>? ResponseSignatureAlgorithm { get; set; }

        /// <summary>
        /// The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        /// </summary>
        [Input("sessionAbsoluteTimeout")]
        public Input<double>? SessionAbsoluteTimeout { get; set; }

        /// <summary>
        /// The session audience, for example "my-application"
        /// </summary>
        [Input("sessionAudience")]
        public Input<string>? SessionAudience { get; set; }

        /// <summary>
        /// The session cookie domain flag.
        /// </summary>
        [Input("sessionCookieDomain")]
        public Input<string>? SessionCookieDomain { get; set; }

        /// <summary>
        /// Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
        /// </summary>
        [Input("sessionCookieHttpOnly")]
        public Input<bool>? SessionCookieHttpOnly { get; set; }

        /// <summary>
        /// The session cookie name.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// A string representing a URL path, such as /path/to/resource. Must start with a forward slash (/) and must not contain empty segments (i.e., two consecutive forward slashes).
        /// </summary>
        [Input("sessionCookiePath")]
        public Input<string>? SessionCookiePath { get; set; }

        /// <summary>
        /// Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks. must be one of ["Strict", "Lax", "None", "Default"]
        /// </summary>
        [Input("sessionCookieSameSite")]
        public Input<string>? SessionCookieSameSite { get; set; }

        /// <summary>
        /// The cookie is only sent to the server when a request is made with the https:scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
        /// </summary>
        [Input("sessionCookieSecure")]
        public Input<bool>? SessionCookieSecure { get; set; }

        /// <summary>
        /// When set to `true`, audiences are forced to share the same subject.
        /// </summary>
        [Input("sessionEnforceSameSubject")]
        public Input<bool>? SessionEnforceSameSubject { get; set; }

        /// <summary>
        /// When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
        /// </summary>
        [Input("sessionHashStorageKey")]
        public Input<bool>? SessionHashStorageKey { get; set; }

        /// <summary>
        /// When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
        /// </summary>
        [Input("sessionHashSubject")]
        public Input<bool>? SessionHashSubject { get; set; }

        /// <summary>
        /// The session cookie idle time in seconds.
        /// </summary>
        [Input("sessionIdlingTimeout")]
        public Input<double>? SessionIdlingTimeout { get; set; }

        /// <summary>
        /// The memcached host.
        /// </summary>
        [Input("sessionMemcachedHost")]
        public Input<string>? SessionMemcachedHost { get; set; }

        /// <summary>
        /// An integer representing a port number between 0 and 65535, inclusive.
        /// </summary>
        [Input("sessionMemcachedPort")]
        public Input<int>? SessionMemcachedPort { get; set; }

        /// <summary>
        /// The memcached session key prefix.
        /// </summary>
        [Input("sessionMemcachedPrefix")]
        public Input<string>? SessionMemcachedPrefix { get; set; }

        /// <summary>
        /// The memcached unix socket path.
        /// </summary>
        [Input("sessionMemcachedSocket")]
        public Input<string>? SessionMemcachedSocket { get; set; }

        /// <summary>
        /// The Redis cluster maximum redirects.
        /// </summary>
        [Input("sessionRedisClusterMaxRedirections")]
        public Input<int>? SessionRedisClusterMaxRedirections { get; set; }

        [Input("sessionRedisClusterNodes")]
        private InputList<Inputs.GatewayPluginSamlConfigSessionRedisClusterNodeArgs>? _sessionRedisClusterNodes;

        /// <summary>
        /// The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
        /// </summary>
        public InputList<Inputs.GatewayPluginSamlConfigSessionRedisClusterNodeArgs> SessionRedisClusterNodes
        {
            get => _sessionRedisClusterNodes ?? (_sessionRedisClusterNodes = new InputList<Inputs.GatewayPluginSamlConfigSessionRedisClusterNodeArgs>());
            set => _sessionRedisClusterNodes = value;
        }

        /// <summary>
        /// The Redis connection timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisConnectTimeout")]
        public Input<int>? SessionRedisConnectTimeout { get; set; }

        /// <summary>
        /// The Redis host IP.
        /// </summary>
        [Input("sessionRedisHost")]
        public Input<string>? SessionRedisHost { get; set; }

        /// <summary>
        /// Password to use for Redis connection when the `redis` session storage is defined. If undefined, no auth commands are sent to Redis. This value is pulled from
        /// </summary>
        [Input("sessionRedisPassword")]
        public Input<string>? SessionRedisPassword { get; set; }

        /// <summary>
        /// An integer representing a port number between 0 and 65535, inclusive.
        /// </summary>
        [Input("sessionRedisPort")]
        public Input<int>? SessionRedisPort { get; set; }

        /// <summary>
        /// The Redis session key prefix.
        /// </summary>
        [Input("sessionRedisPrefix")]
        public Input<string>? SessionRedisPrefix { get; set; }

        /// <summary>
        /// The Redis read timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisReadTimeout")]
        public Input<int>? SessionRedisReadTimeout { get; set; }

        /// <summary>
        /// The Redis send timeout in milliseconds.
        /// </summary>
        [Input("sessionRedisSendTimeout")]
        public Input<int>? SessionRedisSendTimeout { get; set; }

        /// <summary>
        /// The SNI used for connecting to the Redis server.
        /// </summary>
        [Input("sessionRedisServerName")]
        public Input<string>? SessionRedisServerName { get; set; }

        /// <summary>
        /// The Redis unix socket path.
        /// </summary>
        [Input("sessionRedisSocket")]
        public Input<string>? SessionRedisSocket { get; set; }

        /// <summary>
        /// Use SSL/TLS for the Redis connection.
        /// </summary>
        [Input("sessionRedisSsl")]
        public Input<bool>? SessionRedisSsl { get; set; }

        /// <summary>
        /// Verify the Redis server certificate.
        /// </summary>
        [Input("sessionRedisSslVerify")]
        public Input<bool>? SessionRedisSslVerify { get; set; }

        /// <summary>
        /// Redis username if the `redis` session storage is defined and ACL authentication is desired.If undefined, ACL authentication will not be performed.  This requires Redis v6.0.0+. The username **cannot** be set to `default`.
        /// </summary>
        [Input("sessionRedisUsername")]
        public Input<string>? SessionRedisUsername { get; set; }

        /// <summary>
        /// Enables or disables persistent sessions
        /// </summary>
        [Input("sessionRemember")]
        public Input<bool>? SessionRemember { get; set; }

        /// <summary>
        /// Persistent session absolute timeout in seconds.
        /// </summary>
        [Input("sessionRememberAbsoluteTimeout")]
        public Input<double>? SessionRememberAbsoluteTimeout { get; set; }

        /// <summary>
        /// Persistent session cookie name
        /// </summary>
        [Input("sessionRememberCookieName")]
        public Input<string>? SessionRememberCookieName { get; set; }

        /// <summary>
        /// Persistent session rolling timeout in seconds.
        /// </summary>
        [Input("sessionRememberRollingTimeout")]
        public Input<double>? SessionRememberRollingTimeout { get; set; }

        [Input("sessionRequestHeaders")]
        private InputList<string>? _sessionRequestHeaders;
        public InputList<string> SessionRequestHeaders
        {
            get => _sessionRequestHeaders ?? (_sessionRequestHeaders = new InputList<string>());
            set => _sessionRequestHeaders = value;
        }

        [Input("sessionResponseHeaders")]
        private InputList<string>? _sessionResponseHeaders;
        public InputList<string> SessionResponseHeaders
        {
            get => _sessionResponseHeaders ?? (_sessionResponseHeaders = new InputList<string>());
            set => _sessionResponseHeaders = value;
        }

        /// <summary>
        /// The session cookie absolute timeout in seconds. Specifies how long the session can be used until it is no longer valid.
        /// </summary>
        [Input("sessionRollingTimeout")]
        public Input<double>? SessionRollingTimeout { get; set; }

        /// <summary>
        /// The session secret. This must be a random string of 32 characters from the base64 alphabet (letters, numbers, `/`, `_` and `+`). It is used as the secret key for encrypting session data as well as state information that is sent to the IdP in the authentication exchange.
        /// </summary>
        [Input("sessionSecret")]
        public Input<string>? SessionSecret { get; set; }

        /// <summary>
        /// The session storage for session data: - `cookie`: stores session data with the session cookie. The session cannot be invalidated or revoked without changing the session secret, but is stateless, and doesn't require a database. - `memcached`: stores session data in memcached - `redis`: stores session data in Redis. must be one of ["cookie", "memcache", "memcached", "redis"]
        /// </summary>
        [Input("sessionStorage")]
        public Input<string>? SessionStorage { get; set; }

        /// <summary>
        /// Configures whether or not session metadata should be stored. This includes information about the active sessions for the `specific_audience` belonging to a specific subject.
        /// </summary>
        [Input("sessionStoreMetadata")]
        public Input<bool>? SessionStoreMetadata { get; set; }

        /// <summary>
        /// Enable signature validation for SAML responses.
        /// </summary>
        [Input("validateAssertionSignature")]
        public Input<bool>? ValidateAssertionSignature { get; set; }

        public GatewayPluginSamlConfigArgs()
        {
        }
        public static new GatewayPluginSamlConfigArgs Empty => new GatewayPluginSamlConfigArgs();
    }
}
